<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>promise</title>
    <link href="/2022/04/14/promise/"/>
    <url>/2022/04/14/promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="promise代码"><a href="#promise代码" class="headerlink" title="promise代码"></a>promise代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>  resolve();<br>  <span class="hljs-comment">// reject();</span><br>&#125;);<br>p1.then(<span class="hljs-function">() =&gt;</span> &#123;&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="promise的三个状态"><a href="#promise的三个状态" class="headerlink" title="promise的三个状态"></a>promise的三个状态</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li>pending</li><li>fulfilled(resolved)</li><li>rejected</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>不可逆</li><li>只能从 pending-&gt;fulfilled 或者 pending-&gt;rejected</li></ul><h3 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h3><p>执行resolve()  该promise的状态则 pending-&gt;fulfilled<br>执行reject()  该promise的状态则 pending-&gt;rejected</p><h3 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h3><p>resolved状态的promise可以触发then回调<br>rejected状态的promise可以触发catch回调</p><h2 id="then-catch-怎么影响状态的变化"><a href="#then-catch-怎么影响状态的变化" class="headerlink" title="then\catch 怎么影响状态的变化"></a>then\catch 怎么影响状态的变化</h2><p>then正常返回resolved,如果有报错则 返回rejected<br>catch正常返回resolved,如果有报错则 返回rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;then error&#x27;</span>)<br>&#125;) <span class="hljs-comment">// rejected状态的promise 后续p2的then则不会触发</span><br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;bug&quot;</span>)<br>&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-comment">//2</span><br>&#125;).then(<span class="hljs-function">()=&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<span class="hljs-comment">//3 注意这边catch正常的返回也是resolved状态的promise，是可以触发后续的then回调的</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, promise, async, await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试高频题</title>
    <link href="/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <url>/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="手写系列"><a href="#手写系列" class="headerlink" title="手写系列"></a>手写系列</h2><h3 id="题目一：实现深度clone"><a href="#题目一：实现深度clone" class="headerlink" title="题目一：实现深度clone"></a>题目一：实现深度clone</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params"> obj=&#123;&#125; </span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object || obj == null) &#123;</span><br><span class="hljs-string">    return obj;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  let res;</span><br><span class="hljs-string">  if(obj instanceof Array) &#123;</span><br><span class="hljs-string">    res = [];</span><br><span class="hljs-string">  &#125;else &#123;</span><br><span class="hljs-string">    res = &#123;&#125;;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  for(let item in obj) &#123;</span><br><span class="hljs-string">    if(obj.hasOwnProperty(item)) &#123;</span><br><span class="hljs-string">      res[item] = deepClone(obj[item])</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  return res;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="题目二：实现节流和防抖"><a href="#题目二：实现节流和防抖" class="headerlink" title="题目二：实现节流和防抖"></a>题目二：实现节流和防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// throttle 节流</span><br><span class="hljs-comment">// 用户会反复触发一些操作，比如鼠标移动事件，此时只需要指定一个“巡视”的间隔时间，不管用户期间触发多少次，只会在间隔点上执行给定的回调函数 scroll条</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,threshold = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-number">0</span>;<br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span>(current - start &gt;= threshold) &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments);<br>      start = current;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), threshold, ...arguments);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// debounce 防抖</span><br><span class="hljs-comment">// 给一个固定时间，如果你开始触发动作，并且在这个固定时间内不再有任何动作，我就执行一次，否则我每次都会重新开始计时 搜索框</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span> (<span class="hljs-params">fn, delay = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 重新计时</span><br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), delay, ...arguments);<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><h3 id="题目三：实现call-apply-bind函数"><a href="#题目三：实现call-apply-bind函数" class="headerlink" title="题目三：实现call,apply,bind函数"></a>题目三：实现call,apply,bind函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//区别 call(assigned this object, other arguments function may need) apply(assigned this object, [other arguments]) bind(not imediately</span><br><span class="hljs-comment">//invoke,return a function,arguments are same as call)</span><br></code></pre></td></tr></table></figure><h3 id="题目四：实现简单的Promise"><a href="#题目四：实现简单的Promise" class="headerlink" title="题目四：实现简单的Promise"></a>题目四：实现简单的Promise</h3><h3 id="题目五：实现new函数"><a href="#题目五：实现new函数" class="headerlink" title="题目五：实现new函数"></a>题目五：实现new函数</h3>]]></content>
    
    
    
    <tags>
      
      <tag>高频题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题运行环境相关</title>
    <link href="/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="前端运行环境"><a href="#前端运行环境" class="headerlink" title="前端运行环境"></a>前端运行环境</h1><h2 id="网页是如何被渲染出来的"><a href="#网页是如何被渲染出来的" class="headerlink" title="网页是如何被渲染出来的"></a>网页是如何被渲染出来的</h2><blockquote><ol><li>从输入url到渲染出页面的过程</li></ol></blockquote><ol><li>加载资源的形式</li><li>加载资源的过程</li><li>渲染页面的过程</li></ol><p>详细步骤：</p><ol><li>dns解析域名对应的ip</li><li>tcp三次握手  seq = 1 ; seq = 1,ack = 1+1; seq=1+1,ack=1+1</li><li>浏览器发送请求</li><li>服务器处理请求并返回信息</li><li>浏览器解析渲染<ul><li>浏览器将获取的 HTML 文档解析成 DOM 树；</li><li>处理 CSS 标记，构成层叠样式表模型（CSSOM）；</li><li>将 DOM 和 CSSOM 合并为渲染树（rendering tree）；</li><li>渲染树的每个元素的内容都是计算过的，称之为 布局layout；</li><li>将渲染树上的各个节点绘制到屏幕上，称之为 绘制painting；</li></ul></li></ol><blockquote><ol start="2"><li>window.onload和DOMContentLoaded的区别</li></ol></blockquote><p>window.onload 所有的资源全部加载完成</p><p>DOMContentLoaded dom渲染完毕即可 图片视频之类的可能还没加载完</p>]]></content>
    
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数组方法</title>
    <link href="/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JS常用数组方法"><a href="#JS常用数组方法" class="headerlink" title="JS常用数组方法"></a>JS常用数组方法</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ol><li><p>特点：能存储 有序节点 可以在已知的两个元素中间插入新的元素</p></li><li><p>创建数组的两种方法：<br>var arr = [];<br>var arr = new Array(); //用的居然是小括号 一般不用这个方法</p></li><li><p>获取元素：arr[0];获取下标为0的元素<br>替换元素：arr[3] = “fruit” 如果之前没有下标为3的元素 则在3位置处添加新的元素</p></li><li><p>length 数组长度</p></li><li><p>数组内部可以存储所有类型元素  包括数组和对象<br>var arr = [{name:”john”,age:19},12,”hello”];<br>console.log(arr[0].name);//显示为john</p></li><li><p>queue（队列）方法：pop/push  shift/unshift<br>push在队列末端插入新元素   shift在队列前端取出第一个元素并返回他，后续元素向前移动一格<br>unshift：在队列前端插入新元素 push和unshift都可以一次添加多个元素</p></li><li><p>stack（栈）方法：push/pop<br>push pop都是在末端插入或取出元素 只能是一个元素</p></li><li><p>数组同时支持先进先出(lifo)和后进先出(fifo)   是双端队列</p></li><li><p>从本质上讲  数组也是一个对象   复制数组也是复制的引用</p></li></ol><p>最后  强调 数组必须是用于  有序数据  的特殊结构 如果不按照有序数组来操作 那么就不会享受到数组的优化</p><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ol><li><p>插入提取方法</p><ul><li>arr.push 从尾部插入</li><li>arr.pop 从尾部提取</li><li>arr.shift 从头部提取</li><li>arr.unshift  从头部插入</li></ul></li><li><p>splice方法 ：可以实现 添加 删除 插入元素等操作</p><ul><li>插入或删除的起始下标：1就是替换第二个元素</li><li>删除的个数：0表示添加</li><li>添加或者要更换的元素</li></ul></li></ol><blockquote><p>splice(1,1) <em>删除</em>：从下标为1的位置删掉1个元素 splice返回的就是被删除掉的元素<br>splice(0,3,”let’s”,”dance”) <em>替换</em>：从下标为0的位置删掉3个元素 并用let’s dance替换在被删掉的区域<br>splice(1,0,”hello”,”world”) <em>添加</em>：从下标为1的位置向后添加2个元素 添加在下标为1和2的位置</p></blockquote><ol start="3"><li><p>slice方法：切片功能 slice(a,b) 切出从a下标到b下标之前的的元素 左闭右开（左边包括 右边不包括）</p><p> arr.slice()不带参数调用的话 就是创建一份新的arr副本<br> 其中b是可选的，不写的话就是从a切到末尾。<br> arr.slice()返回的是切出来的值组成的[a,b)<br> 对 <em>原数组</em> 是没有影响的</p></li><li><p>concat方法：<br>链接方法：arr.concat(a,b)将a和b连接到arr数组的最后。 如果a也是数组 则会提取出数组中的数值 添加到arr后面 ，如果不是数组，其他元素都会以本来的形式插入到数组arr中。</p></li><li><p>arr.foreach()方法：可以为数组中每一个元素运行方法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&quot;Bilbo&quot;</span>, <span class="hljs-string">&quot;Gandalf&quot;</span>, <span class="hljs-string">&quot;Nazgul&quot;</span>].forEach(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123;<br>  alert(<span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span> is at index <span class="hljs-subst">$&#123;index&#125;</span> in <span class="hljs-subst">$&#123;array&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="6"><li><p>arr.indexOf(item,from) / arr.lastIndexOf(item,from) /arr.includes(item,from) 返回item元素在数组中的下标<br>from指从哪一个下标位置开始查询</p></li><li><p>转换数组 arr.map() 对数组内所有元素调用某个方法 返回该方法返回值组成的新数组</p></li></ol><p>格式:<code>let res = arr.map(function(item,index,array)&#123;&#125;)</code><br>示例：<code>let length = [&quot;heloo&quot;,&quot;jack&quot;,&quot;tom&quot;].map(item =&gt; item.length);</code></p><ol start="8"><li><p>arr.sort() 对数组进行原位排序  排序之后的结果返回到这个数组本身 等于是修改了原数组 默认是按字符串排序</p></li><li><p>利用sort函数 对数字进行排序操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span> ];<br><br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;); 只需要比较函数返回正数或者负数就可以完成数组的排序<br><br>alert(arr);  <span class="hljs-comment">// 1, 2, 15</span><br>  <span class="hljs-comment">// 还有更简洁的：箭头函数</span><br>arr.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> <span class="hljs-keyword">return</span> a-b;);<span class="hljs-comment">//原答案return都没有写</span><br></code></pre></td></tr></table></figure></li><li><p>arr.reverse()<br>用于颠倒数组中的元素顺序</p></li><li><p>分割字符串<br>let names = ‘Bilbo, Gandalf, Nazgul’;<br>let arr = names.split(‘, ‘);<br>for (let name of arr) {<br>alert( <code>A message to $&#123;name&#125;.</code> ); // A message to Bilbo（和其他名字）<br>}</p></li><li><p>黏合字符串 与上面分割字符串正好相反：arr.join()<br>let arr = [‘Bilbo’, ‘Gandalf’, ‘Nazgul’];<br>let str = arr.join(‘;’); // 使用分号 ; 将数组粘合成字符串<br>alert( str ); // Bilbo;Gandalf;Nazgul</p></li><li><p>arr.reduce()方法：该函数一个接一个地应用于arr数组的所有元素 并将前一次结果作为参数传给下一次调用 其中accumulator是用来储存<em>上一次计算结果</em>的 可以用作类似求和的需求<br>let value = arr.reduce(function(accumulator, item, index, array)<br>示例：<br>let arr = [1, 2, 3, 4, 5];<br>let result = arr.reduce((sum, current) =&gt; sum + current, 0);<br>alert(result); // 15</p></li><li><p>array.isArray() 是数组的话返回true 反之返回false</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS字符串方法</title>
    <link href="/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="js基础-—-js字符串方法"><a href="#js基础-—-js字符串方法" class="headerlink" title="js基础 — js字符串方法"></a>js基础 — js字符串方法</h2><ol><li>round floor ceil parseInt parseFloat区别<br>round 四舍五入，返回参数+0.5后，向下取整<br>floor 返回小于等于参数的最大整数<br>ceil  返回大于等于参数的最小整数<br>parseInt 解析一个字符串，并返回一个整数 返回舍去参数的小数部分后的整数<br>parseFloat  解析一个字符串，并返回一个浮点数</li></ol><h2 id="整理字符串和数组常用方法"><a href="#整理字符串和数组常用方法" class="headerlink" title="整理字符串和数组常用方法"></a>整理字符串和数组常用方法</h2><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="查找字符串的方法"><a href="#查找字符串的方法" class="headerlink" title="查找字符串的方法"></a>查找字符串的方法</h4><ul><li><p>indexOf() 返回字符串中指定文本首次出现的索引index 没找到返回 -1 第二个参数为检索起始位置  不可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.indexOf(<span class="hljs-string">&quot;china&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure></li><li><p>lastIndexOf() 返回字符串中指定文本最后一次出现的索引 index 没找到返回 -1 同上</p></li><li><p>search()  方法返回字符串中指定文本第一次出现的位置 无法设置第二个参数  可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.search(<span class="hljs-string">&quot;China&quot;</span>)   =&gt; <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="提取字符串的方法"><a href="#提取字符串的方法" class="headerlink" title="提取字符串的方法"></a>提取字符串的方法</h4><ul><li><p>slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。</p><ul><li>如果参数是负数，则从字符串的结尾开始计数</li><li>如果省略第二个参数，则该方法将裁剪字符串的剩余部分</li><li>从结尾计数，也是裁剪字符串的剩余部分</li></ul></li><li><p>substring(start, end) 类似于slice() 不过不能接受负的索引</p></li><li><p>substr(start, length) 类似于slice() 第二个参数规定被提取部分的长度</p></li></ul><h4 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h4><ul><li>replace() <ul><li>replace()方法不会改变调用它的字符串 它返回的是新字符串</li><li>replace()只替换首个匹配</li><li><a href="https://www.w3school.com.cn/js/js_string_methods.asp">https://www.w3school.com.cn/js/js_string_methods.asp</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为机试算法题.md</title>
    <link href="/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>计算某字母key出现在指定字符串str中的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = readline().toLowerCase();<br><span class="hljs-keyword">var</span> key = readline().toLowerCase();<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>count = str.split(key).length - <span class="hljs-number">1</span>;<br>print(count)<br></code></pre></td></tr></table></figure></li><li><p>动态规划  dp0-1 钱包问题  （动态规划 =》 将大问题转变成小问题的和 类似dfs）</p><h2 id="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"><a href="#现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品" class="headerlink" title="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"></a>现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品</h2><p>物品编号   1  2  3  4<br>物品重量   2  3  4  5</p><h2 id="物品价值-3-4-5-6"><a href="#物品价值-3-4-5-6" class="headerlink" title="物品价值   3  4  5  6"></a>物品价值   3  4  5  6</h2><p>解：记f(k,w)  背包容量为w，有k件物品可以偷，所能偷到的最大价值</p><p>状态转移方程<br>f(k,w) = f(k-1,w)  when wk&gt;w  当第k个物品的重量大于背包容量 等于k-1物品里 偷总重量不超过w的的最大价值<br>f(k,w) = max{ f(k-1,w-wk)+vk,f(k-1,w) }  when wk&lt;=w 当k物品不重于背包容量的话，可以选择偷和不偷  偷的话 最大价值转变成 从k-1个物品里偷重量不超w-k物品的重量  不偷的话 转变成 从k-1个物品里偷w重量的最大价值</p></li></ul><p>var reg = /^(A|D|W|S){1}[0-9]{1,2}$/;</p><p>var reg1 = /[a-zA-Z0-9]/</p><h3 id="padStart、padEnd、parseInt的第二参数"><a href="#padStart、padEnd、parseInt的第二参数" class="headerlink" title="padStart、padEnd、parseInt的第二参数"></a>padStart、padEnd、parseInt的第二参数</h3><p>padStart的第一参数n 是指将目标字符串用第二参数c扩充到n位（是一共n位 不是n个c）<br>parseInt第二参数是 将第一个参数以几进制转换2-36</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket简单上手</title>
    <link href="/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="socket-简单上手"><a href="#socket-简单上手" class="headerlink" title="socket 简单上手"></a>socket 简单上手</h2><blockquote><p>利用express和socket实现一个简易的聊天室 日后可持续添加新功能</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>只需基于node的express框架搭建出一个包含表单和消息列表的html页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm init -y  <span class="hljs-comment">// 初始化package.json文件以安装node框架</span><br>npm i express  <span class="hljs-comment">// 安装express框架</span><br></code></pre></td></tr></table></figure><h3 id="创建服务后台"><a href="#创建服务后台" class="headerlink" title="创建服务后台"></a>创建服务后台</h3><p>利用express提供的能力搭建后台 </p><ul><li>初始化 app 作为 HTTP 服务器的回调函数</li><li>监听3000端口 </li><li>定义了首页路由 <strong>/</strong> </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)();<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).Server(app);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  res.sendFile(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>&#125;);<br><br>http.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening on *:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="添加socket-io"><a href="#添加socket-io" class="headerlink" title="添加socket.io"></a>添加socket.io</h3><p>安装socket.io</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i socket.io<br></code></pre></td></tr></table></figure><h4 id="在index-js中添加socket模块"><a href="#在index-js中添加socket模块" class="headerlink" title="在index.js中添加socket模块"></a>在index.js中添加socket模块</h4><ul><li>通过传入http对象初始化了一个socket.io的实例 </li><li>监听connection事件来接收sockets，并将连接信息打印在console</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(http);<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在index-html-的-标签中添加socket-io-client"><a href="#在index-html-的-标签中添加socket-io-client" class="headerlink" title="在index.html 的  标签中添加socket-io-client"></a>在index.html 的 </body> 标签中添加socket-io-client</h4><p>socket.io-client 暴露了一个 io 全局变量，然后连接服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> socket = io(); <span class="hljs-comment">// 请注意我们在调用 io() 时没有指定任何 URL,因为它默认将尝试连接到提供当前页面的主机</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// io这里可以传入参数（可以log一下参数），参数是当前Socket的所有信息</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="监听connection和disconnect事件"><a href="#监听connection和disconnect事件" class="headerlink" title="监听connection和disconnect事件"></a>监听connection和disconnect事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-comment">// 这里的socket可以拿到socket相关参数 比如每个socket连接的id 区分不同连接的用户</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>  socket.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user disconnected&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="手动触发自定义事件"><a href="#手动触发自定义事件" class="headerlink" title="手动触发自定义事件"></a>手动触发自定义事件</h3><blockquote><p>比如发送消息</p></blockquote><p>当用户输入消息时，服务器接收一个 chat message 事件<br>此处类似vue的事件触发，socket.emit 触发自定义事件并传入参数</p><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-1.11.1.js&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;external nofollow&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> socket = io();</span></span><br><span class="javascript"><span class="xml">    $(<span class="hljs-string">&#x27;form&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">      socket.emit(<span class="hljs-string">&#x27;chat message&#x27;</span>, $(<span class="hljs-string">&#x27;#m&#x27;</span>).val());</span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&#x27;#m&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml">  &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><p>监听client端的自定义事件：此处事件名为 chat message</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;message: &#x27;</span> + msg);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="socket也提供了广播功能"><a href="#socket也提供了广播功能" class="headerlink" title="socket也提供了广播功能"></a>socket也提供了广播功能</h3><p>让服务器将消息发送给其他用户</p><p>要将事件发送给每个用户，Socket.IO 提供了 io.emit 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">io.emit(<span class="hljs-string">&#x27;some event&#x27;</span>, &#123; <span class="hljs-attr">for</span>: <span class="hljs-string">&#x27;everyone&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>要将消息发给除特定 socket 外的其他用户，可以用 broadcast 标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.broadcast.emit(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在client端监听"><a href="#在client端监听" class="headerlink" title="在client端监听"></a>在client端监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>  $(<span class="hljs-string">&#x27;#messages&#x27;</span>).append($(<span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span>).text(msg));<br>&#125;);<br></code></pre></td></tr></table></figure><p>至此：简单的socket上手已完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题HTML&amp;CSS</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/</url>
    
    <content type="html"><![CDATA[<ol><li>property和attribute的区别</li></ol><p>property是dom元素对象的一个属性，是js里面的对象 值可以是对象、数组在内的任何类型<br>attribute是html标签上的属性，值只能是字符串</p><p>建议使用property，因为attribute的每次修改都会触发页面重绘</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题VUE篇</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h2><h3 id="Vue-的最大的优势是什么"><a href="#Vue-的最大的优势是什么" class="headerlink" title="Vue 的最大的优势是什么"></a>Vue 的最大的优势是什么</h3><ol><li>数据可以双向绑定  mvvm</li><li>组件化开发</li><li>单页面应用，减少后台请求</li><li>第三方库比较好用</li></ol><h3 id="mvvm-和-mvc-区别是什么"><a href="#mvvm-和-mvc-区别是什么" class="headerlink" title="mvvm 和 mvc 区别是什么"></a>mvvm 和 mvc 区别是什么</h3><ul><li>mvvm(model view viewmodel) </li></ul><p>viewModel是核心<br>可以将model-&gt;view  by数据绑定 ；<br>可以将view-&gt;model  bydom事件监听  即 双向绑定</p><ul><li>mvc(model view controller)<br>c-&gt;vm vm是从c中抽离业务逻辑 相当于是在c基础上封装了一层</li></ul><h3 id="Vue-数据双向绑定的原理是什么"><a href="#Vue-数据双向绑定的原理是什么" class="headerlink" title="Vue 数据双向绑定的原理是什么"></a>Vue 数据双向绑定的原理是什么</h3><p>数据劫持结合发布者-订阅者模式<br>数据劫持 Observer<br>Dep 收集订阅者</p><p>Object.defineProperty()<br>待补充</p><h3 id="Object-defineProperty-和-Proxy-的区别"><a href="#Object-defineProperty-和-Proxy-的区别" class="headerlink" title="Object.defineProperty 和 Proxy 的区别"></a>Object.defineProperty 和 Proxy 的区别</h3><ul><li>proxy</li></ul><ul><li>Object.defineProperty</li></ul><h3 id="Vue的生命周期-（现在有11个）"><a href="#Vue的生命周期-（现在有11个）" class="headerlink" title="Vue的生命周期  （现在有11个）"></a>Vue的生命周期  （现在有11个）</h3><ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>activated        keep-alive激活时调用</li><li>deactivated      keep-alive停用时调用</li><li>beforeDestory</li><li>destoryed</li><li>errorCaptured   捕获到子孙组件的错误时调用</li></ol><p>了解各部分是干啥的</p><h3 id="封装过-Vue-的组件吗"><a href="#封装过-Vue-的组件吗" class="headerlink" title="封装过 Vue 的组件吗"></a>封装过 Vue 的组件吗</h3><p>☆</p><h3 id="组件之间是如何传值的"><a href="#组件之间是如何传值的" class="headerlink" title="组件之间是如何传值的"></a>组件之间是如何传值的</h3><h3 id="data为啥必须是函数"><a href="#data为啥必须是函数" class="headerlink" title="data为啥必须是函数"></a>data为啥必须是函数</h3><h3 id="怎么监听路由参数的变化"><a href="#怎么监听路由参数的变化" class="headerlink" title="怎么监听路由参数的变化"></a>怎么监听路由参数的变化</h3><ul><li>watch $route(to, from)</li><li>beforeRouteUpdate(to, from, next)</li></ul><h3 id="如何显示组件缓存"><a href="#如何显示组件缓存" class="headerlink" title="如何显示组件缓存"></a>如何显示组件缓存</h3><h3 id="常用的修饰符"><a href="#常用的修饰符" class="headerlink" title="常用的修饰符"></a>常用的修饰符</h3><ul><li>prevent</li><li>stop</li><li>self</li><li>capture</li></ul><h3 id="Vue踩过的坑"><a href="#Vue踩过的坑" class="headerlink" title="Vue踩过的坑"></a>Vue踩过的坑</h3><ul><li>给data中的对象直接添加属性并赋值 无效果<br>解决方法：Vue.set(object, attribute, value)新增的属性也是响应式的</li><li>在created中操作dom报错，无法获取到dom<br>解决方法：Vue.nextTick()</li></ul><h3 id="Vue-渲染模板时怎么保留模板中的-HTML-注释呢"><a href="#Vue-渲染模板时怎么保留模板中的-HTML-注释呢" class="headerlink" title="Vue 渲染模板时怎么保留模板中的 HTML 注释呢"></a>Vue 渲染模板时怎么保留模板中的 HTML 注释呢</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template comments&gt; ... &lt;/template&gt;<br><span class="hljs-comment">// 将组件中comments选项设置为true即可</span><br></code></pre></td></tr></table></figure><h3 id="Vue的template编译的理解"><a href="#Vue的template编译的理解" class="headerlink" title="Vue的template编译的理解"></a>Vue的template编译的理解</h3><p>简单说： 先转化成AST树，再得到render函数，并返回VNode</p><h3 id="Vue的两种路由模式-hash和history"><a href="#Vue的两种路由模式-hash和history" class="headerlink" title="Vue的两种路由模式 hash和history"></a>Vue的两种路由模式 hash和history</h3><ol><li>hash模式，就是连接中有#的，#后面的被称为hash，hash虽然在url中，但是不包括在HTTP请求中，hash变化也不会重新加载页面</li><li>history模式，采用h5新特性，切提供了两个新方法：pushState和replaceState可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</li></ol><h3 id="route-和-router-的区别是什么"><a href="#route-和-router-的区别是什么" class="headerlink" title="$route 和$router 的区别是什么"></a>$route 和$router 的区别是什么</h3><ul><li>$route 是路由信息对象，包括一些路由信息参数如。path, params, hash, query, fullPath, matched, name</li><li>$router 是VueRouter的实例，相当于一个全局的路由器对象，包含很多属性和子对象，如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)</li></ul><h3 id="vue-router官网记录"><a href="#vue-router官网记录" class="headerlink" title="vue router官网记录"></a>vue router官网记录</h3><p>router文件中必须要有routes，路由数组：存放多个不同路由(放的是路由信息)，对应上面的$route</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>   &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,<br>      <span class="hljs-attr">component</span>: AboutComponent<br>   &#125;<br>]<br></code></pre></td></tr></table></figure><p>router实例是VueRouter这个插件的实例，routes路由信息是传给router实例的配置参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>   <span class="hljs-attr">routes</span>: routes<br>&#125;)<br></code></pre></td></tr></table></figure><p>创建并挂在根实例，记得要通过router配置参数注入路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>   router<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由</p><p>routes的meta字段是路由元信息<br>一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.some(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>https://v3.router.vuejs.org/zh/guide/advanced/data-fetching.html#%E5%AF%BC%E8%88%AA%E5%AE%8C%E6%88%90%E5%90%8E%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE</code></p><h3 id="Vue-Router的动态路由，怎么获取传过来的动态参数-☆"><a href="#Vue-Router的动态路由，怎么获取传过来的动态参数-☆" class="headerlink" title="Vue-Router的动态路由，怎么获取传过来的动态参数 ☆"></a>Vue-Router的动态路由，怎么获取传过来的动态参数 ☆</h3><p>场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染<br>动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配<br>到一个路由时，参数会被设置到 this.$router.params 中，并且可以在每个组件<br>中使用。<br>like this: <code>&#123; path: &#39;/user/:id&#39;, component: User &#125;</code><br>在匹配到该路由之后，动态参数会被设置到this.$route.params<br><code>template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;</code><br>也可以是多个参数<br>like this: <code>/user/:username/post/:post_id</code> 与路由一一对应</p><h3 id="Vue-Router-的钩子函数都有哪些"><a href="#Vue-Router-的钩子函数都有哪些" class="headerlink" title="Vue-Router 的钩子函数都有哪些"></a>Vue-Router 的钩子函数都有哪些</h3><p>即 路由守卫 记住，在任务导航守卫中都要触发next函数<br>主要分为三类</p><ol><li>全局钩子beforeEach(to,from,next:function) beforeResolve afterEach</li><li>路由独享钩子 beforeEnter  // 在routes数组中给某个特定的route单独设置路由狗子，参数一致</li><li>组件内钩子<ul><li>beforeRouterEnter // 不！能！获取组件实例 <code>this</code></li><li>beforeRouterUpdate // 在当前路由改变，但是该组件被复用时调用 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候</li><li>beforeRouterLeave // 导航离开该组件的对应路由时调用 可以访问组件实例 <code>this</code> （禁止用户在还未保存修改前突然离开）</li><li>用处：一般用的是beforeEach，可以判断用户身份，未登录则导航到Login页面<h3 id="路由传值的方式有哪几种"><a href="#路由传值的方式有哪几种" class="headerlink" title="路由传值的方式有哪几种"></a>路由传值的方式有哪几种</h3></li></ul></li></ol><p>155page</p><h3 id="vue组件的定时器怎么销毁"><a href="#vue组件的定时器怎么销毁" class="headerlink" title="vue组件的定时器怎么销毁"></a>vue组件的定时器怎么销毁</h3><ul><li>如果页面上有很多个定时器，在data选项中添加一个timer对象，给每个定时器去一个名字一一映射在对象timer中，然后在beforeDestory函数中for循环clearInterval掉</li><li>如果只有一个定时器，可以用<code>this.$once(&#39;hook:beforeDestory&#39;,()=&gt;&#123; clearInterval(timer) &#125;)</code></li></ul><h3 id="Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"><a href="#Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法" class="headerlink" title="Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"></a>Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法</h3><blockquote><p>可以触发更新</p></blockquote><ul><li><p>push()</p></li><li><p>pop()</p></li><li><p>unshift()</p></li><li><p>shift()</p></li><li><p>splice()</p></li><li><p>sort()</p></li><li><p>reverse()</p></li><li><p>filter()</p></li><li><p>concat()</p></li><li><p>slice()</p></li></ul><blockquote><p>不可以触发更新</p></blockquote><ul><li>直接利用索引设置新数组值  this.arr[index] = newV;</li><li>直接修改数组的长度  this.arr.length = newL;</li></ul><blockquote><p>解决第一种</p></blockquote><p>this.$set(this.aarr,index,newValue)<br>this.arr.splice(index,1,newValue)</p><blockquote><p>解决第二种</p></blockquote><p>this.arr.splce(newLength)</p><h3 id="怎么重置Vue中的data"><a href="#怎么重置Vue中的data" class="headerlink" title="怎么重置Vue中的data"></a>怎么重置Vue中的data</h3><p>Object.assign(target, source) 方法用于将所有可枚举属性的值从一个或多个源对<br>象复制到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.$data, <span class="hljs-built_in">this</span>.$options.data(<span class="hljs-built_in">this</span>))<br></code></pre></td></tr></table></figure><h3 id="Vue首屏加载优化"><a href="#Vue首屏加载优化" class="headerlink" title="Vue首屏加载优化"></a>Vue首屏加载优化</h3><ul><li>不常改变的库放到index.html中，用cdn引入</li><li>路由懒加载</li><li>不生成map文件</li><li>vue组件尽量不全局引入</li><li>开启gzip压缩</li><li>首页单独做服务端渲染</li></ul><h3 id="Vue的nextTick原理"><a href="#Vue的nextTick原理" class="headerlink" title="Vue的nextTick原理"></a>Vue的nextTick原理</h3><p>如果需要必须对数据更改并刷新后的DOM做处理时</p><blockquote><p>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中</p></blockquote><p>原理：利用异步队列</p><p>在每个 macro-task 运行完以后，UI 都会重渲染，那么在 micro-task （异步事件回调） 中就完成数据更新，当前 次事件循环 结束就可以得到最新的 UI 了。反之如果新建一个 macro-task 来做数据更新，那么渲染就会进行两次。</p><p>总结</p><ol><li>vue用异步队列的方式来控制DOM更新和nextTick回调先后执行</li><li>micro-task因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li><li>因为兼容性问题，vue不得不做了microtask向macrotask的降级方案</li></ol><h3 id="待丰富"><a href="#待丰富" class="headerlink" title="待丰富"></a>待丰富</h3><p>Vue-Router的动态路由，怎么获取传过来的动态参数</p><p>路由传值的方式有哪几种</p><p>Vue-Router 的钩子函数都有哪些</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue, 面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题JS篇</title>
    <link href="/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/"/>
    <url>/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="JS基础篇"><a href="#JS基础篇" class="headerlink" title="JS基础篇"></a>JS基础篇</h2><h3 id="手写js深拷贝"><a href="#手写js深拷贝" class="headerlink" title="手写js深拷贝"></a>手写js深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 这边留意 双等号意味着既不是null也不是undefined</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-comment">// 初始化返回值</span><br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 核心</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span>(obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 递归调用 这边要反复看 自己默写的是result</span><br>      result[item] = deepClone(obj[item])<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归可以深入研究下 添加到toDo中</p></blockquote><h3 id="typeof的用法"><a href="#typeof的用法" class="headerlink" title="typeof的用法"></a>typeof的用法</h3><ol><li>可以返回所有的基本数据类型 undefined string number boolean</li><li>引用数据类型只能返回object，不能具体区分是array还是object</li><li>typeof function返回值就是function<br>举例：typeof(class c{}) 也是function</li></ol><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>题目：</p><ol><li>如何准确判断一个变量是不是数组</li><li>手写一个jquery，考虑插件和扩展性</li><li>class的原型本质，怎么理解</li></ol><h4 id="class的用法"><a href="#class的用法" class="headerlink" title="class的用法"></a>class的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 构造函数 就是在初始化新实例/对象的时候执行的方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.num = num;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, 学号：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.num&#125;</span>`</span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> xialuo = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;夏洛&quot;</span>,<span class="hljs-number">120</span>);<br>xialuo.sayHi();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 继承 调用super函数 处理父亲有的参数</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num,gender</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name,num);<br>    <span class="hljs-comment">// 自己独有的自己绑定</span><br>    <span class="hljs-built_in">this</span>.gender = gender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="instanceof进行类型判断"><a href="#instanceof进行类型判断" class="headerlink" title="instanceof进行类型判断"></a>instanceof进行类型判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xialuo <span class="hljs-keyword">instanceof</span> Student <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ol><li>每个class都有显式原型prototype</li><li>每个class实例化后都有隐式原型__proto__</li><li>实例的隐式原型指向对应class的显式原型</li><li>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.<strong>proto</strong> === Student.proptotype</li></ol><p><img src="../../../../img/prototype.png" alt="原型图"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ol><li>能手绘原型链图</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="闭包的表现"><a href="#闭包的表现" class="headerlink" title="闭包的表现"></a>闭包的表现</h4><ol><li>函数作为参数被传递<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = create()<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>fn() <span class="hljs-comment">// log值为100</span><br></code></pre></td></tr></table></figure></li><li>函数作为返回值被返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>  fn()<br>&#125;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br>print(fn) <span class="hljs-comment">// 打印值仍为100</span><br></code></pre></td></tr></table></figure><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4></li></ol><ul><li>封装变量（在function中定义私有变量，return一个function，变量即不会被拿到或修改）</li></ul><blockquote><p>所有（闭包）自由变量的查找  是在函数<strong>定义</strong>的地方，向上级作用域查找 不是在执行的地方</p></blockquote><h4 id="this的使用场景"><a href="#this的使用场景" class="headerlink" title="this的使用场景"></a>this的使用场景</h4><ol><li>作为普通函数  window</li><li>使用call bind apply （三个的区别 call可直接换this指向 bind是有返回值 返回值再调用）</li><li>作为对象方法被调用   指代的就是这个对象本身</li><li>在class方法中调用   当前实例本身 setTimeout注意</li><li>箭头函数 ()=&gt;{this} 和上级作用域的值一致<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对应上方点2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br>fn1.call(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;) <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-keyword">const</span> fn2 = fn1.bind(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;)<br>fn2(); <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-function"><span class="hljs-title">setTimeout</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// this === window</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>this取什么值是在函数被<strong>执行</strong>的时候确定的，不是在定义的时候</p></blockquote><h4 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h4><h5 id="手写bind函数"><a href="#手写bind函数" class="headerlink" title="手写bind函数"></a>手写bind函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// bind function</span><br><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将参数拆分成数组</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-comment">// 获取this</span><br>  <span class="hljs-keyword">const</span> t = args.shift()<br>  <span class="hljs-comment">// fn1.bind(...) 中的 fn1 实例</span><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span><br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> self.apply(t,args)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h5><ol><li>隐藏数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 闭包cache  数据隐藏</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = &#123;&#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,val</span>) </span>&#123;<br>      data[key] = val<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> data[key]<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> c = createCache()<br>c.set(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(c.get(<span class="hljs-string">&quot;a&quot;</span>))<br></code></pre></td></tr></table></figure></li><li>循环绑定事件<br>for循环中给标签添加监听事件addEventListener<br>调用的时候循环已经结束 调用时的增量i为循环结束时i的取值了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><blockquote><p>基于js是单线程语言  callback回调<br>异步不会阻塞代码执行<br>同步会阻塞代码执行</p></blockquote></li></ol><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="同步异步的区别是什么"><a href="#同步异步的区别是什么" class="headerlink" title="同步异步的区别是什么"></a>同步异步的区别是什么</h5><p>异步不会阻塞代码执行<br>同步会阻塞代码执行</p><h5 id="手写用promise加载一张图片"><a href="#手写用promise加载一张图片" class="headerlink" title="手写用promise加载一张图片"></a>手写用promise加载一张图片</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImg</span>(<span class="hljs-params">src</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;img&quot;</span>)<br>      img.onload = <span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(img)<br>      &#125;<br>      img.onerror = <span class="hljs-function">() =&gt;</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>))<br>      &#125;<br>      img.src = src<br>    &#125;<br>  )<br>&#125;<br>loadImg(url).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.width)<br>  <span class="hljs-keyword">return</span> img <span class="hljs-comment">// 普通对象 loadImg返回的对象值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.height)<br>  <span class="hljs-keyword">return</span> loadImg(url2)  <span class="hljs-comment">// 返回的是new promise 后面的then取到的loadImg请求的返回值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img2</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h5 id="前端使用异步的场景有哪些"><a href="#前端使用异步的场景有哪些" class="headerlink" title="前端使用异步的场景有哪些"></a>前端使用异步的场景有哪些</h5><p>请求后台数据</p><h2 id="JS异步-进阶"><a href="#JS异步-进阶" class="headerlink" title="JS异步-进阶"></a>JS异步-进阶</h2><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><ul><li>event loop过程1<ul><li>同步代码，一行一行放在call Stack执行</li><li>遇到异步，会先记录下，等待时机（定时，网络请求）</li><li>时机到了，就会移动到callback queue</li></ul></li><li>event loop过程2<ul><li>如果call stack为空（同步代码执行完），event loop开始工作</li><li>轮训查找callback queue，如果有则移动到call stack</li><li>然后继续轮训查找</li></ul></li></ul><h3 id="dom事件与event-loop关系"><a href="#dom事件与event-loop关系" class="headerlink" title="dom事件与event loop关系"></a>dom事件与event loop关系</h3><ol><li>js是单线程的</li><li>异步都是基于event loop的</li><li>dom事件也使用回调，也是基于event loop</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).on(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">// 注意这里的click是立即执行的，但是function会被立刻放到webapi的库中，</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;btn clicked&#x27;</span>); <span class="hljs-comment">// 当用户点击click时，function会被放入到callback queue中</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><ul><li>宏任务<ul><li>setTimeout</li><li>setImmediate</li><li>setInterval</li><li>requestAnimationFrame</li><li>I/O</li><li>UI rendering</li></ul></li><li>微任务<ul><li>process.nextTick</li><li>promise (then)</li><li>object.observe</li><li>mutationObserve</li></ul></li></ul><h3 id="一面面试题"><a href="#一面面试题" class="headerlink" title="一面面试题"></a>一面面试题</h3><ol><li>做过哪些项目 项目的亮点是什么</li><li>defer和async的区别</li><li>生命周期有哪些和各自特点</li><li>原型链是什么</li><li>闭包的使用，在哪用过，为啥要用</li><li>event loop</li></ol><h3 id="二面面试题"><a href="#二面面试题" class="headerlink" title="二面面试题"></a>二面面试题</h3><ol><li>前端性能优化相关</li><li>前端安全相关做过哪些，xss csrf分别是怎么防护的</li><li>搜索页面是怎么保证在秒级拿到数据的，（不拘泥于前端），模糊查找，前缀模糊查找和后缀模糊查找哪个性能更好（后缀：面试官说的）</li><li>算法数据结构了解哪些？哈希表是啥？怎么插入，删除数据，优点是啥</li><li>react和vue区别是什么？一般技术选型是怎么选的</li><li>有没有做过一个独立需求的落地？怎么选择技术或者框架的</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6常用技巧</title>
    <link href="/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="对象取值方式"><a href="#对象取值方式" class="headerlink" title="对象取值方式"></a>对象取值方式</h3><blockquote><p>用解构赋值的方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj;<br><span class="hljs-keyword">const</span> res = a + b; <br></code></pre></td></tr></table></figure><p>如果想创建的变量名和对象的属性名不一致，可用取别名的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">a</span>:myName&#125; = obj;<br></code></pre></td></tr></table></figure><blockquote><p>注意：解构的对象不能为undefined和null，会报错<br>可以给一个默认值：空对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj || &#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并数据方式"><a href="#合并数据方式" class="headerlink" title="合并数据方式"></a>合并数据方式</h3><p>一般方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array</span><br><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> c = a.concat(b);<br><span class="hljs-comment">// object</span><br><span class="hljs-keyword">const</span> d = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> e = &#123;<br>  <span class="hljs-attr">f</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> g = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,d,e)<span class="hljs-comment">//a:1,f:1 注意Object.assign是浅拷贝</span><br></code></pre></td></tr></table></figure><p>ES6方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> c = [...new <span class="hljs-built_in">Set</span>([...a,...b])];<br><span class="hljs-keyword">const</span> g = &#123;...d,...e&#125; <span class="hljs-comment">//解构赋值也是浅拷贝</span><br></code></pre></td></tr></table></figure><h3 id="if中判断条件"><a href="#if中判断条件" class="headerlink" title="if中判断条件"></a>if中判断条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span> || type == <span class="hljs-number">2</span> || type == <span class="hljs-number">3</span> ) &#123;...&#125;<br><span class="hljs-comment">// 改进之后 用es6新增的includes方法</span><br><span class="hljs-keyword">const</span> condition = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">if</span>(condition.includes(type))<br></code></pre></td></tr></table></figure><h3 id="获取对象属性值的方法"><a href="#获取对象属性值的方法" class="headerlink" title="获取对象属性值的方法"></a>获取对象属性值的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = obj &amp;&amp; obj.name<br><span class="hljs-comment">// 改进之后 es6的可选链操作符</span><br><span class="hljs-keyword">const</span> name = obj?.name<br></code></pre></td></tr></table></figure><h3 id="输入框非空的判断"><a href="#输入框非空的判断" class="headerlink" title="输入框非空的判断"></a>输入框非空的判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// 改进后 空值合并运算符</span><br><span class="hljs-keyword">if</span>(value ?? <span class="hljs-string">&#x27;&#x27;</span> !== <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="添加动态变化属性名的对象属性"><a href="#添加动态变化属性名的对象属性" class="headerlink" title="添加动态变化属性名的对象属性"></a>添加动态变化属性名的对象属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> key = <span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>;<br>obj[key] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br><span class="hljs-comment">// 改进之后 对象属性名用表达式</span><br>obj[<span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async和await</title>
    <link href="/2021/11/08/async%E5%92%8Cawait/"/>
    <url>/2021/11/08/async%E5%92%8Cawait/</url>
    
    <content type="html"><![CDATA[<h1 id="async-await要点"><a href="#async-await要点" class="headerlink" title="async await要点"></a>async await要点</h1><ol><li>await 后面可以追加 promise 对象，获取 resolve 的值</li><li>await 必须包裹在 async 函数里面</li><li>async 函数执行返回的也是一个 promise 对象</li><li>try-catch 截获 promise 中 reject 的值</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, async, await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual DOM理解</title>
    <link href="/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/"/>
    <url>/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><blockquote><p>用原生的JavaScript对象去描述一个DOM节点</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>vue2底层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐分享</title>
    <link href="/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"/>
    <url>/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h1><blockquote><p>这个文件用来记录喜欢的音乐</p></blockquote><h3 id="To-Be-Continued"><a href="#To-Be-Continued" class="headerlink" title="To Be Continued"></a>To Be Continued</h3><blockquote><p>2022/4/14  生存指南</p></blockquote><blockquote><p>2022/4/18  一样的月光</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AllToDo</title>
    <link href="/2021/10/31/AllToDo/"/>
    <url>/2021/10/31/AllToDo/</url>
    
    <content type="html"><![CDATA[<h1 id="所有的TODO"><a href="#所有的TODO" class="headerlink" title="所有的TODO"></a>所有的TODO</h1><blockquote><p>每次修改完记得提交到github</p></blockquote><p>什么都容易遗忘 基础都得夯实<br>html css js 移动端 webApi jquery node echarts vue react 微信小程序  </p><p>当前最重要任务  <strong>看面试题</strong><br>看面试题书 将重要的写成博客</p><h3 id="blog配置相关"><a href="#blog配置相关" class="headerlink" title="blog配置相关"></a>blog配置相关</h3><ol><li>添加代码提交规范 commitlint插件 + husky插件  10.31</li></ol><h3 id="blog内容相关"><a href="#blog内容相关" class="headerlink" title="blog内容相关"></a>blog内容相关</h3><ol><li>【网络】get和post传值的区别  10.31</li><li>【vue2】promise原理理解（实现代码）  10.31</li><li>【vue2底层】vue2底层学习笔记  10.31</li><li>【js】call方法作用及使用方式  10.31</li><li>【vue】模块化规范-require和import区别 11.8</li><li>【js】常用ES6技巧</li><li>【js】常用深浅拷贝记录</li><li>【基础】递归方法的实现</li><li>【js】手写new函数 bind（面试题已写） call apply 12.14</li><li>【css】@mixin</li><li>【css】用纯html+css3实现轮播图</li><li>【css】grid布局  1.1</li><li>【echarts】至少要用过一些</li></ol><h3 id="可提升方面"><a href="#可提升方面" class="headerlink" title="可提升方面"></a>可提升方面</h3><ol><li>js优化能力： 封装成类   封装成类的能力太弱</li></ol><h3 id="当前任务"><a href="#当前任务" class="headerlink" title="当前任务"></a>当前任务</h3><h4 id="完成一个简易版qq-socket-io-vue-express-mysql"><a href="#完成一个简易版qq-socket-io-vue-express-mysql" class="headerlink" title="完成一个简易版qq   socket.io+vue+express+mysql"></a>完成一个简易版qq   socket.io+vue+express+mysql</h4><p>两个页面 私聊 + 群聊<br>vue create 一个项目出来 完成</p><h4 id="qq项目"><a href="#qq项目" class="headerlink" title="qq项目"></a>qq项目</h4><p>qq前端项目   vue3-qq  注册  登录  聊天  三个页面<br>qq后端express 用express-generator   封装successModel  errorModel 返回请求成功或失败的返回值  参考blog-express  导出module.exports  引入require</p>]]></content>
    
    
    
    <tags>
      
      <tag>ToDo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/31/hello-world/"/>
    <url>/2021/10/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>How to publish a new article by hexo</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
