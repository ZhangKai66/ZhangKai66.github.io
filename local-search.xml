<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>promise</title>
    <link href="/2022/04/14/promise/"/>
    <url>/2022/04/14/promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="promise代码"><a href="#promise代码" class="headerlink" title="promise代码"></a>promise代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>  resolve();<br>  <span class="hljs-comment">// reject();</span><br>&#125;);<br>p1.then(<span class="hljs-function">() =&gt;</span> &#123;&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="promise的三个状态"><a href="#promise的三个状态" class="headerlink" title="promise的三个状态"></a>promise的三个状态</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li>pending</li><li>fulfilled(resolved)</li><li>rejected</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>不可逆</li><li>只能从 pending-&gt;fulfilled 或者 pending-&gt;rejected</li></ul><h3 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h3><p>执行resolve()  该promise的状态则 pending-&gt;fulfilled<br>执行reject()  该promise的状态则 pending-&gt;rejected</p><h3 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h3><p>resolved状态的promise可以触发then回调<br>rejected状态的promise可以触发catch回调</p><h2 id="then-catch-怎么影响状态的变化"><a href="#then-catch-怎么影响状态的变化" class="headerlink" title="then\catch 怎么影响状态的变化"></a>then\catch 怎么影响状态的变化</h2><p>then正常返回resolved,如果有报错则 返回rejected<br>catch正常返回resolved,如果有报错则 返回rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;then error&#x27;</span>)<br>&#125;) <span class="hljs-comment">// rejected状态的promise 后续p2的then则不会触发</span><br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;bug&quot;</span>)<br>&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-comment">//2</span><br>&#125;).then(<span class="hljs-function">()=&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<span class="hljs-comment">//3 注意这边catch正常的返回也是resolved状态的promise，是可以触发后续的then回调的</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, promise, async, await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试高频题</title>
    <link href="/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <url>/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="手写系列"><a href="#手写系列" class="headerlink" title="手写系列"></a>手写系列</h2><h3 id="题目一：实现深度clone"><a href="#题目一：实现深度clone" class="headerlink" title="题目一：实现深度clone"></a>题目一：实现深度clone</h3><h3 id="题目二：实现节流和防抖"><a href="#题目二：实现节流和防抖" class="headerlink" title="题目二：实现节流和防抖"></a>题目二：实现节流和防抖</h3><h3 id="题目三：实现bind、call、apply函数"><a href="#题目三：实现bind、call、apply函数" class="headerlink" title="题目三：实现bind、call、apply函数"></a>题目三：实现bind、call、apply函数</h3><h3 id="题目四：实现简单的Promise"><a href="#题目四：实现简单的Promise" class="headerlink" title="题目四：实现简单的Promise"></a>题目四：实现简单的Promise</h3><h3 id="题目五：实现new函数"><a href="#题目五：实现new函数" class="headerlink" title="题目五：实现new函数"></a>题目五：实现new函数</h3>]]></content>
    
    
    
    <tags>
      
      <tag>高频题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题运行环境相关</title>
    <link href="/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="前端运行环境"><a href="#前端运行环境" class="headerlink" title="前端运行环境"></a>前端运行环境</h1><h2 id="网页是如何被渲染出来的"><a href="#网页是如何被渲染出来的" class="headerlink" title="网页是如何被渲染出来的"></a>网页是如何被渲染出来的</h2><blockquote><ol><li>从输入url到渲染出页面的过程</li></ol></blockquote><ol><li>加载资源的形式</li><li>加载资源的过程</li><li>渲染页面的过程</li></ol><blockquote><ol start="2"><li>window.onload和DOMContentLoaded的区别</li></ol></blockquote><p>window.onload 所有的资源全部加载完成</p><p>DOMContentLoaded dom渲染完毕即可 图片视频之类的可能还没加载完</p>]]></content>
    
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数组方法</title>
    <link href="/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JS常用数组方法"><a href="#JS常用数组方法" class="headerlink" title="JS常用数组方法"></a>JS常用数组方法</h2>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS字符串方法</title>
    <link href="/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="js基础-—-js字符串方法"><a href="#js基础-—-js字符串方法" class="headerlink" title="js基础 — js字符串方法"></a>js基础 — js字符串方法</h2><ol><li>round floor ceil parseInt parseFloat区别<br>round 四舍五入，返回参数+0.5后，向下取整<br>floor 返回小于等于参数的最大整数<br>ceil  返回大于等于参数的最小整数<br>parseInt 解析一个字符串，并返回一个整数 返回舍去参数的小数部分后的整数<br>parseFloat  解析一个字符串，并返回一个浮点数</li></ol><h2 id="整理字符串和数组常用方法"><a href="#整理字符串和数组常用方法" class="headerlink" title="整理字符串和数组常用方法"></a>整理字符串和数组常用方法</h2><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="查找字符串的方法"><a href="#查找字符串的方法" class="headerlink" title="查找字符串的方法"></a>查找字符串的方法</h4><ul><li><p>indexOf() 返回字符串中指定文本首次出现的索引index 没找到返回 -1 第二个参数为检索起始位置  不可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.indexOf(<span class="hljs-string">&quot;china&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure></li><li><p>lastIndexOf() 返回字符串中指定文本最后一次出现的索引 index 没找到返回 -1 同上</p></li><li><p>search()  方法返回字符串中指定文本第一次出现的位置 无法设置第二个参数  可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.search(<span class="hljs-string">&quot;China&quot;</span>)   =&gt; <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="提取字符串的方法"><a href="#提取字符串的方法" class="headerlink" title="提取字符串的方法"></a>提取字符串的方法</h4><ul><li><p>slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。</p><ul><li>如果参数是负数，则从字符串的结尾开始计数</li><li>如果省略第二个参数，则该方法将裁剪字符串的剩余部分</li><li>从结尾计数，也是裁剪字符串的剩余部分</li></ul></li><li><p>substring(start, end) 类似于slice() 不过不能接受负的索引</p></li><li><p>substr(start, length) 类似于slice() 第二个参数规定被提取部分的长度</p></li></ul><h4 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h4><ul><li>replace() <ul><li>replace()方法不会改变调用它的字符串 它返回的是新字符串</li><li>replace()只替换首个匹配</li><li><a href="https://www.w3school.com.cn/js/js_string_methods.asp">https://www.w3school.com.cn/js/js_string_methods.asp</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为机试算法题.md</title>
    <link href="/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>计算某字母key出现在指定字符串str中的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = readline().toLowerCase();<br><span class="hljs-keyword">var</span> key = readline().toLowerCase();<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>count = str.split(key).length - <span class="hljs-number">1</span>;<br>print(count)<br></code></pre></td></tr></table></figure></li><li><p>动态规划  dp0-1 钱包问题  （动态规划 =》 将大问题转变成小问题的和 类似dfs）</p><h2 id="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"><a href="#现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品" class="headerlink" title="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"></a>现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品</h2><p>物品编号   1  2  3  4<br>物品重量   2  3  4  5</p><h2 id="物品价值-3-4-5-6"><a href="#物品价值-3-4-5-6" class="headerlink" title="物品价值   3  4  5  6"></a>物品价值   3  4  5  6</h2><p>解：记f(k,w)  背包容量为w，有k件物品可以偷，所能偷到的最大价值</p><p>状态转移方程<br>f(k,w) = f(k-1,w)  when wk&gt;w  当第k个物品的重量大于背包容量 等于k-1物品里 偷总重量不超过w的的最大价值<br>f(k,w) = max{ f(k-1,w-wk)+vk,f(k-1,w) }  when wk&lt;=w 当k物品不重于背包容量的话，可以选择偷和不偷  偷的话 最大价值转变成 从k-1个物品里偷重量不超w-k物品的重量  不偷的话 转变成 从k-1个物品里偷w重量的最大价值</p></li></ul><p>var reg = /^(A|D|W|S){1}[0-9]{1,2}$/;</p><p>var reg1 = /[a-zA-Z0-9]/</p><h3 id="padStart、padEnd、parseInt的第二参数"><a href="#padStart、padEnd、parseInt的第二参数" class="headerlink" title="padStart、padEnd、parseInt的第二参数"></a>padStart、padEnd、parseInt的第二参数</h3><p>padStart的第一参数n 是指将目标字符串用第二参数c扩充到n位（是一共n位 不是n个c）<br>parseInt第二参数是 将第一个参数以几进制转换2-36</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket简单上手</title>
    <link href="/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="socket-简单上手"><a href="#socket-简单上手" class="headerlink" title="socket 简单上手"></a>socket 简单上手</h2><blockquote><p>利用express和socket实现一个简易的聊天室 日后可持续添加新功能</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>只需基于node的express框架搭建出一个包含表单和消息列表的html页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm init -y  <span class="hljs-comment">// 初始化package.json文件以安装node框架</span><br>npm i express  <span class="hljs-comment">// 安装express框架</span><br></code></pre></td></tr></table></figure><h3 id="创建服务后台"><a href="#创建服务后台" class="headerlink" title="创建服务后台"></a>创建服务后台</h3><p>利用express提供的能力搭建后台 </p><ul><li>初始化 app 作为 HTTP 服务器的回调函数</li><li>监听3000端口 </li><li>定义了首页路由 <strong>/</strong> </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)();<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).Server(app);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  res.sendFile(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>&#125;);<br><br>http.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening on *:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="添加socket-io"><a href="#添加socket-io" class="headerlink" title="添加socket.io"></a>添加socket.io</h3><p>安装socket.io</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i socket.io<br></code></pre></td></tr></table></figure><h4 id="在index-js中添加socket模块"><a href="#在index-js中添加socket模块" class="headerlink" title="在index.js中添加socket模块"></a>在index.js中添加socket模块</h4><ul><li>通过传入http对象初始化了一个socket.io的实例 </li><li>监听connection事件来接收sockets，并将连接信息打印在console</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(http);<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在index-html-的-标签中添加socket-io-client"><a href="#在index-html-的-标签中添加socket-io-client" class="headerlink" title="在index.html 的  标签中添加socket-io-client"></a>在index.html 的 </body> 标签中添加socket-io-client</h4><p>socket.io-client 暴露了一个 io 全局变量，然后连接服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> socket = io(); <span class="hljs-comment">// 请注意我们在调用 io() 时没有指定任何 URL,因为它默认将尝试连接到提供当前页面的主机</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// io这里可以传入参数（可以log一下参数），参数是当前Socket的所有信息</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="监听connection和disconnect事件"><a href="#监听connection和disconnect事件" class="headerlink" title="监听connection和disconnect事件"></a>监听connection和disconnect事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-comment">// 这里的socket可以拿到socket相关参数 比如每个socket连接的id 区分不同连接的用户</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>  socket.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user disconnected&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="手动触发自定义事件"><a href="#手动触发自定义事件" class="headerlink" title="手动触发自定义事件"></a>手动触发自定义事件</h3><blockquote><p>比如发送消息</p></blockquote><p>当用户输入消息时，服务器接收一个 chat message 事件<br>此处类似vue的事件触发，socket.emit 触发自定义事件并传入参数</p><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-1.11.1.js&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;external nofollow&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> socket = io();</span></span><br><span class="javascript"><span class="xml">    $(<span class="hljs-string">&#x27;form&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">      socket.emit(<span class="hljs-string">&#x27;chat message&#x27;</span>, $(<span class="hljs-string">&#x27;#m&#x27;</span>).val());</span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&#x27;#m&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml">  &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><p>监听client端的自定义事件：此处事件名为 chat message</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;message: &#x27;</span> + msg);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="socket也提供了广播功能"><a href="#socket也提供了广播功能" class="headerlink" title="socket也提供了广播功能"></a>socket也提供了广播功能</h3><p>让服务器将消息发送给其他用户</p><p>要将事件发送给每个用户，Socket.IO 提供了 io.emit 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">io.emit(<span class="hljs-string">&#x27;some event&#x27;</span>, &#123; <span class="hljs-attr">for</span>: <span class="hljs-string">&#x27;everyone&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>要将消息发给除特定 socket 外的其他用户，可以用 broadcast 标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.broadcast.emit(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在client端监听"><a href="#在client端监听" class="headerlink" title="在client端监听"></a>在client端监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>  $(<span class="hljs-string">&#x27;#messages&#x27;</span>).append($(<span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span>).text(msg));<br>&#125;);<br></code></pre></td></tr></table></figure><p>至此：简单的socket上手已完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题HTML&amp;CSS</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/</url>
    
    <content type="html"><![CDATA[<ol><li>property和attribute的区别</li></ol><p>property是dom元素对象的一个属性，是js里面的对象 值可以是对象、数组在内的任何类型<br>attribute是html标签上的属性，值只能是字符串</p><p>建议使用property，因为attribute的每次修改都会触发页面重绘</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题VUE篇</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h2><h3 id="Vue-的最大的优势是什么"><a href="#Vue-的最大的优势是什么" class="headerlink" title="Vue 的最大的优势是什么"></a>Vue 的最大的优势是什么</h3><ol><li>数据可以双向绑定  mvvm</li><li>组件化开发</li><li>单页面应用，减少后台请求</li><li>第三方库比较好用</li></ol><h3 id="mvvm-和-mvc-区别是什么"><a href="#mvvm-和-mvc-区别是什么" class="headerlink" title="mvvm 和 mvc 区别是什么"></a>mvvm 和 mvc 区别是什么</h3><ul><li>mvvm(model view viewmodel) </li></ul><p>viewModel是核心<br>可以将model-&gt;view  by数据绑定 ；<br>可以将view-&gt;model  bydom事件监听  即 双向绑定</p><ul><li>mvc(model view controller)<br>c-&gt;vm vm是从c中抽离业务逻辑 相当于是在c基础上封装了一层</li></ul><h3 id="Vue-数据双向绑定的原理是什么"><a href="#Vue-数据双向绑定的原理是什么" class="headerlink" title="Vue 数据双向绑定的原理是什么"></a>Vue 数据双向绑定的原理是什么</h3><p>数据劫持结合发布者-订阅者模式<br>Object.defineProperty()<br>待补充</p><h3 id="Object-defineProperty-和-Proxy-的区别"><a href="#Object-defineProperty-和-Proxy-的区别" class="headerlink" title="Object.defineProperty 和 Proxy 的区别"></a>Object.defineProperty 和 Proxy 的区别</h3><ul><li>proxy</li></ul><ul><li>Object.defineProperty</li></ul><h3 id="Vue的生命周期-（现在有11个）"><a href="#Vue的生命周期-（现在有11个）" class="headerlink" title="Vue的生命周期  （现在有11个）"></a>Vue的生命周期  （现在有11个）</h3><ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>activated        keep-alive激活时调用</li><li>deactivated      keep-alive停用时调用</li><li>beforeDestory</li><li>destoryed</li><li>errorCaptured   捕获到子孙组件的错误时调用</li></ol><p>了解各部分是干啥的</p><h3 id="封装过-Vue-的组件吗"><a href="#封装过-Vue-的组件吗" class="headerlink" title="封装过 Vue 的组件吗"></a>封装过 Vue 的组件吗</h3><p>☆</p><h3 id="组件之间是如何传值的"><a href="#组件之间是如何传值的" class="headerlink" title="组件之间是如何传值的"></a>组件之间是如何传值的</h3><h3 id="data为啥必须是函数"><a href="#data为啥必须是函数" class="headerlink" title="data为啥必须是函数"></a>data为啥必须是函数</h3><h3 id="怎么监听路由参数的变化"><a href="#怎么监听路由参数的变化" class="headerlink" title="怎么监听路由参数的变化"></a>怎么监听路由参数的变化</h3><ul><li>watch $route(to, from)</li><li>beforeRouteUpdate(to, from, next)</li></ul><h3 id="如何显示组件缓存"><a href="#如何显示组件缓存" class="headerlink" title="如何显示组件缓存"></a>如何显示组件缓存</h3><h3 id="常用的修饰符"><a href="#常用的修饰符" class="headerlink" title="常用的修饰符"></a>常用的修饰符</h3><ul><li>prevent</li><li>stop</li><li>self</li><li>capture</li></ul><h3 id="桌面文件-24题-148页"><a href="#桌面文件-24题-148页" class="headerlink" title="桌面文件 24题  148页"></a>桌面文件 24题  148页</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Vue, 面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题JS篇</title>
    <link href="/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/"/>
    <url>/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="JS基础篇"><a href="#JS基础篇" class="headerlink" title="JS基础篇"></a>JS基础篇</h2><h3 id="手写js深拷贝"><a href="#手写js深拷贝" class="headerlink" title="手写js深拷贝"></a>手写js深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 这边留意 双等号意味着既不是null也不是undefined</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-comment">// 初始化返回值</span><br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 核心</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span>(obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 递归调用 这边要反复看 自己默写的是result</span><br>      result[item] = deepClone(obj[item])<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归可以深入研究下 添加到toDo中</p></blockquote><h3 id="typeof的用法"><a href="#typeof的用法" class="headerlink" title="typeof的用法"></a>typeof的用法</h3><ol><li>可以返回所有的基本数据类型 undefined string number boolean</li><li>引用数据类型只能返回object，不能具体区分是array还是object</li><li>typeof function返回值就是function<br>举例：typeof(class c{}) 也是function</li></ol><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>题目：</p><ol><li>如何准确判断一个变量是不是数组</li><li>手写一个jquery，考虑插件和扩展性</li><li>class的原型本质，怎么理解</li></ol><h4 id="class的用法"><a href="#class的用法" class="headerlink" title="class的用法"></a>class的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 构造函数 就是在初始化新实例/对象的时候执行的方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.num = num;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, 学号：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.num&#125;</span>`</span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> xialuo = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;夏洛&quot;</span>,<span class="hljs-number">120</span>);<br>xialuo.sayHi();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 继承 调用super函数 处理父亲有的参数</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num,gender</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name,num);<br>    <span class="hljs-comment">// 自己独有的自己绑定</span><br>    <span class="hljs-built_in">this</span>.gender = gender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="instanceof进行类型判断"><a href="#instanceof进行类型判断" class="headerlink" title="instanceof进行类型判断"></a>instanceof进行类型判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xialuo <span class="hljs-keyword">instanceof</span> Student <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ol><li>每个class都有显式原型prototype</li><li>每个class实例化后都有隐式原型__proto__</li><li>实例的隐式原型指向对应class的显式原型</li><li>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.<strong>proto</strong> === Student.proptotype</li></ol><p><img src="../../public/img/prototype.png" alt="原型图"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ol><li>能手绘原型链图</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="闭包的表现"><a href="#闭包的表现" class="headerlink" title="闭包的表现"></a>闭包的表现</h4><ol><li>函数作为参数被传递<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = create()<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>fn() <span class="hljs-comment">// log值为100</span><br></code></pre></td></tr></table></figure></li><li>函数作为返回值被返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>  fn()<br>&#125;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br>print(fn) <span class="hljs-comment">// 打印值仍为100</span><br></code></pre></td></tr></table></figure><blockquote><p>所有（闭包）自由变量的查找  是在函数<strong>定义</strong>的地方，向上级作用域查找 不是在执行的地方</p></blockquote></li></ol><h4 id="this的使用场景"><a href="#this的使用场景" class="headerlink" title="this的使用场景"></a>this的使用场景</h4><ol><li>作为普通函数  window</li><li>使用call bind apply （三个的区别 call可直接换this指向 bind是有返回值 返回值再调用）</li><li>作为对象方法被调用   指代的就是这个对象本身</li><li>在class方法中调用   当前实例本身 setTimeout注意</li><li>箭头函数 ()=&gt;{this} 和上级作用域的值一致<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对应上方点2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br>fn1.call(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;) <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-keyword">const</span> fn2 = fn1.bind(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;)<br>fn2(); <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-function"><span class="hljs-title">setTimeout</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// this === window</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>this取什么值是在函数被<strong>执行</strong>的时候确定的，不是在定义的时候</p></blockquote><h4 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h4><h5 id="手写bind函数"><a href="#手写bind函数" class="headerlink" title="手写bind函数"></a>手写bind函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// bind function</span><br><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将参数拆分成数组</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-comment">// 获取this</span><br>  <span class="hljs-keyword">const</span> t = args.shift()<br>  <span class="hljs-comment">// fn1.bind(...) 中的 fn1 实例</span><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span><br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> self.apply(t,args)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h5><ol><li>隐藏数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 闭包cache  数据隐藏</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = &#123;&#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,val</span>) </span>&#123;<br>      data[key] = val<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> data[key]<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> c = createCache()<br>c.set(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(c.get(<span class="hljs-string">&quot;a&quot;</span>))<br></code></pre></td></tr></table></figure></li><li>循环绑定事件<br>for循环中给标签添加监听事件addEventListener<br>调用的时候循环已经结束 调用时的增量i为循环结束时i的取值了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><blockquote><p>基于js是单线程语言  callback回调<br>异步不会阻塞代码执行<br>同步会阻塞代码执行</p></blockquote></li></ol><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="同步异步的区别是什么"><a href="#同步异步的区别是什么" class="headerlink" title="同步异步的区别是什么"></a>同步异步的区别是什么</h5><p>异步不会阻塞代码执行<br>同步会阻塞代码执行</p><h5 id="手写用promise加载一张图片"><a href="#手写用promise加载一张图片" class="headerlink" title="手写用promise加载一张图片"></a>手写用promise加载一张图片</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImg</span>(<span class="hljs-params">src</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;img&quot;</span>)<br>      img.onload = <span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(img)<br>      &#125;<br>      img.onerror = <span class="hljs-function">() =&gt;</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>))<br>      &#125;<br>      img.src = src<br>    &#125;<br>  )<br>&#125;<br>loadImg(url).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.width)<br>  <span class="hljs-keyword">return</span> img <span class="hljs-comment">// 普通对象 loadImg返回的对象值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.height)<br>  <span class="hljs-keyword">return</span> loadImg(url2)  <span class="hljs-comment">// 返回的是new promise 后面的then取到的loadImg请求的返回值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img2</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h5 id="前端使用异步的场景有哪些"><a href="#前端使用异步的场景有哪些" class="headerlink" title="前端使用异步的场景有哪些"></a>前端使用异步的场景有哪些</h5><p>请求后台数据</p><h2 id="JS异步-进阶"><a href="#JS异步-进阶" class="headerlink" title="JS异步-进阶"></a>JS异步-进阶</h2><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><ul><li>event loop过程1<ul><li>同步代码，一行一行放在call Stack执行</li><li>遇到异步，会先记录下，等待时机（定时，网络请求）</li><li>时机到了，就会移动到callback queue</li></ul></li><li>event loop过程2<ul><li>如果call stack为空（同步代码执行完），event loop开始工作</li><li>轮训查找callback queue，如果有则移动到call stack</li><li>然后继续轮训查找</li></ul></li></ul><h3 id="dom事件与event-loop关系"><a href="#dom事件与event-loop关系" class="headerlink" title="dom事件与event loop关系"></a>dom事件与event loop关系</h3><ol><li>js是单线程的</li><li>异步都是基于event loop的</li><li>dom事件也使用回调，也是基于event loop</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).on(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">// 注意这里的click是立即执行的，但是function会被立刻放到webapi的库中，</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;btn clicked&#x27;</span>); <span class="hljs-comment">// 当用户点击click时，function会被放入到callback queue中</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6常用技巧</title>
    <link href="/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="对象取值方式"><a href="#对象取值方式" class="headerlink" title="对象取值方式"></a>对象取值方式</h3><blockquote><p>用解构赋值的方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj;<br><span class="hljs-keyword">const</span> res = a + b; <br></code></pre></td></tr></table></figure><p>如果想创建的变量名和对象的属性名不一致，可用取别名的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">a</span>:myName&#125; = obj;<br></code></pre></td></tr></table></figure><blockquote><p>注意：解构的对象不能为undefined和null，会报错<br>可以给一个默认值：空对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj || &#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并数据方式"><a href="#合并数据方式" class="headerlink" title="合并数据方式"></a>合并数据方式</h3><p>一般方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array</span><br><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> c = a.concat(b);<br><span class="hljs-comment">// object</span><br><span class="hljs-keyword">const</span> d = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> e = &#123;<br>  <span class="hljs-attr">f</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> g = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,d,e)<span class="hljs-comment">//a:1,f:1 注意Object.assign是浅拷贝</span><br></code></pre></td></tr></table></figure><p>ES6方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> c = [...new <span class="hljs-built_in">Set</span>([...a,...b])];<br><span class="hljs-keyword">const</span> g = &#123;...d,...e&#125; <span class="hljs-comment">//解构赋值也是浅拷贝</span><br></code></pre></td></tr></table></figure><h3 id="if中判断条件"><a href="#if中判断条件" class="headerlink" title="if中判断条件"></a>if中判断条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span> || type == <span class="hljs-number">2</span> || type == <span class="hljs-number">3</span> ) &#123;...&#125;<br><span class="hljs-comment">// 改进之后 用es6新增的includes方法</span><br><span class="hljs-keyword">const</span> condition = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">if</span>(condition.includes(type))<br></code></pre></td></tr></table></figure><h3 id="获取对象属性值的方法"><a href="#获取对象属性值的方法" class="headerlink" title="获取对象属性值的方法"></a>获取对象属性值的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = obj &amp;&amp; obj.name<br><span class="hljs-comment">// 改进之后 es6的可选链操作符</span><br><span class="hljs-keyword">const</span> name = obj?.name<br></code></pre></td></tr></table></figure><h3 id="输入框非空的判断"><a href="#输入框非空的判断" class="headerlink" title="输入框非空的判断"></a>输入框非空的判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// 改进后 空值合并运算符</span><br><span class="hljs-keyword">if</span>(value ?? <span class="hljs-string">&#x27;&#x27;</span> !== <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="添加动态变化属性名的对象属性"><a href="#添加动态变化属性名的对象属性" class="headerlink" title="添加动态变化属性名的对象属性"></a>添加动态变化属性名的对象属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> key = <span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>;<br>obj[key] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br><span class="hljs-comment">// 改进之后 对象属性名用表达式</span><br>obj[<span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async和await</title>
    <link href="/2021/11/08/async%E5%92%8Cawait/"/>
    <url>/2021/11/08/async%E5%92%8Cawait/</url>
    
    <content type="html"><![CDATA[<h1 id="async-await要点"><a href="#async-await要点" class="headerlink" title="async await要点"></a>async await要点</h1><ol><li>await 后面可以追加 promise 对象，获取 resolve 的值</li><li>await 必须包裹在 async 函数里面</li><li>async 函数执行返回的也是一个 promise 对象</li><li>try-catch 截获 promise 中 reject 的值</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, async, await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual DOM理解</title>
    <link href="/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/"/>
    <url>/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><blockquote><p>用原生的JavaScript对象去描述一个DOM节点</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>vue2底层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐分享</title>
    <link href="/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"/>
    <url>/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h1><blockquote><p>这个文件用来记录喜欢的音乐</p></blockquote><h3 id="To-Be-Continued"><a href="#To-Be-Continued" class="headerlink" title="To Be Continued"></a>To Be Continued</h3><blockquote><p>2022/4/14  生存指南</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AllToDo</title>
    <link href="/2021/10/31/AllToDo/"/>
    <url>/2021/10/31/AllToDo/</url>
    
    <content type="html"><![CDATA[<h1 id="所有的TODO"><a href="#所有的TODO" class="headerlink" title="所有的TODO"></a>所有的TODO</h1><blockquote><p>每次修改完记得提交到github</p></blockquote><p>什么都容易遗忘 基础都得夯实<br>html css js 移动端 webApi jquery node echarts vue react 微信小程序  </p><p>当前最重要任务  <strong>看面试题</strong><br>看面试题书 将重要的写成博客</p><h3 id="blog配置相关"><a href="#blog配置相关" class="headerlink" title="blog配置相关"></a>blog配置相关</h3><ol><li>添加代码提交规范 commitlint插件 + husky插件  10.31</li></ol><h3 id="blog内容相关"><a href="#blog内容相关" class="headerlink" title="blog内容相关"></a>blog内容相关</h3><ol><li>【网络】get和post传值的区别  10.31</li><li>【vue2】promise原理理解（实现代码）  10.31</li><li>【vue2底层】vue2底层学习笔记  10.31</li><li>【js】call方法作用及使用方式  10.31</li><li>【vue】模块化规范-require和import区别 11.8</li><li>【js】常用ES6技巧</li><li>【js】常用深浅拷贝记录</li><li>【基础】递归方法的实现</li><li>【js】手写new函数 bind（面试题已写） call apply 12.14</li><li>【css】@mixin</li><li>【css】用纯html+css3实现轮播图</li><li>【css】grid布局  1.1</li><li>【echarts】至少要用过一些</li></ol><h3 id="可提升方面"><a href="#可提升方面" class="headerlink" title="可提升方面"></a>可提升方面</h3><ol><li>js优化能力： 封装成类   封装成类的能力太弱</li></ol><h3 id="当前任务"><a href="#当前任务" class="headerlink" title="当前任务"></a>当前任务</h3><h4 id="完成一个简易版qq-socket-io-vue-express-mysql"><a href="#完成一个简易版qq-socket-io-vue-express-mysql" class="headerlink" title="完成一个简易版qq   socket.io+vue+express+mysql"></a>完成一个简易版qq   socket.io+vue+express+mysql</h4><p>两个页面 私聊 + 群聊<br>vue create 一个项目出来 完成</p><h4 id="qq项目"><a href="#qq项目" class="headerlink" title="qq项目"></a>qq项目</h4><p>qq前端项目   vue3-qq  注册  登录  聊天  三个页面<br>qq后端express 用express-generator   封装successModel  errorModel 返回请求成功或失败的返回值  参考blog-express  导出module.exports  引入require</p>]]></content>
    
    
    
    <tags>
      
      <tag>ToDo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/31/hello-world/"/>
    <url>/2021/10/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>How to publish a new article by hexo</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
