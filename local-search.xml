<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用代码整理</title>
    <link href="/2023/12/27/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <url>/2023/12/27/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端埋点</title>
    <link href="/2023/04/19/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/"/>
    <url>/2023/04/19/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="前端埋点"><a href="#前端埋点" class="headerlink" title="前端埋点"></a>前端埋点</h2><h3 id="前端埋点是干啥的"><a href="#前端埋点是干啥的" class="headerlink" title="前端埋点是干啥的"></a>前端埋点是干啥的</h3><ol><li>数据监控（监控用户行为）<ol><li>统计页面pv uv</li><li>用户在每个页面停留的时间</li><li>用户在每个页面触发的行为</li></ol></li><li>性能监控<ol><li>首屏加载时间</li><li>http请求时间</li><li>页面渲染时间</li></ol></li></ol><h3 id="埋点方案总结"><a href="#埋点方案总结" class="headerlink" title="埋点方案总结"></a>埋点方案总结</h3><ol><li>手动埋点</li><li>声明式埋点</li><li>可视化埋点</li><li>全埋点（无埋点） 事件埋点上报，停留时间上报</li></ol><h3 id="事件埋点上报"><a href="#事件埋点上报" class="headerlink" title="事件埋点上报"></a>事件埋点上报</h3><p>通过给元素绑定自定义指令的方式实现(减少对原有代码的侵入)🍜，将信息存储在缓存池中定时上报，上报之后清空之前的上报信息</p><p>可以写一个自定义指令 uni-app</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-comment">// 自定义埋点指令</span><br>Vue.directive(<span class="hljs-string">&quot;buried&quot;</span>, &#123;<br>  <span class="hljs-attr">bind</span>: <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (binding.value) &#123;<br>      <span class="hljs-comment">//这里参数是根据自己业务可以自己定义</span><br>      <span class="hljs-keyword">let</span> params = &#123;<br>        <span class="hljs-attr">currentUrl</span>: binding.value.currentUrl,<br>        <span class="hljs-attr">triggerType</span>: binding.value.triggerType,<br>        <span class="hljs-attr">title</span>: binding.value.title,<br>        <span class="hljs-attr">frontTriggerType</span>: binding.value.triggerType,<br>        <span class="hljs-attr">behavior</span>: binding.value.behavior,<br>      &#125;;<br>      <span class="hljs-comment">//如果是浏览类型，直接保存,目前只考虑点击类型</span><br>      <span class="hljs-keyword">if</span> (binding.value.triggerType == <span class="hljs-string">&quot;browse&quot;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;browse&quot;</span>, params);<br>        <span class="hljs-comment">//调用后台接口保存数据</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (binding.value.triggerType == <span class="hljs-string">&quot;click&quot;</span>) &#123;<br>        <span class="hljs-comment">//如果是click类型，监听click事件</span><br>        el.addEventListener(<br>          <span class="hljs-string">&quot;click&quot;</span>,<br>          <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 将操作和内容存储在缓存中定时上报</span><br>            <span class="hljs-keyword">let</span> buriedArray = uni.getStorageSync(<span class="hljs-string">&#x27;buriedArray&#x27;</span>) <span class="hljs-comment">//获取埋点集合</span><br>            buriedArray.push(params)  <span class="hljs-comment">// 将埋点集合存入缓存中</span><br>            uni.setStorageSync(<span class="hljs-string">&#x27;buriedArray&#x27;</span>, buriedArray)<br>          &#125;,<br>          <span class="hljs-literal">false</span><br>        );<br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- <br>triggerType: 事件类型<br>title: 页面标题<br>currentUrl: 页面路由<br>behavior: 操作行为<br>--&gt;<br>&lt;view v-buried=&quot;&#123;<br>triggerType:&#x27;click&#x27;,<br>title:&#x27;我的&#x27;,<br>currentUrl: currentPath,<br>behavior:&#x27;点击我的收藏按钮&#x27;&#125;&quot;&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure><h3 id="停留时间上报"><a href="#停留时间上报" class="headerlink" title="停留时间上报"></a>停留时间上报</h3><p>需要重新封装路由，创建路由拦截在跳转之前记录来源,以及上一个页面的停留时间，当拦截器捕获成功之后🌯，如果发现停留时间大于xx秒进行上报</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> v5 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;uuid/v5&#x27;</span>;<br><span class="hljs-keyword">import</span> UniRouteGuard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/js_sdk/pocky-route-gurads/lib&#x27;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><br>Vue.use(UniRouteGuard);<br> <br><span class="hljs-keyword">const</span> guard = <span class="hljs-keyword">new</span> UniRouteGuard();<br> <br><span class="hljs-keyword">let</span> startTime = <span class="hljs-built_in">Date</span>.now();<br>guard.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> currentTime = <span class="hljs-built_in">Date</span>.now();<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.url &amp;&amp; <span class="hljs-keyword">from</span>.url == <span class="hljs-string">&#x27;/pages/first/index&#x27;</span>) &#123;<br>next()<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(router)<br><span class="hljs-keyword">if</span> (to.url) &#123;<br><span class="hljs-keyword">if</span> (to.url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>to.url = to.url.substr(<span class="hljs-number">0</span>, to.url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>))<br>&#125;<br>&#125;<br><span class="hljs-keyword">let</span> fromName = router.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.path == <span class="hljs-keyword">from</span>.url) ? router.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.path == <span class="hljs-keyword">from</span>.url).title : <span class="hljs-string">&#x27;未知&#x27;</span><br><span class="hljs-keyword">let</span> toName = router.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.path == to.url) ? router.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.path == to.url).title : <span class="hljs-string">&#x27;未知&#x27;</span><br>  <span class="hljs-keyword">const</span> stayTime=  <span class="hljs-built_in">parseInt</span>((currentTime - startTime) / <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">const</span> MY_NAMESPACE = <span class="hljs-string">&#x27;1b671a64-40d5-491e-99b0-da01ff1f3341&#x27;</span>;<br> <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`由<span class="hljs-subst">$&#123;fromName&#125;</span>跳转到<span class="hljs-subst">$&#123;toName&#125;</span>并在<span class="hljs-subst">$&#123;fromName&#125;</span>中停留了<span class="hljs-subst">$&#123;stayTime&#125;</span>秒钟`</span>);<br><span class="hljs-keyword">let</span> params = &#123;<br><span class="hljs-attr">fromUrl</span>: <span class="hljs-keyword">from</span>.url, <span class="hljs-comment">//来源地址</span><br><span class="hljs-attr">toUrl</span>: to.url, <span class="hljs-comment">// 目的地址</span><br><span class="hljs-attr">fromName</span>: fromName, <span class="hljs-comment">// 来源名称</span><br><span class="hljs-attr">toName</span>: toName, <span class="hljs-comment">// 目的名称</span><br><span class="hljs-attr">stayTime</span>: stayTime, <span class="hljs-comment">// 停留时长</span><br><span class="hljs-attr">guid</span>: v5(<span class="hljs-keyword">from</span>.url, MY_NAMESPACE), <span class="hljs-comment">//页面uuid</span><br><span class="hljs-attr">appUuid</span>: uni.getStorageSync(<span class="hljs-string">&#x27;appUuid&#x27;</span>) ? uni.getStorageSync(<span class="hljs-string">&#x27;appUuid&#x27;</span>) : <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// app唯一标识</span><br><span class="hljs-attr">model</span>: uni.getStorageSync(<span class="hljs-string">&quot;model&quot;</span>)? uni.getStorageSync(<span class="hljs-string">&#x27;model&#x27;</span>) : <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 手机型号</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(params)<br>  <span class="hljs-keyword">if</span>(stayTime&gt;<span class="hljs-number">10</span>)&#123;<br>   <span class="hljs-comment">// 上报逻辑</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;停留的时间大于10秒钟了，可以进行上报&#x27;</span>)<br>  &#125;<br>  startTime = <span class="hljs-built_in">Date</span>.now();<br>next();<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/hsany330/article/details/125070076">https://blog.csdn.net/hsany330/article/details/125070076</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>埋点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023面试题整理</title>
    <link href="/2023/02/21/2023%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2023/02/21/2023%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h1><h2 id="js-手写题"><a href="#js-手写题" class="headerlink" title="js 手写题"></a>js 手写题</h2><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 是null或者不是对象和数组 直接返回</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 保证key不是原型的属性</span><br>      result[item] = deepClone(obj[item]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 方法2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-comment">// 1 判断是否是非应用类型或者null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-comment">// 2 创建一个容器</span><br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor()<br>    <span class="hljs-comment">// 3 拿到对象的keys，给容器赋值</span><br>    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> cloneObj[v] = deepClone(obj[v]))<br>    <span class="hljs-comment">// 4 返回容器</span><br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="手写-call-apply-bind-函数"><a href="#手写-call-apply-bind-函数" class="headerlink" title="手写 call apply bind 函数"></a>手写 call apply bind 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">context, args</span>) </span>&#123;<br>  context = context || <span class="hljs-built_in">window</span><br>  args = args ? args : [];<br>  context.fn = <span class="hljs-built_in">this</span>;<span class="hljs-comment">// this是调用的函数</span><br>  <span class="hljs-keyword">const</span> res = context.fn(...args);<br>  <span class="hljs-keyword">delete</span> context.fn;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 剩下的都一样</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  context = context || <span class="hljs-built_in">window</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">this</span> <br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newFn</span>(<span class="hljs-params">...fnArgs</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> res<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> newFn) &#123;<br>      res = <span class="hljs-keyword">new</span> fn(...args, ...fnArgs)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      res = fn.call(context, ...args, ...fnArgs)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写一个简易的jquery，考虑插件和扩展性"><a href="#手写一个简易的jquery，考虑插件和扩展性" class="headerlink" title="手写一个简易的jquery，考虑插件和扩展性"></a>手写一个简易的jquery，考虑插件和扩展性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(Selector);<br>    <span class="hljs-keyword">const</span> length = result.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;length;i++) &#123;<br>      <span class="hljs-built_in">this</span>[i] = result[i]<br>    &#125;<br>    <span class="hljs-built_in">this</span>.length = length<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">index</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[index]<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">each</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.length;i++) &#123;<br>      <span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">this</span>[i];<br>      fn(elem)<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type,fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.each(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> &#123;<br>      elem.addEventListener(type,fn,<span class="hljs-literal">false</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 插件</span><br>jQuery.prototype.dialog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>&#123;<br>  alert(info)<br>&#125;<br><br><span class="hljs-comment">// 造轮子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJquery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(selector);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写-new-函数"><a href="#手写-new-函数" class="headerlink" title="手写 new 函数"></a>手写 new 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNew</span>(<span class="hljs-params">Fn, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> newObj = <span class="hljs-built_in">Object</span>.create(Fn);<br>  <span class="hljs-keyword">const</span> res = Fn.apply(newObj, args);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> ? res : newObj;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newFunc</span>(<span class="hljs-params">father, ...rest</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.__proto__ = father.prototype;<br>  <span class="hljs-keyword">var</span> result2 = father.apply(result, rest);<br>  <span class="hljs-keyword">if</span> (<br>    (<span class="hljs-keyword">typeof</span> result2 === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> result2 === <span class="hljs-string">&#x27;function&#x27;</span>) &amp;&amp;<br>    result2 !== <span class="hljs-literal">null</span><br>  ) &#123;<br>    <span class="hljs-keyword">return</span> result2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件总线-发布订阅模式-event-bus-（EventMitter）"><a href="#事件总线-发布订阅模式-event-bus-（EventMitter）" class="headerlink" title="事件总线 | 发布订阅模式 event bus （EventMitter）"></a>事件总线 | 发布订阅模式 event bus （EventMitter）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 发布订阅模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventEmitter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.events = &#123;&#125; <span class="hljs-comment">// 事件存放对象</span><br>  <span class="hljs-built_in">this</span>._maxListener = <span class="hljs-number">10</span>; <span class="hljs-comment">// 默认最大绑定函数个数</span><br>&#125;<br>EventEmitter.prototype.on = EventEmitter.prototype.addListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type,listener</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.events[type]) &#123;<br>    <span class="hljs-built_in">this</span>.events[type].push(listener); <span class="hljs-comment">// 一个事件名可以绑定函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.events[type].length != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">this</span>.events[type].length &gt; <span class="hljs-built_in">this</span>._maxListener) &#123; <span class="hljs-comment">// 绑定函数数据大于最大限定个数</span><br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`MaxListenersExceededWarning: Possible EventEmitter memory leak detected. <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.events[type].length&#125;</span> <span class="hljs-subst">$&#123;type&#125;</span> listeners added. Use emitter.setMaxListeners() to increase limit`</span>)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">this</span>.events[type] = [listener]; <br>  &#125;<br>&#125;<br>EventEmitter.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type,...args</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.events[type] &amp;&amp; <span class="hljs-built_in">this</span>.events[type].forEach(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 依次执行绑定的函数(数组)</span><br>    item(...args);<br>  &#125;)<br>&#125;<br>EventEmitter.prototype.once = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type,listener</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> wrapper =  <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123; <span class="hljs-comment">// 对once进行包裹，执行完就移除，实现只执行一次的效果</span><br>    listener(...args);<br>    <span class="hljs-built_in">this</span>.removeListener(type, wrapper);<br>  &#125;<br>  <span class="hljs-built_in">this</span>.on(type,wrapper);<br>&#125;<br><br>EventEmitter.prototype.removeListener = EventEmitter.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type,listener</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.events[type]) &#123;<br>    <span class="hljs-built_in">this</span>.events[type] = <span class="hljs-built_in">this</span>.events[type].filter(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l != listener); <span class="hljs-comment">// 过滤掉需要移除的绑定函数</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;no listener is able to remove&#x27;</span>);<br>  &#125;<br>&#125;<br>EventEmitter.prototype.removeAllListeners = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...type</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(type)<br>  type.forEach(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.events[t] = <span class="hljs-literal">null</span>;<br>  &#125;)<br>&#125;<br><br>EventEmitter.prototype.setMaxListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">maxListener</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>._maxListener = maxListener; <span class="hljs-comment">// 设置最大绑定函数个数</span><br>&#125;<br>EventEmitter.prototype.listeners = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.events[type]; <span class="hljs-comment">// 返回所有指定事件的绑定函数</span><br>&#125;<br>EventEmitter.prototype.getMaxListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._maxListener; <span class="hljs-comment">// 获取最大绑定函数个数</span><br>&#125;<br>EventEmitter.prototype.listenerCount = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.events[type] ? <span class="hljs-built_in">this</span>.events[type].length : <span class="hljs-number">0</span>; <span class="hljs-comment">// 获取指定事件绑定的函数个数</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = EventEmitter;<br></code></pre></td></tr></table></figure><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCurried</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args1.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-literal">null</span>, ...args1)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">null</span>, [...args1, ...args2])<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. set</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr)];<br>&#125;<br><span class="hljs-comment">// 2. 双层for循环splice去重</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] == arr[j]) &#123;<br>        <span class="hljs-comment">//第一个等同于第二个，splice方法删除第二个</span><br>        arr.splice(j, <span class="hljs-number">1</span>);<br>        j--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">// 3. 单层for循环加indexOf</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> array = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; arr.length;i++) &#123;<br>    <span class="hljs-keyword">if</span>(array.indexOf(arr[i]) === -<span class="hljs-number">1</span>) &#123;<br>      array.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-comment">// 4. sort之后 前后不同的加入数组</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  arr = arr.sort();<br>  <span class="hljs-keyword">let</span> res = [arr[<span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i&lt;arr.length;i++) &#123;<br>    <span class="hljs-keyword">if</span>(arr[i] !== arr[i-<span class="hljs-number">1</span>]) &#123;<br>      array.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 5. includes</span><br><span class="hljs-comment">// 6. map数据结构去重 把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果</span><br><span class="hljs-comment">//7. filter</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> array.indexOf(item) === index;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">target, origin</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&quot;object&quot;</span> || target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> origin !== <span class="hljs-string">&quot;function&quot;</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;origin must be function&quot;</span>);<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(target); <span class="hljs-comment">// 相当于 proto = target.__proto__;</span><br>  <span class="hljs-keyword">while</span> (proto) &#123;<br>    <span class="hljs-keyword">if</span> (proto === origin.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>TODO:重点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr,depth = <span class="hljs-number">1</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(depth &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> pre.concat(<span class="hljs-built_in">Array</span>.isArray(cur) ? flat(cur,depth - <span class="hljs-number">1</span>) : cur)<br>    &#125;,[])<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.slice()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>不管点多少次 一段时间内只执行一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用时间戳</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> preTime = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> nowTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt; wait) &#123;<br>      func.apply(context, args);<br>      preTime = nowTime;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (!timeout) &#123;<br>      <span class="hljs-comment">// 在timeout这段时间内timer都是存在的，就不会执行func，timeout时间一过就会再次执行</span><br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>不管点多少次 点击结束后一段时间才执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 如果有定时器 就清除定时器啥也不执行，没有定时器后delay秒再执行方法</span><br>    <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-keyword">let</span> callNow = !timeout;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) func.apply(context, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb,initialValue</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">let</span> total = initialValue || arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = initialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    total = cb(total,arr[i],i,arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><h3 id="异步控制并发数"><a href="#异步控制并发数" class="headerlink" title="异步控制并发数"></a>异步控制并发数</h3><h3 id="es5-和-es6-继承"><a href="#es5-和-es6-继承" class="headerlink" title="es5 和 es6 继承"></a>es5 和 es6 继承</h3><h4 id="es5"><a href="#es5" class="headerlink" title="es5"></a>es5</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.prototype = <span class="hljs-literal">true</span>;<br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prototype;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span>;<br>&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> SubType();<br><br>SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;RUN&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br><br>    <span class="hljs-built_in">this</span>.gender = <span class="hljs-string">&quot;男&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">fight</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot; FIGHT&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> User = <span class="hljs-keyword">new</span> Man(<span class="hljs-string">&quot;LI Lei&quot;</span>);<br><span class="hljs-built_in">console</span>.log(User);<br><br></code></pre></td></tr></table></figure><h3 id="数组排序-快速排序"><a href="#数组排序-快速排序" class="headerlink" title="数组排序 快速排序"></a>数组排序 快速排序</h3><p>TODO: 背</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>  quickSort(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums);<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">start, end, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>    <span class="hljs-keyword">const</span> mid = sort(start, end, arr);<br>    quickSort(start, mid - <span class="hljs-number">1</span>, arr);<br>    quickSort(mid + <span class="hljs-number">1</span>, end, arr);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">start, end, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> base = arr[start];<br>  <span class="hljs-keyword">let</span> left = start;<br>  <span class="hljs-keyword">let</span> right = end;<br>  <span class="hljs-keyword">while</span> (left !== right) &#123;<br>    <span class="hljs-keyword">while</span> (arr[right] &gt;= base &amp;&amp; right &gt; left) &#123;<br>      right--;<br>    &#125;<br>    arr[left] = arr[right];<br>    <span class="hljs-keyword">while</span> (arr[left] &lt;= base &amp;&amp; right &gt; left) &#123;<br>      left++;<br>    &#125;<br>    arr[right] = arr[left];<br>  &#125;<br>  arr[left] = base;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取-url-参数"><a href="#获取-url-参数" class="headerlink" title="获取 url 参数"></a>获取 url 参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParam</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来</span><br>  <span class="hljs-keyword">const</span> paramsArr = paramsStr.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><br>  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将 params 存到对象中</span><br>  paramsArr.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数</span><br>      <span class="hljs-keyword">let</span> [key, val] = param.split(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 分割 key 和 value</span><br>      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码</span><br>      val = <span class="hljs-regexp">/^\d+$/</span>.test(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span><br>      <span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><br>        paramsObj[key] = [].concat(paramsObj[key], val);<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span><br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span><br>      paramsObj[param] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="html-amp-css-相关"><a href="#html-amp-css-相关" class="headerlink" title="html&amp;css 相关"></a>html&amp;css 相关</h2><h3 id="转字符串类型的3种方法"><a href="#转字符串类型的3种方法" class="headerlink" title="转字符串类型的3种方法"></a>转字符串类型的3种方法</h3><ol><li>value.toString() 参数可以控制转成多少进制 默认十进制</li><li>value + “” 加空字符串即可</li><li>String（）将数字转成字符串</li><li>模板字符串</li></ol><h3 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h3><p>src和href都是用来引用外部的资源<br><code>&lt;a link href=&quot;xxx&quot; /&gt; &lt;script src=&quot;xxx.js /&gt;&quot;</code><br>src用于替换当前元素,href用于在当前文档和引用资源之确立联系</p><p>src在浏览器中被解析到时会暂停其他资源的下载和处理，并且把该资源加载编译完成。<br>href在文档中进行添加时，浏览器会识别到这个文档，并命名为css文件，就会下载合并资源，同时也不会停止对当前文档的处理。</p><h3 id="rem-em"><a href="#rem-em" class="headerlink" title="rem em"></a>rem em</h3><p>都是相对设置的大小，rem相对于根节点html的字体大小，em是相对于父元素的字体大小</p><h3 id="css中link和-import的区别"><a href="#css中link和-import的区别" class="headerlink" title="css中link和@import的区别"></a>css中link和@import的区别</h3><ol><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等事务。 @import属于CSS范畴，只能加载CSS</li><li>link引用CSS在页面加载时同时加载，@import会阻塞后续css的加载。</li><li>link是XHTML标签，没有兼容性，@import是在CSS2.1中提出的，低版浏览器不支持</li><li>link支持使用Javascript控制DOM来改变样式；@import不支持。</li></ol><h3 id="伪元素和伪类区别"><a href="#伪元素和伪类区别" class="headerlink" title="伪元素和伪类区别"></a>伪元素和伪类区别</h3><p>伪类其实就是基于普通DOM元素而产生的不同<strong>状态</strong>，他是DOM元素的某一特征。伪类用单冒号:表示  :link :hover :visited :first-child</p><p>伪元素能够创建在DOM树中不存在的<strong>抽象对象</strong>，而且这些抽象对象是能够访问到的。伪元素用双冒号::表示 ::before ::first-line</p><h3 id="布局有哪些"><a href="#布局有哪些" class="headerlink" title="布局有哪些"></a>布局有哪些</h3><p>浮动布局（float layout）<br>定位布局（position layout）：<br>弹性布局（flexbox layout）<br>网格布局（grid layout）</p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p><code>display:grid</code></p><ol><li>grid-template-columns: 80px 90px auto 100px;//4列</li><li>grid-template-rows //每一个行高</li><li>justify-content：space-evenly</li><li>grid-column： 1/5 属性 是grid-column-start 和 grid-column-end 属性的简写 </li><li>同理grid-row是行</li><li>grid-area 属性是 grid-row-start, grid-column-start, grid-row-end 以及 grid-column-end 属性的简写。 <code>grid-area: 1 / 2 / 5 / 6;</code></li></ol><h3 id="html5新特性"><a href="#html5新特性" class="headerlink" title="html5新特性"></a>html5新特性</h3><ol><li>语义化标签   header footer nav</li><li>表单新属性  color date datetime number url search</li><li>canvas绘图 </li><li>音视频 audio video</li><li>svg绘图  可伸缩矢量图</li><li>地理定位  getCurrentPosition()获取用户位置</li><li>拖放api div draggable=”true”</li><li>websocket 全双工通信机制 实时聊天</li><li>webworker Web Worker可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。</li><li>webstorage localstorage sessionstorage</li></ol><h3 id="全屏滚动的实现"><a href="#全屏滚动的实现" class="headerlink" title="全屏滚动的实现"></a>全屏滚动的实现</h3><ol><li>首先 将主容器设置为占满整个屏幕，并禁止页面滚动</li><li>将每个section元素设置为占满整个屏幕，并使用绝对定位将它们垂直堆叠在一起</li><li>监听wheel事件 计算滚动的位置 然后window.scrollTo跳转过去<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;wheel&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  event.preventDefault(); <span class="hljs-comment">// 阻止默认滚动行为</span><br>  <br>  <span class="hljs-keyword">var</span> delta = event.deltaY;<br>  <span class="hljs-keyword">var</span> scrollSpeed = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 滚动速度，可根据需求调整</span><br>  <br>  <span class="hljs-comment">// 计算下一个要滚动到的位置</span><br>  <span class="hljs-keyword">var</span> scrollPosition = <span class="hljs-built_in">window</span>.pageYOffset + delta * scrollSpeed;<br>  <br>  <span class="hljs-comment">// 滚动动画</span><br>  <span class="hljs-built_in">window</span>.scrollTo(&#123;<br>    <span class="hljs-attr">top</span>: scrollPosition,<br>    <span class="hljs-attr">behavior</span>: <span class="hljs-string">&#x27;smooth&#x27;</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h3 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h3><p>就是利用css的媒体查询功能根据不同屏幕大小 ，向下兼容设备</p><h3 id="无样式内容闪烁怎么处理"><a href="#无样式内容闪烁怎么处理" class="headerlink" title="无样式内容闪烁怎么处理"></a>无样式内容闪烁怎么处理</h3><p>一般是因为css文件的@import导致的</p><ol><li>预加载CSS和JavaScript 页面闪烁的原因往往是由于CSS和JavaScript文件的加载较慢导致页面元素的布局错乱。因此,预加载CSS和JavaScript文件成为解决页面闪烁问题的一种有效手段。可以通过将CSS文件放在<head>标签中的<link>元素中,同时将JavaScript文件放在<body>标签底部的<script>元素中,使得CSS和JavaScript文件能够优先加载</li><li>使用缓存和压缩 可以减少页面加载时间,并降低页面闪烁的风险</li></ol><h3 id="html语义化标签怎么理解"><a href="#html语义化标签怎么理解" class="headerlink" title="html语义化标签怎么理解"></a>html语义化标签怎么理解</h3><p>语义化是指根据内容的结构化（<strong>内容</strong>语义化），选择合适的标签（代码语义化），就是html的标签名要有意义</p><ul><li>让人更容易读懂</li><li>让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息</li><li>没有css情况下，也能呈现很好的内容结构</li></ul><h3 id="script-标签的-defer-和-async-区别"><a href="#script-标签的-defer-和-async-区别" class="headerlink" title="script 标签的 defer 和 async 区别"></a>script 标签的 defer 和 async 区别</h3><p>script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html<br>async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行。async脚本的 下载 不会阻塞页面的解析渲染。async脚本的<strong>执行</strong>会阻塞页面的解析渲染 <strong>异步下载，立即执行</strong><br>defer script: 完全不阻碍html的解析，解析完成后再按照<strong>顺序</strong>执行脚本 <strong>异步下载，解析完执行</strong></p><p>区别在于：多个脚本异步载入时，defer会按照文档中排列的顺序按序执行，而async是谁先完成载入谁先执行，是无序的</p><h3 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h3><h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h4><p>meta 标签是由 name 和 content 属性定义，用来描述网页文档的属性，类似给网页添加的标签</p><h4 id="常用的name有"><a href="#常用的name有" class="headerlink" title="常用的name有"></a>常用的name有</h4><ol><li>charset  <code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code></li><li>keywords  <code>&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</code></li><li>description  <code>&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</code></li><li>viewport  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code></li></ol><h3 id="img的srcset属性的作用"><a href="#img的srcset属性的作用" class="headerlink" title="img的srcset属性的作用"></a>img的srcset属性的作用</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片，不同屏幕密度下加载不同图片<br><code>&lt;img src=&quot;image-128.png&quot;      srcset=&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;      sizes=&quot;(max-width: 360px) 340px, 128px&quot; /&gt;</code></p><h3 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h3><p>允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。</p><p><code>const worker = new Worker(path, options);</code></p><p>主线程与 worker 线程都是通过 postMessage 方法来发送消息，以及监听 message 事件来接收消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js（主线程）</span><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;/worker.js&#x27;</span>); <span class="hljs-comment">// 创建worker</span><br>myWorker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123; <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-built_in">console</span>.log(e.data); <span class="hljs-comment">// Greeting from Worker.js，worker线程发送的消息</span><br>&#125;);<br><span class="hljs-comment">// 这种写法也可以</span><br><span class="hljs-comment">// myWorker.onmessage = e =&gt; &#123; // 接收消息</span><br><span class="hljs-comment">//    console.log(e.data);</span><br><span class="hljs-comment">// &#125;;</span><br>myWorker.postMessage(<span class="hljs-string">&#x27;Greeting from Main.js&#x27;</span>); <span class="hljs-comment">// 向 worker 线程发送消息，对应 worker 线程中的 e.data</span><br><span class="hljs-comment">// worker.js worker线程</span><br>self.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123; <span class="hljs-comment">// 接收到消息</span><br>    <span class="hljs-built_in">console</span>.log(e.data); <span class="hljs-comment">// Greeting from Main.js，主线程发送的消息</span><br>    self.postMessage(<span class="hljs-string">&#x27;Greeting from Worker.js&#x27;</span>); <span class="hljs-comment">// 向主线程发送消息</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a>iframe 有那些优点和缺点？</h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>优点：</p><ul><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li>绕过cors（跨域）限制，实现跨子域通信</li><li>并行加载脚本<br>缺点：</li><li>iframe 会阻塞主页面的 onload 事件，减慢页面加载速度</li><li>第三方网站不受控制</li><li>没有语义，无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul><p>如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值</p><h3 id="Canvas和SVG的区别"><a href="#Canvas和SVG的区别" class="headerlink" title="Canvas和SVG的区别"></a>Canvas和SVG的区别</h3><p>SVG：可缩放矢量图形<br>特点：</p><ol><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li></ol><p>Canvas： Canvas是画布，其位置发生改变，就会重新进行绘制<br>特点：</p><ol><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ol><h3 id="文档声明（Doctype）和-lt-Doctype-html-gt-有何作用"><a href="#文档声明（Doctype）和-lt-Doctype-html-gt-有何作用" class="headerlink" title="文档声明（Doctype）和&lt;!Doctype html&gt;有何作用?"></a>文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用?</h3><p>文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。<br><code>&lt;!doctype html&gt;</code>是进入标准模式，不写这个就是进入混杂模式<br>严格模式（标准模式）： 指浏览器按照W3C标准解析代码<br>混杂模式： 指浏览器用自己的方式解析代码</p><p>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</p><h3 id="谷歌浏览器怎么支持小于12px的文字"><a href="#谷歌浏览器怎么支持小于12px的文字" class="headerlink" title="谷歌浏览器怎么支持小于12px的文字"></a>谷歌浏览器怎么支持小于12px的文字</h3><ol><li>transform:scale()  推荐这种</li><li>zoom：50% css缩小到原来的一半 有兼容问题，会触发重排</li></ol><h3 id="relative和absolute区别"><a href="#relative和absolute区别" class="headerlink" title="relative和absolute区别"></a>relative和absolute区别</h3><p>position的值<br>absolute fixed relative static inherit</p><ol><li>定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在，而定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在（不占位置了）。</li><li>absolute不受父元素里的其他元素影响，而relative会受到父元素里的其他元素影响</li><li>relative相对的总是<strong>自身原来的位置</strong>，无论其父元素是何种定位方式，而absolute总是相对于最近<strong>定义为absolute或relative的父层元素</strong></li></ol><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>两种盒模型：标准盒模型、IE盒模型<br>相同点：都是由 content + padding + border + margin构成<br>不同点：盒子内容的宽/高度<br>标准盒模型： 只包含content    box-sizing: content-box<br>IE盒模型： content + padding + border box-sizing: border-box</p><h3 id="选择器及其优先级"><a href="#选择器及其优先级" class="headerlink" title="选择器及其优先级"></a>选择器及其优先级</h3><p>!important &gt; style(内联) &gt; id &gt; class</p><h3 id="隐藏元素的方法有哪些"><a href="#隐藏元素的方法有哪些" class="headerlink" title="隐藏元素的方法有哪些"></a>隐藏元素的方法有哪些</h3><ol><li><code>display:none</code></li><li><code>visibility:hidden</code></li><li><code>opacity:0</code></li><li><code>position:absolute; top:9999px</code></li><li><code>z-index: -100</code></li><li><code>clip-path: circle(0)</code></li><li><code>transform:scale(0,0)</code></li></ol><h3 id="CSS3中有哪些新特性"><a href="#CSS3中有哪些新特性" class="headerlink" title="CSS3中有哪些新特性"></a>CSS3中有哪些新特性</h3><ol><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ol><h3 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display:none 与 visibility:hidden 的区别"></a>display:none 与 visibility:hidden 的区别</h3><ul><li>在渲染树中<br><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；<br><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li><li>是否是继承属性<br>display:none是<strong>非继承</strong>属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示 display修改会触发<strong>重排</strong><br>visibility:hidden是<strong>继承</strong>属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示 visibility修改只会造成本元素的<strong>重绘</strong></li></ul><h3 id="对-requestAnimationframe-的理解"><a href="#对-requestAnimationframe-的理解" class="headerlink" title="对 requestAnimationframe 的理解"></a>对 requestAnimationframe 的理解</h3><p>requestAnimationframe： 请求动画帧<br>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画<br><code>window.requestAnimationFrame(callback);</code><br>callback是下一次重绘之前更新动画帧所调用的函数<br>是 宏任务<br>cancelAnimationFrame(id)来取消执行动画，参数是requestAnimationFrame默认返回的id</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>CPU节能<ol><li>使用SetInterval 实现的动画，当页面被隐藏或最小化时，SetInterval 仍然在后台执行动画任务</li><li>RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li></ol></li><li>函数节流 <ol><li>高频率事件( resize, scroll 等)中，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来</li></ol></li><li>减少dom操作<ol><li>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成<h5 id="另一种说法"><a href="#另一种说法" class="headerlink" title="另一种说法"></a>另一种说法</h5></li></ol></li><li>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li><li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</li></ol><h4 id="setTimeout执行动画的缺点"><a href="#setTimeout执行动画的缺点" class="headerlink" title="setTimeout执行动画的缺点"></a>setTimeout执行动画的缺点</h4><p>它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象。</p><ol><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚。</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ol><h3 id="css和js实现动画分别有哪些优缺点"><a href="#css和js实现动画分别有哪些优缺点" class="headerlink" title="css和js实现动画分别有哪些优缺点"></a>css和js实现动画分别有哪些优缺点</h3><ol><li>css优点<ol><li>硬件加速  会用gpu进行硬件加速，，更加流畅和高效运行</li><li>简单易用  通常几行代码就可实现</li><li>低资源占用  使用更少的cpu和内存资源</li></ol></li><li>css缺点<ol><li>限制较大 不能自由控制动画的速度和方向</li><li>兼容性问题 不同浏览器对css动画支持程度不同，要考虑兼容性</li><li>可维护性差 当效果复杂时，css代码会变的冗长和难以维护</li></ol></li></ol><h3 id="js中阻止事件冒泡和默认行为"><a href="#js中阻止事件冒泡和默认行为" class="headerlink" title="js中阻止事件冒泡和默认行为"></a>js中阻止事件冒泡和默认行为</h3><ol><li>事件冒泡  event.stopPropagation()</li><li>事件默认行为 event.preventDefault()</li></ol><h3 id="reflow（重排-回流）和-repaint（重绘）理解"><a href="#reflow（重排-回流）和-repaint（重绘）理解" class="headerlink" title="reflow（重排/回流）和 repaint（重绘）理解"></a>reflow（重排/回流）和 repaint（重绘）理解</h3><h4 id="重排-回流："><a href="#重排-回流：" class="headerlink" title="重排/回流："></a>重排/回流：</h4><p><strong>第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流</strong><br>元素的<strong>几何信息</strong>被影响导致浏览器需要<strong>重新计算</strong>元素在视口内的几何属性（位置和尺寸）</p><h4 id="引发回流的几种情况"><a href="#引发回流的几种情况" class="headerlink" title="引发回流的几种情况"></a>引发回流的几种情况</h4><ol><li>DOM结构发生变改变，如添加新的节点或者移除节点</li><li>改变布局，如修改了width height padding font-size等值。</li><li>改变窗口 resize,修改了窗口的尺寸。</li><li>调用 getComputedStyle方法获取尺寸、位置信息。</li></ol><h4 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h4><p><strong>第一次渲染内容称之为绘制，之后重新渲染称之为重绘</strong><br>通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的<strong>实际像素</strong>的阶段</p><h4 id="引发重绘的几种情况"><a href="#引发重绘的几种情况" class="headerlink" title="引发重绘的几种情况"></a>引发重绘的几种情况</h4><p>修改背景色、文字颜色、边框颜色、样式等。</p><h3 id="如何减少重排和重绘"><a href="#如何减少重排和重绘" class="headerlink" title="如何减少重排和重绘"></a>如何减少重排和重绘</h3><ul><li>最小化重绘和重排，修改样式尽量集中一次性修改</li><li>尽量避免频繁的操作DOM</li><li>批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中</li><li>尽量避免通过 <code>getComputedStyle</code> 获取尺寸位置信息</li><li>使用 <strong>absolute</strong> 或 <strong>fixed</strong> 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显</li><li>开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘 TODO:D</li></ul><p><a href="https://juejin.cn/post/6844903779700047885">参考</a></p><h3 id="为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="为什么有时候⽤translate来改变位置⽽不是定位？"></a>为什么有时候⽤translate来改变位置⽽不是定位？</h3><ol><li>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。</li><li>transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。</li></ol><h3 id="BFC-的理解"><a href="#BFC-的理解" class="headerlink" title="BFC 的理解"></a>BFC 的理解</h3><p>block format context: 块级格式上下文 相当于一个独自的渲染区域 （内部布局不会影响外部）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>父元素垂直外边距不会与子元素重叠</li><li>bfc的元素不会被浮动元素覆盖</li><li>开启bfc的元素可以包含浮动元素</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>清除浮动主要是为了解决父元素因为子级元素浮动引起的内部高度为0的问题</li><li>处理外边距塌陷问题</li><li>使浮动元素不遮挡普通元素</li></ol><h4 id="如何开启bfc"><a href="#如何开启bfc" class="headerlink" title="如何开启bfc"></a>如何开启bfc</h4><ol><li>overflow:hidden</li><li>before after伪类 clear:both</li></ol><h3 id="实现两栏布局（左侧固定和右侧自适应）-5-种"><a href="#实现两栏布局（左侧固定和右侧自适应）-5-种" class="headerlink" title="实现两栏布局（左侧固定和右侧自适应） 5 种"></a>实现两栏布局（左侧固定和右侧自适应） 5 种</h3><ol><li>浮动<br>左侧元素宽度固定，向左浮动，右边元素margin-left设为固定宽度，<strong>width:auto</strong></li><li>浮动<br>左边元素宽度固定 ，设置向左浮动。右侧元素设置 <strong>overflow: hidden;</strong> 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li><li>flex<br>左边固定宽度，右边<strong>flex:1</strong></li><li>绝对定位<br>左边元素absolute，宽度固定，右边margin-left设为左边元素的宽度</li><li>绝对定位<br>左边元素宽度固定，右边元素 absolute  定位， left  为宽度大小，其余方向定位为 0</li></ol><h3 id="实现圣杯布局和双飞翼布局（三分栏）"><a href="#实现圣杯布局和双飞翼布局（三分栏）" class="headerlink" title="实现圣杯布局和双飞翼布局（三分栏）"></a>实现圣杯布局和双飞翼布局（三分栏）</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><ol><li>三栏布局，中间一栏最先加载和渲染（内容最重要，中间内容在html中最先写好从而最先加载）。</li><li>两侧内容固定，中间内容随着宽度自适应。</li><li>一般用于 PC 网页。</li></ol><h4 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h4><ol><li>使用 float 布局。</li><li>两侧使用 margin 负值，以便和中间内容横向重叠。</li><li>防止中间内容被两侧覆盖，圣杯布局用(父元素) padding ，双飞翼布局用（子元素） margin </li></ol><h3 id="水平垂直居中的实现"><a href="#水平垂直居中的实现" class="headerlink" title="水平垂直居中的实现"></a>水平垂直居中的实现</h3><ol><li><p>绝对定位 <strong>不需要管宽高</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>绝对定位 各方向为0 margin设为auto  盒子必须有宽高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>绝对定位 left和top定位之后通过margin-left和margin-top修改  必须有宽高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>flex 不定宽高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="flex：1-的含义"><a href="#flex：1-的含义" class="headerlink" title="flex：1 的含义"></a>flex：1 的含义</h3><p>flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。<br>flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。<br>flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .</p><h3 id="line-height-如何继承"><a href="#line-height-如何继承" class="headerlink" title="line-height 如何继承"></a>line-height 如何继承</h3><ol><li>父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。</li><li>父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。</li><li>父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。</li></ol><h3 id="文字超出省略，用什么css"><a href="#文字超出省略，用什么css" class="headerlink" title="文字超出省略，用什么css"></a>文字超出省略，用什么css</h3><h4 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box1</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 不换行 */</span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 超出省略 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box2</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">display</span>: -webkit-box; <span class="hljs-comment">/* 将对象作为弹性伸缩盒子模型显示 */</span><br>    -webkit-box-orient: vertical; <span class="hljs-comment">/* 设置子元素排列方式 */</span><br>    -webkit-line-clamp: <span class="hljs-number">3</span>; <span class="hljs-comment">/* 显示几行，超出的省略 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么画一条0-5px的线"><a href="#怎么画一条0-5px的线" class="headerlink" title="怎么画一条0.5px的线"></a>怎么画一条0.5px的线</h3><ol><li>height: 1px; transform: scale(0.5)<br>注意宽度也会变化，记得将宽度设为本来的200%</li></ol><h3 id="网页中有大量图片加载很慢，怎么优化"><a href="#网页中有大量图片加载很慢，怎么优化" class="headerlink" title="网页中有大量图片加载很慢，怎么优化"></a>网页中有大量图片加载很慢，怎么优化</h3><ol><li>图片懒加载 监听滚动条事件，判断图片位置与浏览器顶端和页面的距离，前者小于后者，优先加载</li><li>使用图片预加载技术，将当前展示图片的前一张和后一张优先下载</li><li>csssprite和svgsprite</li></ol><h2 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h2><h3 id="“1”-”2”-”3”-map-parseInt-值是啥"><a href="#“1”-”2”-”3”-map-parseInt-值是啥" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)值是啥"></a>[“1”,”2”,”3”].map(parseInt)值是啥</h3><p>[1,NaN,NaN] 因为parseInt需要两个参数val,radix<br>map传了3个(element,index,array) 对应的radix不合法导致解析失败</p><p>callback函数的执行规则<br>参数：自动传入三个参数<br>currentValue（当前被传递的元素）；<br>index（当前被传递的元素的索引）；<br>array（调用map方法的数组）</p><p>[“1”,”2”,”3”].map(v =&gt; parseInt(v)) 可以解析成功</p><h3 id="js的基本数据类型"><a href="#js的基本数据类型" class="headerlink" title="js的基本数据类型"></a>js的基本数据类型</h3><p>undefined null boolean number string </p><h3 id="js-的内置对象"><a href="#js-的内置对象" class="headerlink" title="js 的内置对象"></a>js 的内置对象</h3><p>数据封装类对象： Object Array Boolean Number String<br>其他对象： Function Arguments Math Date RegExp Error</p><h3 id="js的延迟加载方式有哪些"><a href="#js的延迟加载方式有哪些" class="headerlink" title="js的延迟加载方式有哪些"></a>js的延迟加载方式有哪些</h3><ol><li>动态创建script元素 并将其添加到DOM中 <code>var sc = document.createElement(&#39;script&#39;) script.src = &#39;a.js&#39; document.body.appendChild(sc)</code></li><li>使用defer属性，将脚本执行推迟到文档解析完成后再执行  async也可以</li><li>动态加载模块 import和export 可以使用动态import方法来延迟加载<br><code>import(&quot;path/module.js&quot;).then(res =&gt; &#123;&#125;).catch(err =&gt; err)</code></li></ol><h3 id="同源和跨域"><a href="#同源和跨域" class="headerlink" title="同源和跨域"></a>同源和跨域</h3><h4 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h4><p>指：域名www、协议http、端口8080相同。</p><p>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收。即请求发送了，服务器响应了，但是无法被浏览器接收</p><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>若干标签可以允许跨域</p><ol><li>img</li><li>link href</li><li>script src</li></ol><h4 id="ajax跨域问题"><a href="#ajax跨域问题" class="headerlink" title="ajax跨域问题"></a>ajax跨域问题</h4><p>cors 跨域资源共享 服务端进行配置即可</p><p>jsonp </p><p>首先是利用script标签的src属性来实现跨域。<br>服务端返回一个定义好的js函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合。<br>缺点：</p><ol><li>只支持get，且需要后端配合</li><li>有可能有恶意代码</li><li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题</li></ol><p><code>var str = params.query.callback + &#39;(&#39; + JSON.stringify(data) + &#39;)&#39;;</code></p><h3 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h3><ol><li>箭头函数没有this，它只会从自己作用域链上一层继承this，call，apply，bind也不能改变this指向</li><li>箭头函数没有自己的arguments对象向，可以再箭头函数中使用rest参数替代arguments来访问箭头函数的参数列表 <code>(...args) =&gt; &#123;&#125;</code></li><li>箭头函数不能通过new关键字调用，没有原型，super，new.target值等</li></ol><h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><ol><li>let const 块级作用域</li><li>模板字符串 <code>$&#123;muban&#125;</code></li><li>展开运算符 <code>...arr</code></li><li>箭头函数  <code>() =&gt; &#123;&#125;</code></li><li>解构赋值 <code>let &#123;name&#125; = obj</code></li><li>类语法糖class</li><li>map set数据结构</li></ol><h3 id="call-apply-bind-函数的区别"><a href="#call-apply-bind-函数的区别" class="headerlink" title="call apply bind 函数的区别"></a>call apply bind 函数的区别</h3><p>call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，即修改函数体内this的指向</p><p>call和apply用法类似，call方法接受的是参数列表即多个参数以逗号分隔，而apply方法接受的是一个参数数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params">arg1,arg2</span>)</span> &#123;&#125;<br>func.apply(func1,[arg1,arg2]) <span class="hljs-comment">//参数数量不确定时，可以通过arguments把参数全部push进去</span><br>func.call(func1,arg1,arg2)<br></code></pre></td></tr></table></figure><p><strong>bind</strong>和call/apply最大的区别，一个函数被call和apply的时候会立即执行函数，但是bind会创建一个<strong>新函数</strong>，<strong>不会立即执行</strong></p><h3 id="new函数创建实例对象的步骤"><a href="#new函数创建实例对象的步骤" class="headerlink" title="new函数创建实例对象的步骤"></a>new函数创建实例对象的步骤</h3><ol><li><p>创建一个空对象obj</p></li><li><p>将obj的原型指向构造函数，这样obj就可以访问到构造函数的原型</p></li><li><p>执行构造函数，this指向obj，这样obj就可以访问到构造函数的属性</p></li><li><p>返回obj</p></li><li><p>创建一个新的对象</p></li><li><p>继承父类原型上的方法.</p></li><li><p>添加父类的属性到新的对象上并初始化. 保存方法的执行结果.</p></li><li><p>如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNew</span>(<span class="hljs-params">Fn, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> newObj = <span class="hljs-built_in">Object</span>.create(Fn);<br>  <span class="hljs-keyword">const</span> res = Fn.apply(newObj, args);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> ? res : newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>值类型的变量直接存储数据（<strong>栈</strong>上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据<strong>堆</strong>中。</p><p>引用类型：当<strong>声明</strong>一个类时，只在<strong>栈</strong>中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 <strong>new</strong> 创建一个类的实例时，分配<strong>堆</strong>上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</p><h3 id="typeof-能判断哪些类型"><a href="#typeof-能判断哪些类型" class="headerlink" title="typeof 能判断哪些类型"></a>typeof 能判断哪些类型</h3><p>所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)</p><ol><li>识别所有值类型</li><li>识别函数 返回 ‘function’</li><li>判断是否是引用类型</li></ol><p>注意： typeof null | [1,2]  =&gt; “object”</p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h3><p>== 只要求值相等即可 即经过类型转换为同一类型后值相等即可<br>=== 不仅值相等 类型也要相同</p><p>使用过程中，除了 == null 之外，其他一律用 ===<br>if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)</p><p>truly变量： !!a === true的变量<br>falsely变量  !!a === false的变量 ( 0 NaN “” null undefined false )</p><p>逻辑判断：<br>10 &amp;&amp; 0 前面是truly值，&amp;&amp;直接返回后面的值<br>“” || ‘abc’ 前面是falsely值， ||直接返回后面的值</p><h3 id="为啥-0-1-0-2-！-0-3"><a href="#为啥-0-1-0-2-！-0-3" class="headerlink" title="为啥 0.1+0.2 ！== 0.3"></a>为啥 0.1+0.2 ！== 0.3</h3><p>是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等<br>浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值</p><p>正确的比较方法 是使用js提供的最小精度值 Number.EPSILON<br><code>Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON</code></p><h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><p>原型：<br>每个class都有显式原型prototype<br>每个class实例化后的对象都有隐式原型__proto__<br>实例的隐式原型指向对应class的显式原型<br>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype</p><p>原型链：<br>首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。</p><h4 id="原型对象对实例的作用"><a href="#原型对象对实例的作用" class="headerlink" title="原型对象对实例的作用"></a>原型对象对实例的作用</h4><p>如果要给一个构造函数Foo创建出来的多个实例都添加一个方法，就可以在实例的原型上添加对应的方法，这样这个原型的所有实例便都有这个方法了</p><p>prototype是函数独有的属性 从一个函数指向一个对象 是该函数的原型对象<br>proto属性是所有对象都有的，它指向构造函数的原型对象</p><h3 id="如何判断一个变量是不是数组"><a href="#如何判断一个变量是不是数组" class="headerlink" title="如何判断一个变量是不是数组"></a>如何判断一个变量是不是数组</h3><ol><li>param instanceof Array (return true/false)</li><li>Array.isArray 更好 因为能检测iframes</li></ol><p>xialuo instanceof Student  (true)</p><h3 id="class的原型本质，怎么理解"><a href="#class的原型本质，怎么理解" class="headerlink" title="class的原型本质，怎么理解"></a>class的原型本质，怎么理解</h3><p>TODO:原型和原型链的图示</p><p>class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类<br>继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法</p><h3 id="js的几种继承方式"><a href="#js的几种继承方式" class="headerlink" title="js的几种继承方式"></a>js的几种继承方式</h3><p>TODO:重新整理</p><ul><li>原型链继承：</li></ul><p>优点：通过原型继承多个引用类型的属性和方法</p><p>缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。</p><ul><li>借用构造函数</li></ul><p>优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染</p><p>缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）</p><ul><li>组合继承</li></ul><p>优点： 集合了原型继承和盗用构造函数继承的优点</p><p>缺点：存在效率问题，Super始终会被调用两次</p><ul><li>原型式继承</li></ul><p>优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性</p><p>缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染</p><ul><li>寄生式继承</li></ul><p>优点：根据一个对象克隆创建另一个对象，并增强对象</p><p>缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍</p><ul><li>寄生式组合继承</li></ul><p>优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。</p><h3 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h3><ol><li>工厂模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>  a.name = name;<br>  a.age = age;<br>  <span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">let</span> p1 = createPerson(<span class="hljs-string">&quot;mike&quot;</span>,<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure></li><li>对象字面量 <code>let person = &#123; name: &#39;mike&#39; &#125;</code></li><li>构造函数 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;mike&quot;</span>,<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure></li><li>原型模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>Dog.prototype.name = <span class="hljs-string">&quot;dog1&quot;</span><br><span class="hljs-keyword">let</span> newDog = <span class="hljs-keyword">new</span> Dog()<br></code></pre></td></tr></table></figure></li><li>混合模式  即构造函数+原型</li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>作用域（scope） ：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是<strong>隔离变量</strong>，不同作用域下的同名变量不会有冲突。</p><ul><li>全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）</li><li>函数作用域 （函数内部定义的变量）</li><li>块级作用域 （let const声明的变量）</li></ul><p>作用域链</p><ul><li>自由变量 当前作用域中没有定义的变量，称为自由变量。</li><li>作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链</li><li>作用域与执行上下文的区别<ul><li>解释阶段（作用域规则确定）</li><li>执行阶段（执行上下文）</li></ul></li></ul><p>执行上下文在<strong>运行时</strong>确定（this的指向问题），随时可能改变，作用域（变量的值）在<strong>解释阶段（类似编译）</strong>就确定，并且不会改变。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等</p><h3 id="什么是块级作用域"><a href="#什么是块级作用域" class="headerlink" title="什么是块级作用域"></a>什么是块级作用域</h3><p>任何一对花括号({})中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。es6才有的</p><p>每个执行上下文都分为 变量环境 和 词法环境<br>var声明的变量在编译阶段都被存放到变量环境中，let声明的变量在编译阶段会被存放到词法环境中</p><p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>怎么回答： 怎么实现闭包 为啥要用闭包 那些地方会用到闭包</p><ol><li><p>有权访问其他函数作用域中变量的函数</p></li><li><p>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量</p></li></ol><p>所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方</p><h4 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h4><p>在一个函数内部创建另一个函数</p><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><p>可以读取函数内部的变量<br>可以阻止变量被回收</p><h4 id="为啥要用闭包"><a href="#为啥要用闭包" class="headerlink" title="为啥要用闭包"></a>为啥要用闭包</h4><p>利用闭包可以突破链作用域，将局部变量传到内部</p><h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><p>比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收</p><h4 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h4><ol><li><p>循环绑定监听事件,给标签循环添加监听事件<br>解决方式：1. 立即执行函数 2. es6声明 let const等（如下）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>节流防抖<br>在函数外部定义的timer,返回的是个函数，在函数内部修改timer的值实现定时效果</p></li><li><p>setTimeout 自执行方法</p></li><li><p>所有的回调函数</p></li></ol><h3 id="哪些操作可能引起内存泄漏"><a href="#哪些操作可能引起内存泄漏" class="headerlink" title="哪些操作可能引起内存泄漏"></a>哪些操作可能引起内存泄漏</h3><ol><li>不需要的全局变量  注册在window对象下的变量 var声明的变量</li><li>计时器和回调函数timers 定时器不被需要时，没有被clear</li><li>DOM泄漏  元素引用没有清理  var a = document.getElementById(‘id’)需要a=null来清理</li><li>js闭包</li><li>console.log</li></ol><h3 id="深浅拷贝的几种实现方式"><a href="#深浅拷贝的几种实现方式" class="headerlink" title="深浅拷贝的几种实现方式"></a>深浅拷贝的几种实现方式</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ol><li>Object.assign() let b = Object.assign({},a)</li><li>扩展运算符 let b = {…a}</li><li>Object.create()  let b = Object.create(a, Object.getOwnPropertyDescriptors(a))</li></ol><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ol><li>JSON.stringify 会忽略value为undefined symbol 和function的属性 还有bigInt值会报错</li><li>deepCopy 递归实现</li><li>lodasg.cloneDeep()</li><li>jquery中的extend()方法  let newObj = $.extend(true,{},obj1)</li></ol><h3 id="require-和-import"><a href="#require-和-import" class="headerlink" title="require 和 import"></a>require 和 import</h3><p>1.import在代码编译时被加载，所以必须放在文件开头，require在代码运行时被加载，所以require理论上可以运用在代码的任何地方，所以import性能更好。<br>2.import引入的对象被修改时，源对象也会被修改，相当于浅拷贝，require引入的对象被修改时，源对象不会被修改，官网称值拷贝，我们可以理解为深拷贝。<br>3.import有利于tree-shaking（移除JavaScript上下文中未引用的代码），require对tree-shaking不友好。<br>4.import会触发代码分割（把代码分离到不同的bundle中，然后可以按需加载或者并行加载这些文件），require不会触发。<br>5.import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法，require 是 AMD规范引入方式。</p><h3 id="promise理解"><a href="#promise理解" class="headerlink" title="promise理解"></a>promise理解</h3><p>promise是ES6中为了避免回调地狱的一种异步解决方案</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>状态不受外界影响</li><li>状态一旦改变就不会再变</li></ol><h4 id="实例对象方法"><a href="#实例对象方法" class="headerlink" title="实例对象方法"></a>实例对象方法</h4><ol><li>then</li><li>catch</li><li>finally</li><li>resolve() reject()</li><li>all() 所有resolved 才是resolved 其他都是rejected</li><li>race() 第一个完成状态变化的成功了最终就是resolved 失败就是rejected</li><li>any() 有一个成功就resolved，都失败就rejected</li><li>allSettled() then接收的参数是所有promise对象异步操作的执行结果 如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> &#125;,<br>  &#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <span class="hljs-attr">value</span>: -<span class="hljs-number">1</span> &#125;<br>]<br></code></pre></td></tr></table></figure></li></ol><h3 id="promise简易实现"><a href="#promise简易实现" class="headerlink" title="promise简易实现"></a>promise简易实现</h3><p>其中有点类似发布订阅模式 收集依赖 触发通知 取出依赖执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 存放成功的回调</span><br>    <span class="hljs-built_in">this</span>.onResolvedCallbacks = [];<br>    <span class="hljs-comment">// 存放失败的回调</span><br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks= [];<br><br>    <span class="hljs-keyword">let</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status ===  PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = FULFILLED;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-comment">// 依次将对应的函数执行</span><br>        <span class="hljs-built_in">this</span>.onResolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span>=&gt;</span>fn());<br>      &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">let</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status ===  PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = REJECTED;<br>        <span class="hljs-built_in">this</span>.reason = reason;<br>        <span class="hljs-comment">// 依次将对应的函数执行</span><br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span>=&gt;</span>fn());<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve,reject)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      reject(error)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === FULFILLED) &#123;<br>      onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === REJECTED) &#123;<br>      onRejected(<span class="hljs-built_in">this</span>.reason)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span><br>      <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>        onFulfilled(<span class="hljs-built_in">this</span>.value)<br>      &#125;);<br><br>      <span class="hljs-comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span><br>      <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(<span class="hljs-function">()=&gt;</span> &#123;<br>        onRejected(<span class="hljs-built_in">this</span>.reason);<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代方法-数组遍历方法"><a href="#迭代方法-数组遍历方法" class="headerlink" title="迭代方法 数组遍历方法"></a>迭代方法 数组遍历方法</h3><ol><li>every 有一个不满足返回false，都满足返回true  不会改变原数组</li><li>some   有一个元素满足要求返回true，否则false 不改变原数组</li><li>forEach  返回undefined                 不改变原数组</li><li>filter  返回新数组，元素为符合条件的所有元素  不改变原数组</li><li>map  返回新数组，元素为调用函数处理后的值    不改变原数组（性能比forEach低）</li><li>find  返回第一个满足的项或者undefined     不改变原数组</li><li>findIndex 返回第一个满足的项的下标或者-1     不改变原数组</li></ol><p>其他</p><ol><li>for</li><li>forin  对象 效率最低</li><li>forof  数组 支持break等，缺点没有index</li></ol><p>普通for循环才是最优雅的，优化后的for循环最快<br>数组方法无法中途停止循环，所以都不可以使用break和continue；<br>for循环之类的不可以return，但是能正常使用break和continue；</p><h4 id="其他数组方法"><a href="#其他数组方法" class="headerlink" title="其他数组方法"></a>其他数组方法</h4><p>join()<br>push()和pop()<br>shift() 和 unshift()<br>sort()<br>reverse()<br>concat()<br>slice()<br>splice()</p><h3 id="shift-和-unshift-和-push-和-pop的返回值"><a href="#shift-和-unshift-和-push-和-pop的返回值" class="headerlink" title="shift 和 unshift 和 push 和 pop的返回值"></a>shift 和 unshift 和 push 和 pop的返回值</h3><p>shift 和 pop 返回值 被删除的值<br>unshift 和 push 返回添加之后数组的长度</p><h3 id="map-和-set的区别"><a href="#map-和-set的区别" class="headerlink" title="map 和 set的区别"></a>map 和 set的区别</h3><p>map 字典 键值对 set get has size<br>set 值唯一的数组 add delete</p><h3 id="map和weakMap的区别"><a href="#map和weakMap的区别" class="headerlink" title="map和weakMap的区别"></a>map和weakMap的区别</h3><ol><li>键类型： Map对象的键可以使任何类型，包括基本数据类型和对象类型，WeakMap对象的键必须是对象类型</li><li>垃圾回收：Map对象中的键和值都会被常规垃圾回收机制回收，而weakMap中的键是弱引用，即在对象被垃圾回收时，weakmap中对应的键值对也会被自动删除，这使得weakmap通常用于缓存，当对象不被使用时，weakmap可以自动清除对应的数据</li><li>map对象内部有内置的迭代器，可以通过for of循环来遍历，而weakmap没有内置的迭代器，不能直接遍历</li></ol><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>任务：找到<strong>哪些被分配的内存确实已经不再需要了</strong></p><ol><li><p>引用计数垃圾收集<br>理解为 对象有没有其他对象引用它，如果没有就标记为<strong>零引用</strong>，对象将被垃圾回收机制回收<br>限制：循环引用的风险</p></li><li><p>标记-清除算法<br>理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收<br>限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）</p></li></ol><h3 id="this-的用法及含义"><a href="#this-的用法及含义" class="headerlink" title="this 的用法及含义"></a>this 的用法及含义</h3><p><strong>this取什么值是在函数被执行的时候确定的，不是在定义的时候。this总是指向函数的直接调用者</strong></p><p>this的指向问题</p><ol><li>作为普通函数 window</li><li>使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）</li><li>作为对象方法被调用 指代的就是这个对象本身</li><li>在class方法中调用 当前实例本身 setTimeout注意</li><li>箭头函数  <code>()=&gt;&#123;this&#125;</code> 和上级作用域的值一致</li></ol><h3 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h3><ol><li>cookie<ol><li>特点<ol><li>本身用于浏览器和server端的信息传递，以小文本文件形式保存登录凭证等</li><li>可用<code>document.cookie = &#39;xxx&#39;</code>来修改</li></ol></li><li>缺点<ol><li>存储大小限制为4KB</li><li>http请求需要发送到服务端，增加请求数量</li><li>只能用document.cookie修改，需要自己封装处理cookie的方法</li></ol></li></ol></li><li>localStorage 和 sessionStorage<ol><li>特点<ol><li>最大可存储 5MB</li><li>api 简单易用，setItem getItem</li><li>不会跟随 http 请求发送给服务端</li></ol></li><li>区别<ol><li>localStorage 会永久存储，除非手动删除</li><li>sessionStorage 数据只存在当前会话，浏览器关闭则清空</li><li>一般用 localStorage 较多</li></ol></li></ol></li></ol><h4 id="cookie的详细理解"><a href="#cookie的详细理解" class="headerlink" title="cookie的详细理解"></a>cookie的详细理解</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>可以用document.cookie查看，格式是由键值对构成的字符串以分号空格分割<br>注意只能获取非httponly下的<br>expires  过期时间<br>HttpOnly  设置能否用js访问，一旦携带这个属性，客户端无法通过js访问这个cookie<br>secure  只有在https情况下才能发送至服务器端</p><p>服务端可以设置cookie 的所有选项</p><h3 id="http-缓存（强制缓存-协商缓存）"><a href="#http-缓存（强制缓存-协商缓存）" class="headerlink" title="http 缓存（强制缓存 | 协商缓存）"></a>http 缓存（强制缓存 | 协商缓存）</h3><h4 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h4><p>网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p><h4 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h4><p>http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等</p><ol><li>Expires http1.0的规范，值是一个绝对时间的GMT格式，在此时间之前，本地缓存始终有效。有个缺点，服务端和客户端时间偏差较大时会出现缓存混乱的问题</li><li>Cache-Control 是http1.1的规范，一般用max-age表示<ol><li>max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒</li><li>s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；</li><li>public：指示响应可被任何缓存区缓存；</li><li>private：只能针对个人用户，而不能被代理服务器缓存；</li><li>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</li><li>no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</li></ol></li></ol><p>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>就是利用上面expires和cache-control中的max-age实现<br>过程：</p><ol><li>初次请求，服务器返回资源和cache-control/expires</li><li>再次请求，本地缓存直接返回资源</li></ol><h4 id="协商缓存（对比缓存）"><a href="#协商缓存（对比缓存）" class="headerlink" title="协商缓存（对比缓存）"></a>协商缓存（对比缓存）</h4><ul><li>服务端缓存策略。</li><li>服务端判断客户端资源，是否和服务端资源一样。</li><li>一致则返回 304，否则返回 200 和最新的资源。<br>过程：</li></ul><ol><li>初次请求，服务器端返回资源和资源标识</li><li>再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识</li></ol><p>资源标识：保存在Response Headers中</p><ol><li>Last-Modified： 资源的最后修改时间</li><li>Etag： 资源的唯一标识</li></ol><h5 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified  If-Modified-Since"></a>Last-modified  If-Modified-Since</h5><p>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag  If-None-Match"></a>Etag  If-None-Match</h5><p>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 <strong>If-None-match</strong>（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Etag的优先级比last-modified高</p><p>last-modified的不足：</p><ol><li>只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间</li><li>如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存</li></ol><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，<strong>不会影响阻塞</strong>后面的代码执行</p><ol><li>最开始实现异步都是采用<strong>回调函数</strong>实现的，但是有个缺点：回调地狱</li><li>为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）</li><li>ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解</li></ol><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>异步任务不进入主线程，而是进入<strong>任务队列</strong>，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。</p><ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前微任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ol><p>总结：</p><ol><li>tasks 按序执行，浏览器会在 tasks 之间执行渲染。</li><li>microtasks 按序执行，在下面情况时执行：<ol><li>在每个回调之后，只要没有其它代码正在运行。</li><li>在每个 task 的末尾</li></ol></li></ol><h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><p>异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)</p><p>宏任务 -（当前微任务） - 渲染 - 宏任务 。。。</p><p><strong>微任务比宏任务执行时间要早</strong></p><p>常见宏任务：</p><ol><li>setTimeout</li><li>setInterval</li><li>setImmediate(Node)</li><li>点击事件或键盘事件 i/o事件</li><li>Ajax</li><li>script整体代码段</li><li>promise里面的代码</li></ol><p>常见微任务</p><ol><li><strong>promise.then</strong>,<strong>await</strong>（与then类似）,promise.catch</li><li>object.observe</li><li>new MutationObserver(浏览器环境)</li><li>process.nextTick(node)</li></ol><p>注意：async函数在await之前的代码都是<strong>同步</strong>执行的，可以理解为await之前的代码属于new Promise传入的代码，<strong>await之后的代码都是在Promise.then中的回调</strong></p><h3 id="柯里化-1"><a href="#柯里化-1" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a+ b + c<br>&#125;<br><span class="hljs-comment">// 柯里化之后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> a + b + c<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 调用时</span><br>sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h4 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h4><p>我们处理函数时，希望函数功能尽可能单一</p><h4 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h4><p>(个人感觉不重要，理解什么是柯里化即可)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCurried</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args1.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-literal">null</span>, ...args1)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">null</span>, [...args1, ...args2])<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b + c + d + e<br>&#125;<br><span class="hljs-keyword">let</span> resFunc = myCurried(sum)<br><span class="hljs-built_in">console</span>.log(resFunc(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">23</span>))<br><span class="hljs-comment">//解析:</span><br><span class="hljs-comment">//1、这里的fn.length获取的是函数传入参数的长度</span><br><span class="hljs-comment">//2、这里使用递归的思想</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数的优缺点"><a href="#箭头函数的优缺点" class="headerlink" title="箭头函数的优缺点"></a>箭头函数的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>简写了函数</li><li><strong>改变this的指向为当前外部对象</strong></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>没有arguments参数</li><li>无法通过apply bind call来改变this的指向</li></ol><h4 id="不能用于哪些场景"><a href="#不能用于哪些场景" class="headerlink" title="不能用于哪些场景"></a>不能用于哪些场景</h4><ol><li>不能用于对象内方法</li><li>不能用于对象原型</li><li>不能用于构造函数</li><li>动态上下文中的函数，addEventListener的回调函数，其中的this指向有问题</li><li>vue生命周期和method方法不能写成箭头函数的形式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-attr">getA</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log( obj.getA() ) <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="AMD-和-CommonJS-的理解"><a href="#AMD-和-CommonJS-的理解" class="headerlink" title="AMD 和 CommonJS 的理解"></a>AMD 和 CommonJS 的理解</h3><p>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数<br>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的</p><h3 id="animation的用法"><a href="#animation的用法" class="headerlink" title="animation的用法"></a>animation的用法</h3><p>animation的各个属性<br><code>animation: name duration timing-function delay iteration-count direction fill-mode play-state</code></p><p>name 关键帧名称 loop<br>duration 动画完成时间多少秒 3s<br>timing-function 设置如何完成一个周期 linear<br>delay 启动前延迟间隔 0.3s<br>iteration-count 播放次数 infinite<br>direction 是否反向播放动画<br>fill-mode 动画不播放时，要应用的元素样式<br>play-state 是否正在运行或暂停</p><h3 id="如何使⽤-JavaScript-来判断⽤户设备类型，pc端还是移动端？"><a href="#如何使⽤-JavaScript-来判断⽤户设备类型，pc端还是移动端？" class="headerlink" title="如何使⽤ JavaScript 来判断⽤户设备类型，pc端还是移动端？"></a>如何使⽤ JavaScript 来判断⽤户设备类型，pc端还是移动端？</h3><ol><li>利⽤ navigator.userAgent 属性来获取⽤户代理信息<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMobile</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/Androd|webOS|iphone|iPad|iPad|BlackBerry|Mini/i</span>.test(navigator.userAgent)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>window.matchMedia(‘(max-midth:768px)’).matches;</li><li>第三方库 isMobile mobile-detect detect.js等</li></ol><h3 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h3><p>1：Cookie：<br>通过在用户浏览器中存储小型文本文件来跟踪会话状态信息。每次用户请求时，浏览器将Cookie数据包含在请求头中发送到服务器。<br>2：URL 重写：<br>将会话标识符添加到URL中作为查询参数的一部分。服务器通过解析URL中的会话标识符来跟踪会话状态。<br>3：隐藏表单字段（隐藏input）：<br>在HTML表单中添加一个隐藏字段，用于存储会话标识符。每次用户提交表单时，会话标识符将与请求一起发送到服务器。<br>4：会话存储（Session）：<br>在服务器端存储会话状态信息，并为每个会话分配一个唯一的标识符。服务器使用该标识符跟踪用户的会话状态。<br>5：HTML5 Web存储：<br>使用HTML5中的Web存储机制（如localStorage或sessionStorage）来存储会话状态信息。这些存储在客户端浏览器中，可以在整个会话期间保持不变</p><h2 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h2><h3 id="extend-用法"><a href="#extend-用法" class="headerlink" title="$.extend()用法"></a>$.extend()用法</h3><ol><li>浅拷贝  $.extend(a,b)  b拷贝a的内容</li><li>深拷贝  $.extend(true,a,b)</li><li>jQuery.fn.extend()  这边的jQuery.fn是jquery原型  是为jquery类添加 成员函数，相当于扩展jquery对象方法</li></ol><h3 id="jQuery队列是如何实现的，可以用在哪些地方"><a href="#jQuery队列是如何实现的，可以用在哪些地方" class="headerlink" title="jQuery队列是如何实现的，可以用在哪些地方"></a>jQuery队列是如何实现的，可以用在哪些地方</h3><p>主要是用queue() dequeue() clearQueue() 主要用于animate ajax等需要按时间顺序执行的事件中</p><h3 id="jquery中bind-live-delagate-on的区别"><a href="#jquery中bind-live-delagate-on的区别" class="headerlink" title="jquery中bind live delagate on的区别"></a>jquery中bind live delagate on的区别</h3><p>链接(<a href="https://www.cnblogs.com/gobiggirl/p/4498038.html">https://www.cnblogs.com/gobiggirl/p/4498038.html</a>)</p><h2 id="vue-相关"><a href="#vue-相关" class="headerlink" title="vue 相关"></a>vue 相关</h2><h3 id="vue3的生命周期"><a href="#vue3的生命周期" class="headerlink" title="vue3的生命周期"></a>vue3的生命周期</h3><p>onMounted onUpdated onUnmounted compositionAPI中使用方式 引入进来</p><p>beforeCreate created 这是options API中使用方式<br>beforeMount mounted<br>beforeUpdate updated<br>beforeUnmount unmounted  就这边变了</p><h3 id="为啥vue3没有this"><a href="#为啥vue3没有this" class="headerlink" title="为啥vue3没有this"></a>为啥vue3没有this</h3><p>我们在options api中对其中的一些属性进行绑定,但是在composition api中的setup函数的执行并没有绑定实例对象</p><h3 id="vue-和-react的区别-对比等"><a href="#vue-和-react的区别-对比等" class="headerlink" title="vue 和 react的区别 对比等"></a>vue 和 react的区别 对比等</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ol><li>都是数据驱动视图</li><li>都是组件化思想</li><li>都有虚拟dom</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定</li><li>vue相对语法简单，适用于小型项目，react更侧重于大型应用</li><li>vue渲染更快体积更小，react生态圈更大有更多工具</li></ol><h3 id="vue-的优势"><a href="#vue-的优势" class="headerlink" title="vue 的优势"></a>vue 的优势</h3><ol><li>轻量级框架</li><li>双向数据绑定（即响应式数据绑定）  – 最大优点</li><li>组件化开发</li><li>虚拟dom 节省了大量性能 比react快</li></ol><h3 id="vue修饰符"><a href="#vue修饰符" class="headerlink" title="vue修饰符"></a>vue修饰符</h3><p>事件修饰符</p><ul><li>stop 阻止事件继续传播</li><li>prevent 阻止标签默认行为</li><li>capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理</li><li>self 只当在 event.target 是当前元素自身时触发处理函数</li><li>once 事件将只会触发一次</li><li>passive 告诉浏览器你不想阻止事件的默认行为</li></ul><p>v-model 的修饰符</p><ul><li>lazy 通过这个修饰符，转变为在 change 事件再同步</li><li>number 自动将用户的输入值转化为数值类型</li><li>trim 自动过滤用户输入的首尾空格</li></ul><h3 id="vue的filter用法"><a href="#vue的filter用法" class="headerlink" title="vue的filter用法"></a>vue的filter用法</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><code>&#123;&#123; xxx | filter1 | filter2（'arg1',arg1） &#125;&#125; v-bind:attr=&#39;xxx | attr&#39;</code></p><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue文件中定义</span><br><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-attr">capitalize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 全局定义 main.js文件中定义</span><br>Vue.filter(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>局部过滤器</strong>优先于全局过滤器被调用<br>实际开发中，可以将所有方法写在一个单独的js文件中，然后再main.js中引入全局注册即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> _filters <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./../&quot;</span><br>object.keys(_filters).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  Vue.filter(item,_filters[item])<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="computed和watch区别"><a href="#computed和watch区别" class="headerlink" title="computed和watch区别"></a>computed和watch区别</h3><ol><li>computed 依赖于其他属性值 并且computed的值有<strong>缓存</strong></li><li>watch 监听某些数据的回调</li></ol><h3 id="mvvm-和-mvc-区别"><a href="#mvvm-和-mvc-区别" class="headerlink" title="mvvm 和 mvc 区别"></a>mvvm 和 mvc 区别</h3><ol><li>mvc和mvvm都是一种设计思想。 主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量DOM操作使页面渲染性能降低，加载速度变慢的问题 。</li><li>MVVM与MVC最大的区别就是：它<strong>实现了View和Model的自动同步</strong>：当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的显示，它会自动变化。 （数据变化页面直接跟着变化）</li><li>整体看来，MVVM比MVC精简很多，我们不用再用选择器频繁地操作DOM。</li></ol><h3 id="vue-双向绑定的原理"><a href="#vue-双向绑定的原理" class="headerlink" title="vue 双向绑定的原理"></a>vue 双向绑定的原理</h3><p>采用数据劫持和发布者-订阅者模式<br>数据劫持是通过 Object.defineProperty实现的，defineProperty可以控制对象属性的一些特有操作比如读写，是否可枚举等。其中最重要的就是get和set方法,可以通过defineProperty重写get和set方法来自定义对象属性的读取和设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(Book, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    name = value;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你取了一个书名叫做&#x27;</span> + value);<br>  &#125;,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;《&#x27;</span> + name + <span class="hljs-string">&#x27;》&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="具体的实现（了解）"><a href="#具体的实现（了解）" class="headerlink" title="具体的实现（了解）"></a>具体的实现（了解）</h4><ol><li>实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li><li>实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li><li>实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器</li></ol><p><a href="https://www.cnblogs.com/chenhuichao/p/10818396.html">参考</a></p><h3 id="vue2-和-vue3-双向绑定原理的区别-：proxy"><a href="#vue2-和-vue3-双向绑定原理的区别-：proxy" class="headerlink" title="vue2 和 vue3 双向绑定原理的区别 ：proxy"></a>vue2 和 vue3 双向绑定原理的区别 ：proxy</h3><p>vue2如上<br>vue3采用的是proxy来实现双向绑定的</p><h4 id="为啥vue3要改用proxy"><a href="#为啥vue3要改用proxy" class="headerlink" title="为啥vue3要改用proxy"></a>为啥vue3要改用proxy</h4><p>object.defineProperty的缺点</p><ol><li>因为只能监听对象的属性，所以需要深度遍历，监听需要一次性递归 (遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。</li><li>无法监听新增属性/删除属性(Vue.set Vue.delete，未在 data 中定义的属性会报 undefined)</li><li>无法原生监听数组，需要特殊处理（比如直接根据下标来修改值不能实时响应）</li></ol><p><code>let proxy = new Proxy(target,handler)</code><br>proxy支持13种拦截方式，相比老版更加丰富</p><p>可以理解为在对象之前设置一个<strong>对整个对象的拦截</strong>，当监听的对象被访问的时候，都必须经过这层拦截。可以在这拦截中对原对象处理，返回需要的数据格式。</p><p>Reflect是ES6为了操作对象而新增的API，个人理解为之前Object的优化，并完美支持proxy</p><h4 id="proxy的缺点"><a href="#proxy的缺点" class="headerlink" title="proxy的缺点"></a>proxy的缺点</h4><p>proxy 无法兼容所有浏览器，无法进行polyfill</p><h3 id="data-为啥是函数"><a href="#data-为啥是函数" class="headerlink" title="data 为啥是函数"></a>data 为啥是函数</h3><p>因为<strong>组件是可以复用</strong>的, JS里对象是<strong>引用</strong>关系, 如果组件data是一个对象, 那么在子组件中的data属性值会<strong>互相污染</strong>, 产生副作用。所以一个组件的data选项必须是一个函数, 这样才让每个实例可以维护一份被返回对象的独立拷贝。</p><h3 id="ref是什么"><a href="#ref是什么" class="headerlink" title="ref是什么"></a>ref是什么</h3><p>引用<br><code>this.$refs.refName</code><br>加在普通元素 可以获取到对应的dom元素<br>加在子组件上，用this.ref.name 获取到的是组件实例，可以使用组件的所有方法</p><h3 id="data-computed-watch-的依赖关系"><a href="#data-computed-watch-的依赖关系" class="headerlink" title="data computed watch 的依赖关系"></a>data computed watch 的依赖关系</h3><p>computed计算属性和watch都是以vue的依赖追踪机制为基础的，即依赖数据发生变化，所有一来这个数据的相关数据也自动发生变化<br>computed是一个值受多个属性影响<br>watch是监听一个属性的值发生变化时对其他多条数据的影响</p><h3 id="为啥-v-for-和-v-if-不建议一起用"><a href="#为啥-v-for-和-v-if-不建议一起用" class="headerlink" title="为啥 v-for 和 v-if 不建议一起用"></a>为啥 v-for 和 v-if 不建议一起用</h3><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度。</p><p>建议使用计算属性替代</p><h3 id="插槽（匿名，具名，作用域）及用法"><a href="#插槽（匿名，具名，作用域）及用法" class="headerlink" title="插槽（匿名，具名，作用域）及用法"></a>插槽（匿名，具名，作用域）及用法</h3><h4 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h4><p><code>&lt;slot /&gt;</code></p><h4 id="具名插槽-一一对应即可"><a href="#具名插槽-一一对应即可" class="headerlink" title="具名插槽  一一对应即可"></a>具名插槽  一一对应即可</h4><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 slot=&quot;header&quot;&gt;h1&lt;/h1&gt;<br>&lt;h1 slot=&quot;footer&quot;&gt;h1&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h4 id="作用域插槽-带数据的插槽-可用slot-scope获取数据"><a href="#作用域插槽-带数据的插槽-可用slot-scope获取数据" class="headerlink" title="作用域插槽 - 带数据的插槽 可用slot-scope获取数据"></a>作用域插槽 - 带数据的插槽 可用slot-scope获取数据</h4><ul><li>子组件中<br><code>&lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;</code> </li><li>父组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template slot-scope=&quot;user&quot;&gt;<br>  &lt;div class=&quot;tmpl&quot;&gt;<br>    &lt;span v-for=&quot;item in user.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h3><ol><li>beforeCreate 刚创建实例，没有数据和计算属性等 可以访问到 $el 和 $options</li><li>created 实例创建完，可以访问data和methods，$el上的属性还不存在</li><li>beforeMount 实例已挂载到dom上，但是dom还没更新</li><li>mounted 实例已挂在到dom，dom已更新，<code>$el</code>属性可见，用<code>this.$el</code>可以访问</li><li>beforeUpdate data已更新，dom未更新</li><li>updated dom和data都更新完毕</li><li>beforeDestory 实例销毁前，此时事件监听和watcher都已移除，但是dom还没移除</li><li>destoryed 实例销毁后，事件监听和watcher和dom都移除</li><li>activated  keep-alive激活时调用</li><li>deactivated  keep-alive停用时调用</li><li>errorCaptured 捕获子组件的错误 会向上冒泡 可以在此处进行错误处理</li></ol><p>beforeDestory注意点<br>自定义的全局事件要在退出该页面钱进行解绑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">mounted () &#123;<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.handleScroll)<br>&#125;,<br>beforeDestroy () &#123;<br>  <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.handleScroll)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><ol><li>父 -&gt; 子  props</li><li>子 -&gt; 父  events($emits)</li><li>$parent / $children 两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。</li><li>总线机制bus event bus  ($emit $on)<br>要创建一个公共bus.js 然后在其他组件中引入 作为中间传达的工具</li><li>vuex</li><li>$attrs  / $listeners  两个对象 $attrs是非props属性 $listeners是非原生事件 <code>v-bind=&quot;$attrs&quot;</code></li><li>祖 -&gt; 孙 provide / inject</li></ol><h3 id="vue-循环为啥要加-key"><a href="#vue-循环为啥要加-key" class="headerlink" title="vue 循环为啥要加 key"></a>vue 循环为啥要加 key</h3><p>类似唯一身份标志，主要用来做dom diff算法用的</p><p>diff算法是同级比较，比较当前标签上的key还有它当前的标签名，如果key和标签名都一样时只是做了一个移动的操作，不会重新创建元素和删除元素</p><p>默认使用 就地复用的策略，</p><h4 id="为啥不能用index做key"><a href="#为啥不能用index做key" class="headerlink" title="为啥不能用index做key"></a>为啥不能用index做key</h4><ol><li><p>性能问题：如果在数组前新增一个新元素，整个数组的key都发生了变化，就跟没有key是一个效果了  （在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM更新，从而导致效率低）</p></li><li><p>数据错位：新增input，新增的input还残留之前一个input绑定的数据 （如果结构中包含输入类的 DOM，会产生错误的 DOM 更新）</p></li></ol><h3 id="封装过的-vue-组件"><a href="#封装过的-vue-组件" class="headerlink" title="封装过的 vue 组件"></a>封装过的 vue 组件</h3><ol><li>城市选择组件 搜索 首字母跳转</li><li>全局封装注册图标组件 app.component</li><li>表格、表单等</li></ol><h3 id="vue-的-template-是怎么编译的"><a href="#vue-的-template-是怎么编译的" class="headerlink" title="vue 的 template 是怎么编译的"></a>vue 的 template 是怎么编译的</h3><p>TODO:</p><ol><li>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串</li><li>之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。</li><li>当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。</li><li>如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM</li></ol><h3 id="vue-router-的原理是什么"><a href="#vue-router-的原理是什么" class="headerlink" title="vue-router 的原理是什么"></a>vue-router 的原理是什么</h3><p>vue-router 的原理就是更新视图而不重新请求页面</p><p>Vue Router 的原理是通过拦截浏览器的默认行为，来实现页面跳转和组件切换的效果。当用户访问应用程序的某个链接时，Vue Router 会拦截这个请求，并根据路由规则，将对应的组件显示在视图中。这样，用户就可以在浏览器中操作应用程序，而无需刷新整个页面。</p><p>hash 模式和 history 模式都是通过 window.addEventListener() 方法监听 hashchange 和 popState 进行相应路由的操作。可以通过 back、foward、go 等方法访问浏览器的历史记录栈 进行各种跳转。</p><p>总的来说，Vue Router 的作用是解决 SPA 应用程序中路由和组件之间的关系，实现页面跳转和组件切换的效果。</p><h3 id="vue-的两种路由模式-hash-和-history"><a href="#vue-的两种路由模式-hash-和-history" class="headerlink" title="vue 的两种路由模式 hash 和 history"></a>vue 的两种路由模式 hash 和 history</h3><h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><ol><li>hash模式是url后面带有#的情况，#后面的值不会包含在http请求，所有改变hash的值不会引起页面的重新加载，不会像服务器重新发起请求</li><li>不利于seo优化</li><li>只能修改#后面的部分，因此只能跳转与当前url同文档的url</li></ol><p>hash原理： <strong>onhashchange</strong>事件，页面每次hash值得变化都会触发hashchange事件</p><p>会创建hashHistory对象，会被浏览器记录下来，在访问不同的路由会发生两种事件：hashHistory.push()：将新的路由添加到浏览器访问的历史栈顶，<br>hashHistory.replace()替换到当前栈</p><h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><ol><li>url不带#参数，看起来更美观</li><li>history模式依赖于前后端交互，即url修改就会请求后端url，如果后端没配置对应的/user/id的路由处理，就会返回404报错</li><li>history模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中，可以传递复杂的数据</li><li>可以访问当前url同源的任意url</li><li>history原理：使用<strong>window.onpopstate</strong>监听浏览器地址，对浏览器 history api 中的 pushState()，replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。从而实现 URL 的跳转而无需加载页面，但是它的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来完成，避免 url 无法匹配到资源时能返回页面。</li></ol><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h3><p>$route 是”路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 (信息)<br>$router 是”路由实例(VueRouter)”对象，相当于一个全局的路由器对象,包括了路由的跳转方法，钩子函数等。如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)  (实例)</p><h3 id="动态路由怎么获取传递的动态参数"><a href="#动态路由怎么获取传递的动态参数" class="headerlink" title="动态路由怎么获取传递的动态参数"></a>动态路由怎么获取传递的动态参数</h3><p>场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染<br>动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配<br>到一个路由时，参数会被设置到 this.$route.params 中，并且可以在每个组件<br>中使用。<br><code>&#123; path: &#39;/user/:id&#39;, component: User &#125;</code><br>在匹配到该路由之后，动态参数会被设置到this.$route.params</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;<br></code></pre></td></tr></table></figure><p>也可以是多个参数<br><code>/user/:username/post/:post_id</code> 与路由一一对应</p><h4 id="params和query的区别是什么"><a href="#params和query的区别是什么" class="headerlink" title="params和query的区别是什么"></a>params和query的区别是什么</h4><ol><li>query 要用 path 来引入，params 需要用 name 来引入</li><li>接收参数时，分别是<code>this.$route.query.name</code>  和 <code>this.$route.params.name</code> (注意：是<code>$route</code>而不是<code>$router</code>)</li><li>query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址中显示，params 不显示</li><li>params 传值一刷新就没了，query 传值刷新还存在（因为是保存在地址栏中的）</li></ol><h3 id="路由传值的实现方式"><a href="#路由传值的实现方式" class="headerlink" title="路由传值的实现方式"></a>路由传值的实现方式</h3><p>共2种 params - name 和 query - path</p><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">data:&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>  ...<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.username &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这边的name是给path取的别名，name最重要的一点就是配合params进行路由的参数传递</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Login<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home<br>  &#125;<br>]<br><br><span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.username &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vue-router-的钩子函数-路由守卫"><a href="#vue-router-的钩子函数-路由守卫" class="headerlink" title="vue-router 的钩子函数 路由守卫"></a>vue-router 的钩子函数 路由守卫</h3><p>TODO:背</p><ol><li>全局钩子<ol><li>beforeEach  <code>router.beforeEach(to,from,next)</code></li><li>afterEach</li><li>beforeResolve</li></ol></li><li>路由独享钩子<ol><li>beforeEnter  写在路由配置中，访问到这个路径会触发这个钩子函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/foo&#x27;</span>,<br>    <span class="hljs-attr">componenet</span>: Foo,<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;&#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure></li></ol></li><li>组件内钩子<ol><li>beforeRouterEnter 写在组件中，即将渲染组件的时候触发 不能访问this</li><li>beforeRouterUpdate</li><li>beforeRouterLeave<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 写在vue组件中</span><br> <span class="hljs-function"><span class="hljs-title">beforeRouterLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="vue-的-nextTick"><a href="#vue-的-nextTick" class="headerlink" title="vue 的 nextTick"></a>vue 的 nextTick</h3><p>nextTick: 将回调推迟到下一个 DOM 更新周期之后执行<br>该钩子函数执行时所有的DOM挂载和渲染都已完成</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中</li><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</li></ol><h3 id="mixin-的用法"><a href="#mixin-的用法" class="headerlink" title="mixin 的用法"></a>mixin 的用法</h3><p>mixin 是用来分发 vue 组件中的可复用功能，可包含任意组件选项</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li>在被其他组件引入后，mixin中的方法和属性也就并入到该组件中</li><li>数据对象在内部会进行递归合并，并在发生冲突时以<strong>组件数据优先</strong></li><li>同名钩子函数会被合并为一个数组，都被调用，<strong>mixin的钩子先执行</strong></li><li>也可以全局注入，不过会影响后面的所有vue实例，不建议</li></ol><p>实战举例： e-charts的resize.js</p><h3 id="虚拟-dom-的理解及其优点"><a href="#虚拟-dom-的理解及其优点" class="headerlink" title="虚拟 dom 的理解及其优点"></a>虚拟 dom 的理解及其优点</h3><p>虚拟DOM本质上是<strong>JavaScript对象</strong>,是对真实DOM的抽象 状态变更时，用对象记录新树和旧树的差异<br>最后把差异更新到真正的dom中</p><p>虚拟 DOM 主要的作用是<strong>优化 DOM 的渲染性能</strong>。在传统的网页开发中，当页面状态改变时，需要重新生成整个 DOM 树，这个过程非常耗时。而虚拟 DOM 把这个过程分为两个步骤：首先生成一颗虚拟 DOM 树，然后用虚拟 DOM 树和上一次生成的虚拟 DOM 树进行比较，找到差异，最后只对这些差异部分进行 DOM 操作。这个过程被称为“DOM Diff 算法”。</p><p>虚拟 DOM 本身是一个 JavaScript 对象，它包含了页面的结构信息和状态信息。通过使用虚拟 DOM，可以避免直接操作真实 DOM 树，从而提高渲染性能和用户体验。同时，虚拟 DOM 也提供了更好的抽象层，使得开发者可以更加方便地管理和维护页面状态。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>保证性能下限 大幅度减少了dom的操作，减少了重绘和回流的次数，提高了性能</li><li>无需手动操作DOM virtualDOM的diff和patch都是在一次更新中自动进行的，无需手动操作</li><li>跨平台 本质是js对象，dom是与平台强相关的，js对象可以更方便的跨平台操作</li></ol><h3 id="图片懒加载的实现"><a href="#图片懒加载的实现" class="headerlink" title="图片懒加载的实现"></a>图片懒加载的实现</h3><p>可以利用html5的属性data-xxx来保存图片的路径，当我们需要加载图片的时候才将data-xxx的值赋予src,就能实现图片的按需加载</p><p>vue-lazyload</p><h3 id="vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决"><a href="#vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决" class="headerlink" title="vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决"></a>vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决</h3><ol><li>索引设置元素   <code>this.array[index] = newValue</code><ol><li>解决方式 <code>this.$set(this.array,index,newValue)</code> 或者 <code>this.array.splice(index,1,newValue)</code></li></ol></li><li>直接修改数组长度 <code>this.array.length = newLength</code><ol><li>解决方式   <code>this.array.splice(newLength)</code></li></ol></li></ol><h3 id="vue-底层是怎么实现对数组的监听的"><a href="#vue-底层是怎么实现对数组的监听的" class="headerlink" title="vue 底层是怎么实现对数组的监听的"></a>vue 底层是怎么实现对数组的监听的</h3><p>在将数组处理成响应式数据后，如果使用数组原始方法改变数组时，数组值会发生变化，但是并不会触发数组的setter来通知所有依赖该数组的地方进行更新，为此，vue通过<strong>重写数组的某些方法</strong>来监听数组变化，重写后的方法中会手动触发通知该数组的所有依赖进行更新。</p><p>重写的数组方法：<br>push pop shift unshift splice sort reverse</p><h3 id="vue如何监听js报错"><a href="#vue如何监听js报错" class="headerlink" title="vue如何监听js报错"></a>vue如何监听js报错</h3><ol><li>errorCaptured生命周期</li><li>window.onerror</li><li>errorHandler 全局错误处理 <code>app.config.errorHandler = function() &#123;&#125;</code></li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>状态管理模式</p><h4 id="包含哪几种属性"><a href="#包含哪几种属性" class="headerlink" title="包含哪几种属性"></a>包含哪几种属性</h4><ul><li>state  类似于vue的data mapState映射全局的state的getters到当前组件的computed中 <code>...mapState([&#39;count&#39;])</code></li><li>getters 是store的计算属性 可在多组件之间复用 <code>$store.getters.getter名</code></li><li>mutation 修改数据 类似methods <code>this.$store.commit(&#39;mutation名&#39;)</code></li><li>action 异步修改数据 <code>this.$store.dispatch(&#39;actions的名字&#39;, 参数)</code></li><li>module 模块拆分</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第二种访问方式</span><br><span class="hljs-attr">methods</span>: &#123;<br>  ...mapActions([<span class="hljs-string">&#x27;actionsName&#x27;</span>]),<br>  ...mapMutations([<span class="hljs-string">&#x27;mutationName&#x27;</span>])<br>&#125;<br><span class="hljs-attr">computed</span>: &#123;<br>  ...mapGetters([<span class="hljs-string">&#x27;xxx&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vuex-和-本地存储的区别"><a href="#vuex-和-本地存储的区别" class="headerlink" title="vuex 和 本地存储的区别"></a>vuex 和 本地存储的区别</h3><ol><li>vuex存的是状态，存在<strong>内存</strong>中，localStorage是以文件的形式存储到<strong>本地</strong></li><li>vuex用于组件之间的传值，localStorage则主要用于页面之间的传值</li><li>vuex可以做到数据的<strong>响应</strong>式，localStorage不行。即当两个组件共同用以数据源，如果其中一个组件中的数据源改变，希望另一个组件响应变化，这时候就要选择用vuex。</li><li><strong>当刷新页面时，vuex存储的值会丢失，localStorage不会</strong></li></ol><h3 id="vue-踩过的坑"><a href="#vue-踩过的坑" class="headerlink" title="vue 踩过的坑"></a>vue 踩过的坑</h3><ol><li>给data中的对象直接添加属性并赋值 无效果 删除属性要用vue.delete<br>解决方法：Vue.$set(object, attribute, value)新增的属性也是响应式的</li><li>在created中操作dom报错，无法获取到dom<br>解决方法：Vue.nextTick()</li><li>内存泄漏 全局变量 自定义事件定时器等未销毁 </li><li>路由切换时页面scroll到顶部 <ol><li>从商品列表页进入到详情页后再返回列表页就会scroll到顶部<br>解决办法：<br>在列表页缓存数据和scrollTop值 当再次返回列表页时，渲染组件执行scrollTo方法<br>mpa+app的new webview 两个页面 </li></ol></li></ol><h3 id="如何统一监听vue组件报错"><a href="#如何统一监听vue组件报错" class="headerlink" title="如何统一监听vue组件报错"></a>如何统一监听vue组件报错</h3><ol><li>window.onerror 能全局监听所有js错误 但不能识别vue组件信息 window.addEventListener(‘error’)</li><li>errorCaptured 在app.vue文件中写 可以监听所有子组件的报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">errorCapturedL (err,vm,info) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;eeror&#x27;</span>,rr,vm,info);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">//可以阻止向上传播到window.error等</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>errorHandler main.js中配置 不会向上传播<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = createApp(App)<br>app.config.errorHandler = <span class="hljs-function">(<span class="hljs-params">error,vm,info</span>) =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>异步错误 errorHandler捕获不到<br>可以用 全局onerror监听 也可以用unhandledrejection监听</li></ol><h3 id="vue页面的渲染过程"><a href="#vue页面的渲染过程" class="headerlink" title="vue页面的渲染过程"></a>vue页面的渲染过程</h3><ol><li>调用 compile 函数,生成 render 函数字符串 ,编译过程如下:<ol><li>parse 函数解析 template,生成 ast(抽象语法树) </li><li>optimizer 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)</li><li>generate 函数生成 render 函数字符串</li></ol></li><li>调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象</li><li>调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</li></ol><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><ol><li><p>常见分类<br>1xx - 服务器收到请求。<br>2xx - 请求成功，如 200。<br>3xx - 重定向，如 302。<br>4xx - 客户端错误，如 404。<br>5xx - 服务端错误，如 500。</p></li><li><p>常见状态码<br>200 - 成功。<br>301 - 永久重定向（配合 location，浏览器自动处理）。<br>302 - 临时重定向（配合 location，浏览器自动处理）。<br>304 - 资源未被修改。<br>403 - 没权限。<br>404 - 资源未找到。<br>500 - 服务器错误。<br>504 - 网关超时</p></li></ol><h3 id="https比http的优势"><a href="#https比http的优势" class="headerlink" title="https比http的优势"></a>https比http的优势</h3><p>安全性</p><ol><li>https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</li><li>使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器<br>seo<br>https在搜索结果中的排名会比http更高</li></ol><h3 id="http工作原理"><a href="#http工作原理" class="headerlink" title="http工作原理"></a>http工作原理</h3><p>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端发送所有请求。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>支持客户/服务器模式（请求应答模式）</li><li>应用广泛且跨平台</li><li>简单快速且灵活</li><li>是可靠的传输协议</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>无状态</li><li>无连接</li><li>明文传输 调试遍历但信息易被窃取</li><li>不安全 https引入ssl/tls解决这个问题</li></ol><h3 id="网络分层7层模型"><a href="#网络分层7层模型" class="headerlink" title="网络分层7层模型"></a>网络分层7层模型</h3><p>应用层： 应用层、表示层、会话层（http ftp smtp dns）<br>传输层 （tcp和udp）<br>网络层 （ip）<br>物理和数据链路层 （以太网）</p><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>网络连接是TCP。传输内容是HTTP</p><p>第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；<strong>我要传输</strong><br>第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；<strong>服务端收到</strong><br>第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。<strong>客户端收到</strong><br>其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段</p><p>第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态； <strong>我要断开</strong><br>第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态； <strong>好的收到，还有一个包</strong><br>第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态； <strong>我数据发送完了，随时关闭</strong><br>第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手  <strong>好的拜拜，你关闭吧，不用恢复</strong><br>A客户端等待2msl 无回复则关闭</p><p>理解：</p><p>三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。</p><p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。</p><h3 id="HTTPS-的握手过程"><a href="#HTTPS-的握手过程" class="headerlink" title="HTTPS 的握手过程"></a>HTTPS 的握手过程</h3><p><a href="https://blog.csdn.net/u012219045/article/details/100537007">https://blog.csdn.net/u012219045/article/details/100537007</a></p><ol><li>客户端发起HTTPS请求</li><li>服务端的配置</li><li>传送证书</li><li>客户端解析证书</li><li>传送加密信息</li><li>服务段解密信息</li><li>传输加密后的信息</li><li>客户端解密信息</li></ol><h3 id="Get-和-Post"><a href="#Get-和-Post" class="headerlink" title="Get 和 Post"></a>Get 和 Post</h3><ol><li>GET是默认的HTTP请求方法 参数以key-value形式存放在url中，get更不安全，post是通过request body携带请求参数</li><li>get提交数据大小有限制，因为浏览器URL的长度有限制，post没有</li><li>get可以被缓存，post不能</li><li>get只允许ascii码，post没有限制</li></ol><h3 id="从-url-被输入到请求返回发生了什么"><a href="#从-url-被输入到请求返回发生了什么" class="headerlink" title="从 url 被输入到请求返回发生了什么"></a>从 url 被输入到请求返回发生了什么</h3><ol><li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。<ol><li>强缓存</li><li>协商缓存</li></ol></li><li>DNS 域名解析  域名转化为对应的ip</li><li>TCP 连接<blockquote><p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</p></blockquote></li><li>HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器渲染页面（important）<ol><li>先将HTML加载到浏览器的内部。</li><li>从上往下开始解析HTML。</li><li>当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。</li><li>浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。</li><li>HTML解析完毕之后，等待CSS解析。</li><li>CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）</li><li>在渲染树(Render Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上</li></ol></li><li>断开 TCP 连接</li></ol><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>上面</p><h3 id="前端缓存的几种缓存方式"><a href="#前端缓存的几种缓存方式" class="headerlink" title="前端缓存的几种缓存方式"></a>前端缓存的几种缓存方式</h3><p>HTTP缓存和浏览器缓存<br>http缓存包括 强缓存和协商缓存 如上面<br>浏览器缓存分为本地存储 即cookie localStorage和sessionStorage 如上 </p><h3 id="ajax、axios、fetch的区别"><a href="#ajax、axios、fetch的区别" class="headerlink" title="ajax、axios、fetch的区别"></a>ajax、axios、fetch的区别</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。</p><h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的<br>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p><h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p>Axios 是一种基于Promise封装的HTTP客户端</p><h3 id="web安全及防护"><a href="#web安全及防护" class="headerlink" title="web安全及防护"></a>web安全及防护</h3><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>举例：<br>在输入框中输入SQL inject后面输入框填入’ or 1=1 –<br>这样，前半句被单引号结束，后半句1=1恒成立，–将后续判断注释掉，导致不需要输入密码也能登录</p><p>通过SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p><p>防范措施：</p><ol><li>密码要加密存储</li><li>使用框架及模板提交前检查代码输入内容</li><li>所有输入的内容都要进行过滤</li></ol><h4 id="xss攻击-跨站脚本攻击"><a href="#xss攻击-跨站脚本攻击" class="headerlink" title="xss攻击 跨站脚本攻击"></a>xss攻击 跨站脚本攻击</h4><p>盗取用户的信息，如 cookie </p><p><strong>反射型xss</strong> 攻击者构造了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。 举例：在url后面插入’,alert(‘hha’)，可以拿到cookie，在用更复杂的payload将cookie传给自己的服务器<br><strong>基于dom的xss</strong> 攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。<br><strong>存储型xss</strong> 恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。举例：添加标签时插入onerror=alert(document.cookie)</p><p>防范措施：</p><ol><li>输入过滤，前端进行过滤之后后端在写入或访问数据库之前也要进行过滤</li><li>在使用innerHtml和outerHtml和document.write等要特别小心，不可信的数据不能插到页面上 v-html也不推荐使用，js的eval()、setTimeout()、setInterval()等会将字符串转成代码运行也不推荐使用</li><li>启用CSP（Content Security Policy） 内容安全策略</li><li>还可以对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。</li></ol><h4 id="csrf-跨站请求伪造"><a href="#csrf-跨站请求伪造" class="headerlink" title="csrf 跨站请求伪造"></a>csrf 跨站请求伪造</h4><p>引诱受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br>原理：利用cookie的自动携带特性，在其他的网站想你的网站发送请求，如果你的网站中没有退出登录，那么这次操作请求会被执行，比如银行转账途中点击其他网站。</p><p>特点：是冒充受害者提交操作<br>防范措施：</p><ol><li>同源检测 origin header</li><li>csrf token请求时携带token</li></ol><h2 id="webpack-相关"><a href="#webpack-相关" class="headerlink" title="webpack 相关"></a>webpack 相关</h2><h3 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h3><ol><li>Entry 入口，Webpack执行构建的第一步将从Entry开始，可抽象成输入</li><li>Output 出口，告诉Webpack在哪里输出它打包好的代码以及如何命名，</li><li>Module 模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块</li><li>Chunk 代码块，一个Chunk由多个模块组合而成，用于代码合并与分割</li><li>Loader 模块转换器，用于把模块原内容按照需求转换成新内容</li><li>Plugin 扩展插件，在Webpack构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li></ol><h3 id="webpack的基本功能"><a href="#webpack的基本功能" class="headerlink" title="webpack的基本功能"></a>webpack的基本功能</h3><ol><li>代码转化 ts编译成js，scss编译成css</li><li>文件优化 压缩js css html代码</li><li>代码分割 提取多页面的公共代码，提取首屏不需要执行部分的代码让其异步加载</li><li>模块合并 在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新 自动构建，刷新浏览器</li><li>代码校验 在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li><li>自动发布 更新完代码后，自动构建出线上发布代码并传输给发布系统</li></ol><h3 id="Webpack如何配置多入口文件"><a href="#Webpack如何配置多入口文件" class="headerlink" title="Webpack如何配置多入口文件"></a>Webpack如何配置多入口文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">entry: &#123;<br>  <span class="hljs-attr">home</span>: resolve(__dirname, <span class="hljs-string">&quot;src/home/index.js&quot;</span>),<br>  <span class="hljs-attr">about</span>: resolve(__dirname, <span class="hljs-string">&quot;src/about/index.js&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><p>loader是<strong>文件加载器</strong>，能够加载资源文件，并对文件进行一些处理，如编译，压缩 等，最终一起打包到指定的文件中，loader运行在<strong>项目打包</strong>之前</p><p>plugin赋予了webpack各种灵活的<strong>功能</strong>，如打包优化，资源管理，环境变量，注入等，目的是为了解决loader无法实现的功能，plugins运行在整个项目的<strong>编译</strong>时期</p><h3 id="常见-loader"><a href="#常见-loader" class="headerlink" title="常见 loader"></a>常见 loader</h3><ol><li>css-loader读取合并CSS文件</li><li>style-loader把CSS内容注入到JavaScript里</li><li>sass-loader解析sass文件（安装sass-loader，node-sass）</li><li>postcss-loader自动添加浏览器兼容前缀（postcss.config配置）</li><li>url-loader将文件转换为base64 URI。</li><li>vue-loader处理vue文件</li></ol><h3 id="常见-plugins"><a href="#常见-plugins" class="headerlink" title="常见 plugins"></a>常见 plugins</h3><ol><li>HtmlWebpackPlugin自动在打包结束后生成html文件，并引入bundle.js</li><li>cleanwebPackPlugin打包自动删除上次打包文件</li><li>webpack-dev-server，开启开发服务器，监视文件变动</li><li>uglifyjs-webpack-plugin（js代码压缩混淆）</li><li>webpack-parallel-uglify-plugin 多进程执行代码压缩，提升构建速度。</li></ol><h3 id="webpack-打包的流程"><a href="#webpack-打包的流程" class="headerlink" title="webpack 打包的流程"></a>webpack 打包的流程</h3><ol><li><strong>初始化参数</strong>  webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数</li><li><strong>编译准备</strong> 这一步我们会通过调用webpack()方法返回一个compiler对象，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译</li><li><strong>模块编译</strong> 从入口模块进行分析，调用匹配文件的loaders对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作</li><li><strong>完成编译</strong> 在递归完成后，每个引用模块通过loaders处理完成同时得到模块之间的相互依赖关系</li><li><strong>输出文件</strong> 整理模块依赖关系，同时将处理后的文件输出到ouput的磁盘目录中。</li></ol><h3 id="webpack中的dev-server是怎么跑起来的"><a href="#webpack中的dev-server是怎么跑起来的" class="headerlink" title="webpack中的dev-server是怎么跑起来的"></a>webpack中的dev-server是怎么跑起来的</h3><p>dev-server 是一个小型的 Node.js Express 服务器。</p><p>它使用了 <strong>webpack-dev-middleware</strong> 中间件来实现快速打包编译并通过 HTTP 服务提供打包后的文件。</p><p>dev-server 的运行流程如下：</p><ol><li>打包所有文件生成 JavaScript，并将它们存储在内存中;</li><li>启动一个 HTTP 服务器，为应用程序提供服务;</li><li>监听源代码文件的变化，当文件发生变化时重新编译它们;</li><li>将编译后的文件重新加载到浏览器中，以实现实时重新加载和热模块替换。</li></ol><h3 id="实现webpack持久化缓存"><a href="#实现webpack持久化缓存" class="headerlink" title="实现webpack持久化缓存"></a>实现webpack持久化缓存</h3><p>hash 文件名是实现持久化缓存的第一步，目前 webpack 有两种计算 hash 的方式([hash] 和 [chunkhash])</p><ul><li>hash 代表每次 webpack 在编译的过程中会生成唯一的 hash 值，在项目中任何一个文件改动后就会被重新创建，然后 webpack 计算新的 hash 值。</li><li>chunkhash 是根据模块计算出来的 hash 值，所以某个文件的改动只会影响它本身的 hash 值，不会影响其他文件。<br>如果你的项目涉及到拆包，分模块进行加载等等，那么你需要用 chunkhash，来保证每次更新之后只有相关的文件 hash 值发生改变。<br>一份具有持久化缓存的 webpack 配置应该长这样<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br> <span class="hljs-attr">entry</span>: __dirname + <span class="hljs-string">&#x27;/src/index.js&#x27;</span>,<br> <span class="hljs-attr">output</span>: &#123;<br> <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>,<br> <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[chunkhash:8].js&#x27;</span>,<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>第二种方法：<br>使用 hard-source-webpack-plugin 插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HardSourceWebpackPlugin = <span class="hljs-built_in">require</span>(&amp;#<span class="hljs-number">39</span>;hard-source-webpack-plugin&amp;#<span class="hljs-number">39</span>;);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> HardSourceWebpackPlugin()<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="webpack中的source-map是什么？生产环境怎么用？"><a href="#webpack中的source-map是什么？生产环境怎么用？" class="headerlink" title="webpack中的source map是什么？生产环境怎么用？"></a>webpack中的source map是什么？生产环境怎么用？</h3><p>首先前端项目在投入生产之前，都会对JavaScript源代码进行压缩混淆，从而减小文件的体积，提高文件的加载效率，也因此对压缩混淆之后的代码除错（debug） 是一件极其困难的事情</p><ol><li>变量被替换成没有任何语义的名称</li><li>空行和注释被剔除</li></ol><p>Source Map就是一个信息文件，里面储存着位置信息。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的转换前的位置。<br>出错的时候，除错工具将直接显示原始代码，而不是转换后的代码</p><h4 id="生产环境下"><a href="#生产环境下" class="headerlink" title="生产环境下"></a>生产环境下</h4><p>如果 省略了 devtool 选项 ，则最终生成的文件中 不包含 Source Map 。这能够 防止原始代码 通过 Source Map 的形式 暴露 给别有所图之人。</p><p>在生产环境下，如果 只想定位报错的具体行数 ，且 不想暴露源码 。此时可以将 devtool 的值设置为<br><strong>nosources-source-map</strong>。</p><h2 id="typescript-和-vue3-相关"><a href="#typescript-和-vue3-相关" class="headerlink" title="typescript 和 vue3 相关"></a>typescript 和 vue3 相关</h2><h3 id="ts比js的优势"><a href="#ts比js的优势" class="headerlink" title="ts比js的优势"></a>ts比js的优势</h3><p>ts是js的超集，在js的基础上添加了<strong>类型系统</strong>，用于强大的<strong>静态类型检查</strong>能力，并且继承了js的所有编程类型，js代码在ts环境也可以很好的运行</p><h3 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h3><ol><li>双向数据绑定的原理发生了改变 defineProperty和proxy</li><li>最大区别： composition api组合式api 与 vue2的options api相比更简便和整洁</li><li>生命周期钩子变了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue2--------------vue3<br>beforeCreate  -&gt; setup()<br>created       -&gt; setup()<br>beforeMount   -&gt; onBeforeMount<br>mounted       -&gt; onMounted<br>beforeUpdate  -&gt; onBeforeUpdate<br>updated       -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed     -&gt; onUnmounted<br>activated     -&gt; onActivated<br>deactivated   -&gt; onDeactivated<br></code></pre></td></tr></table></figure></li></ol><h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><h3 id="echarts-js图表宽度自适应的问题"><a href="#echarts-js图表宽度自适应的问题" class="headerlink" title="echarts.js图表宽度自适应的问题"></a>echarts.js图表宽度自适应的问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单个图表</span><br><span class="hljs-built_in">window</span>.onresize = myChart.resize;   <br><br><span class="hljs-comment">//多个图标可以这样写：</span><br><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.myChart.resize()<br>    <span class="hljs-built_in">this</span>.myChart1.resize()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="echarts标签文字过多导致显示不全解决方案"><a href="#echarts标签文字过多导致显示不全解决方案" class="headerlink" title="echarts标签文字过多导致显示不全解决方案"></a>echarts标签文字过多导致显示不全解决方案</h3><h4 id="echarts-x轴标签文字过多导致显示不全"><a href="#echarts-x轴标签文字过多导致显示不全" class="headerlink" title="echarts x轴标签文字过多导致显示不全"></a>echarts x轴标签文字过多导致显示不全</h4><p>解决办法1：xAxis.axisLabel 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">axisLabel: &#123;  <br>  <span class="hljs-attr">interval</span>:<span class="hljs-number">0</span>,  <br>  <span class="hljs-attr">rotate</span>:<span class="hljs-number">40</span>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>解决办法2：调用formatter文字竖直显示 axisLabel的Formartter方法</p><h2 id="uniapp-相关"><a href="#uniapp-相关" class="headerlink" title="uniapp 相关"></a>uniapp 相关</h2><h3 id="谈谈你对uniapp的理解"><a href="#谈谈你对uniapp的理解" class="headerlink" title="谈谈你对uniapp的理解"></a>谈谈你对uniapp的理解</h3><p>uni-app是一个使用vue.js开发所有前端应用的框架，开发编写一套代码，可以发布到多个平台<br>优点：</p><ol><li>跨平台</li><li>运行体验良好</li><li>开放生态，组件丰富</li><li>通用技术栈<br>缺点：</li><li>动画使用不方便，css动画多了会卡顿</li><li>兼容性问题较多</li></ol><h3 id="uni中如何为不同的平台设置不同的代码"><a href="#uni中如何为不同的平台设置不同的代码" class="headerlink" title="uni中如何为不同的平台设置不同的代码"></a>uni中如何为不同的平台设置不同的代码</h3><ol><li>条件注释<br>以 #ifdef 或 #ifndef 加 %PLATFORM% 开头，以 #endif 结尾<br><code>#ifdef APP-PLUS  ...$content...  #endif</code></li></ol><h3 id="uniapp中封装接口请求相较于微信小程序有什么要注意的"><a href="#uniapp中封装接口请求相较于微信小程序有什么要注意的" class="headerlink" title="uniapp中封装接口请求相较于微信小程序有什么要注意的"></a>uniapp中封装接口请求相较于微信小程序有什么要注意的</h3><p>如果uniapp要在web端进行适配,要注意请求跨域问题—需要配置代理;可以通过在 vue.config.js 中配置Proxy代理解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">devServer: &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/xxx-api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="uni-app中的本地存储数据和接收数据是什么"><a href="#uni-app中的本地存储数据和接收数据是什么" class="headerlink" title="uni-app中的本地存储数据和接收数据是什么"></a>uni-app中的本地存储数据和接收数据是什么</h3><p>存储： uni.setStorageSync(‘name’,‘LZJAPYX,ZDL’);<br>获取： uni.getStorageSync(‘name’) // 以健名取键值<br>删除： uni.removeStorageSync(‘name’) // 删除该键名的数据<br>异步存储：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存</span><br>uni.setStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;你好，word&quot;</span>      <span class="hljs-comment">// 键值</span><br>&#125;);<br><span class="hljs-comment">// 取</span><br>uni.getStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log.(res.data)    <span class="hljs-comment">// 你好，word</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 删</span><br>uni.reomveStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log.(res)    <span class="hljs-comment">// ok</span><br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="uni-app-路由与页面跳转"><a href="#uni-app-路由与页面跳转" class="headerlink" title="uni-app 路由与页面跳转"></a>uni-app 路由与页面跳转</h3><ol><li>uni.navigateTo({url: “/路径?参数=参数值”});    保留当前页面，只能跳转非tabBar页面</li><li>uni.switchTab({url: “/路径?参数=参数值”});    关闭所有非tabbar页面，只能打开tabbar页面</li><li>uni.redirectTo({url: “/路径?参数=参数值”});    关闭卸载当前页面，只能打开非tabBar页面</li><li>uni.reLaunch({url: “/路径?参数=参数值”});    关闭卸载所有页面，可以打开任意页面</li><li>uni.navigateBack({delta: 2});    返回上一页面 delta：返回页数</li><li>标签&lt; navigator &gt;    open-type属性决定跳转方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;navigator url=<span class="hljs-string">&quot;../message/message?id=99&quot;</span>&gt;界面跳转传参&lt;/navigator&gt;<br><br><span class="hljs-comment">//获取路由参数，在界面的onLoad方法中获取</span><br><span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params">options</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(options)<br>&#125;,<br></code></pre></td></tr></table></figure></li></ol><h3 id="uni-app全局变量怎么定义，怎么获取"><a href="#uni-app全局变量怎么定义，怎么获取" class="headerlink" title="uni-app全局变量怎么定义，怎么获取"></a>uni-app全局变量怎么定义，怎么获取</h3><p>在app.js中设置globalData设置，在需要的地方的js文件let app=getApp() app.globalData.数据</p><h3 id="uni中生命周期"><a href="#uni中生命周期" class="headerlink" title="uni中生命周期"></a>uni中生命周期</h3><ul><li>app页面<ul><li>onLaunch    当uni-app 初始化完成时触发（全局只触发一次）</li><li>onShow    当 uni-app 启动，或从后台进入前台显示</li><li>onHide    当 uni-app 从前台进入后台</li><li>onError    当 uni-app 报错时触发</li><li>onUniNViewMessage    对 nvue 页面发送的数据进行监听</li><li>onUnhandledRejection    对未处理的 Promise 拒绝事件监听函数</li><li>onPageNotFound    页面不存在监听函数</li><li>onThemeChange    监听系统主题变化</li></ul></li><li>pages页面 <a href="https://blog.csdn.net/ytfty24124/article/details/128087256">参考</a><ul><li>onInit</li><li>onLoad</li><li>onShow</li><li>onReady</li><li>onHide</li><li>onUnload</li><li>onResize</li><li>onPullDownRefresh</li><li>onReachBottom</li><li>onTabItemTop</li></ul></li><li>vue生命周期</li></ul><h3 id="提高微信小程序速度的方法"><a href="#提高微信小程序速度的方法" class="headerlink" title="提高微信小程序速度的方法"></a>提高微信小程序速度的方法</h3><ol><li>控制代码包的大小：<ol><li>代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项</li><li>及时清理无用的代码和资源文件</li><li>减少资源包中的图片等资源的数量和大小</li></ol></li><li>分包加载,预加载：<ol><li>将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包</li></ol></li><li>预请求：<ol><li>请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地</li></ol></li><li>避免不当的使用setData：<ol><li>不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用</li></ol></li><li>使用自定义组件：<ol><li>对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用</li></ol></li></ol><h2 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h2><h3 id="前端性能优化的措施-整理"><a href="#前端性能优化的措施-整理" class="headerlink" title="前端性能优化的措施 整理"></a>前端性能优化的措施 整理</h3><p>前端面试题 第34题 可以参考</p><ul><li>html css js<ul><li><strong>雪碧图 base64等减少请求数量</strong></li><li><strong>图片懒加载</strong></li><li>使用webp格式的图片 <strong>压缩html，css，js和图片</strong></li><li>注意资源加载位置，加载时机，可添加异步script标签</li><li>不使用css @import 会导致css无法并行下载，有个依赖顺序，会加长css解析延迟的时间</li><li>能用css实现的效果就不要用js实现</li><li>少用css表达式，计算评率太高</li></ul></li><li>dom相关<ul><li>给元素设置高度或者最小高度，以防页面晃动</li><li>图片设置尺寸，不然从无到有会有回流</li><li><strong>需要多次重绘的元素开启GPU加速</strong>  transform opacity filter<ul><li>transform: translate3d(xx,xx,xx);</li><li>transform: translateZ(0); left这些每次都会触发repaint会有卡顿现象</li></ul></li><li>批量操作dom，减少dom操作次数，拼接完字符串再更新dom</li><li><strong>事件代理</strong></li><li><strong>防抖和节流</strong></li></ul></li><li>网络相关<ul><li>使用<strong>缓存</strong></li><li><strong>开启gzip压缩</strong></li><li>使用cdn</li></ul></li><li>打包相关<ul><li>打包公共代码 CommonsChunkPlugin插件</li><li>动态导入和<strong>按需加载</strong></li><li>删除无用代码 treeShaking uglifyjs和purifyCSS</li></ul></li></ul><h3 id="h5页面首屏优化"><a href="#h5页面首屏优化" class="headerlink" title="h5页面首屏优化"></a>h5页面首屏优化</h3><ol><li>路由懒加载<ol><li>适用于spa </li><li>路由拆分</li></ol></li><li>ssr服务器端渲染<ol><li>如果是纯h5页面，ssr是性能优化的最佳方案 nuxtjs nextjs</li></ol></li><li>app预取 app h5 jsbridge</li><li>分页<ol><li>针对列表页</li><li>默认只展示第一页内容</li><li>上划加载更多</li></ol></li><li>图片懒加载<ol><li>针对详情页</li><li>默认只展示文本内容，然后触发图片懒加载</li><li>注意提前设置图片尺寸，尽量只重绘不重排</li></ol></li></ol><p>注意要 结合优化结果分析，比如优化完之后首屏渲染速度提升了0.5s</p><h3 id="vue-首屏加载优化方案"><a href="#vue-首屏加载优化方案" class="headerlink" title="vue 首屏加载优化方案"></a>vue 首屏加载优化方案</h3><ol><li>使用cdn加载第三方库</li><li>图片资源压缩（精灵图）和使用图片懒加载（虚拟列表可以讲讲）</li><li>vue-router路由懒加载</li><li>gzip压缩 webpack中使用compression-webpack-plugin插件</li><li>移除 编译文件中的map文件 <code>productionSourceMap: false</code></li><li>代码层面优化 <ol><li>合理使用v-if和v-show</li><li>记得及时销毁定时器 更多的参考上方前端性能优化</li></ol></li></ol><h3 id="实际工作中做过哪些vue优化"><a href="#实际工作中做过哪些vue优化" class="headerlink" title="实际工作中做过哪些vue优化"></a>实际工作中做过哪些vue优化</h3><ol><li>v-if（彻底销毁）和v-show（css隐藏组件）</li><li>v-for使用key</li><li>computed缓存</li><li>keep-alive组件 如tabs</li><li>把异步组件拆包出来 需要时异步加载 不需要的时候不加载 加快首页的加载 defineAsyncComponent</li><li>路由懒加载 component <code>()=&gt; import(&#39;xxx&#39;)</code></li><li>ssr</li></ol><h3 id="前端seo优化有哪些"><a href="#前端seo优化有哪些" class="headerlink" title="前端seo优化有哪些"></a>前端seo优化有哪些</h3><ol><li>title description keywords权重逐渐减小，均要合理</li><li>多用语义化标签</li><li>重要html代码放前面</li><li>少用iframe</li><li>重要图片要加alt</li><li>提高网站速度</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="vue组件封装原则"><a href="#vue组件封装原则" class="headerlink" title="vue组件封装原则"></a>vue组件封装原则</h3><ol><li>单一原则</li><li>多重职责</li><li>明确接受参数</li><li>可拓展</li></ol><h3 id="怎么从0到1构建一个vue项目"><a href="#怎么从0到1构建一个vue项目" class="headerlink" title="怎么从0到1构建一个vue项目"></a>怎么从0到1构建一个vue项目</h3><p>从0创建一个项目我大致会做以下事情：项目构建、引入必要插件、代码规范、提交规范、常用库和组件</p><ol><li>目前vue3项目我会用vite或者create-vue创建项目</li><li>接下来引入必要插件：路由插件vue-router、状态管理vuex/pinia、ui库我比较喜欢</li><li>element-plus和antd-vue、http工具我会选axios</li><li>其他比较常用的库有vueuse，nprogress，图标可以使用vite-svg-loader</li><li>下面是代码规范：结合prettier和eslint即可</li><li>最后是提交规范，可以使用husky，lint-staged，commitlint</li></ol><h3 id="前端工程化的理解"><a href="#前端工程化的理解" class="headerlink" title="前端工程化的理解"></a>前端工程化的理解</h3><ol><li>将系统化的，规范化的方法用于前端应用的开发，运行和维护的过程</li><li>用工程化方法构建和维护有效的，使用的高质量的前端应用</li></ol><p>包含：开发 构建 部署 性能</p><p>，把 前端工程化 等同于 <strong>效率工程</strong>，认为一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化，我觉得这么理解也是没有问题的，提升开发效率、提升产品质量、降低开发难度、降低企业成本应该是工程化的意义所在。</p><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>框架选型<br>前后端分离<br>模块化<br>组件化<br>脚手架<br>组件库<br>本地开发服务器<br>Mock服务<br>微前端</p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>依赖打包<br>文件压缩<br>代码分割<br>增量更新和缓存<br>资源定位<br>图标合并<br>Babel<br>CSS预编译<br>持续构建和集成<br>构建优化</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>持续部署<br>部署流程设计<br>静态资源部署策略<br>Nginx反向代理<br>SPA路由配置<br>跨域<br>https证书和http2<br>灰度发布</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>缓存策略<br>缓存复用<br>CDN内容分发网络<br>按需加载<br>同步异步加载<br>请求合并<br>首屏渲染速度<br>HTTP2服务器推送<br>日志性能监控<br>预加载<br>性能测试</p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>模块化</li><li>组件化</li><li>规范化</li><li>自动化</li></ul><h3 id="单元测试相关"><a href="#单元测试相关" class="headerlink" title="单元测试相关"></a>单元测试相关</h3><p>当前单元测试主要工具有Mocha和Jest<br>Mocha+Chai<br>Jest的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./sum&#x27;</span>);<br><br>describe(<span class="hljs-string">&#x27;sum function test&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&#x27;sum(1, 2) === 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    expect(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  <span class="hljs-comment">// 这里 test 和 it 没有明显区别，it 是指: it should xxx, test 是指 test xxx</span><br>  test(<span class="hljs-string">&#x27;sum(1, 2) === 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    expect(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>配置test在package.json中<br><code>scripts: &#123;&quot;test&quot;: &quot;jest&quot;&#125;</code> npm run test即可</p><p>必须要用require的方式引用被测试方法，因为import是es6的模块化关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; fetchUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../src/fetchUser&#x27;</span>;<br><br>test(<span class="hljs-string">&#x27;fetchUser() 可以请求到一个用户名字为 moji&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data =  <span class="hljs-keyword">await</span> fetchUser();<br><br>  expect(data.name).toBe(<span class="hljs-string">&#x27;moji&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 测试异步函数需要添加插件@babel/plugin-transform-runtime，因为默认babel/preset-env不支持async await</span><br></code></pre></td></tr></table></figure><h3 id="svg的优势"><a href="#svg的优势" class="headerlink" title="svg的优势"></a>svg的优势</h3><p>svg是可伸缩矢量图形</p><ol><li>svg图像可以被任意的文本编辑器创建和编辑</li><li>svg图像可以被搜索、索引化和脚本化，可压缩性更强</li><li>svg图像是可伸缩的</li><li>svg可在任何分辨率下被高质量打印 </li></ol><h3 id="后端如果一次性返回10万条数据，怎么渲染"><a href="#后端如果一次性返回10万条数据，怎么渲染" class="headerlink" title="后端如果一次性返回10万条数据，怎么渲染"></a>后端如果一次性返回10万条数据，怎么渲染</h3><ol><li>首先 这个设计不合理</li><li>自定义nodejs中间层 获取并拆分这10w条数据 成本过高</li><li>虚拟列表<ol><li>只渲染可视区域DOM 其他都用空div撑起高度 借用第三方lib vue-virtual-scroll-list 不建议用，实现复杂且效果不一定好</li></ol></li></ol><h3 id="前端常用的设计模式有哪些，并说明使用场景"><a href="#前端常用的设计模式有哪些，并说明使用场景" class="headerlink" title="前端常用的设计模式有哪些，并说明使用场景"></a>前端常用的设计模式有哪些，并说明使用场景</h3><ul><li>开放封闭原则<ol><li>对扩展开放</li><li>对修改封闭</li></ol></li></ul><ol><li>工厂模式<br>jQuery这种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo()<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单例模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>  private <span class="hljs-keyword">static</span> instance: SingleTon | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br>  private <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>  public <span class="hljs-keyword">static</span> getInstance(): singleTon &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.instance === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> SingleTon()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> s = SingleTon.getInstance()<br></code></pre></td></tr></table></figure></li><li>代理模式 ES6 proxy</li><li>观察者模式 addEventListener监听事件</li><li>发布订阅模式 event.on event.emit()</li><li>装饰器模式 原功能不变，增加一些新功能  Decorator</li></ol><h3 id="观察者模式和发布订阅模式的区别"><a href="#观察者模式和发布订阅模式的区别" class="headerlink" title="观察者模式和发布订阅模式的区别"></a>观察者模式和发布订阅模式的区别</h3><p>subject和observer直接绑定没有中间媒介 ：addEventListern<br>Publisher和observer互不认识，需要中间媒介event channel ：EventBus<br>发布订阅模式相比观察者模式多了一个调度中心<br>发布订阅模式是在观察者模式的基础上做的优化升级。观察者模式是发布订阅模式的一种特殊实现<br>观察者和被观察者，是松耦合的关系<br>发布者和订阅者，则完全解耦</p><h3 id="如果一个h5很慢，你该如何排查性能问题"><a href="#如果一个h5很慢，你该如何排查性能问题" class="headerlink" title="如果一个h5很慢，你该如何排查性能问题"></a>如果一个h5很慢，你该如何排查性能问题</h3><ul><li>前端性能指标 <ul><li>first paint (fp)</li><li>first contentful paint (fp)</li><li>domContentload(dcl)</li><li>load(l)</li></ul></li></ul><p>用chrome的devtools的 performance 可以看到上述各指标的时间<br>性能分析工具 lighthouse</p><h3 id="遇到最困难的问题是啥-怎么解决"><a href="#遇到最困难的问题是啥-怎么解决" class="headerlink" title="遇到最困难的问题是啥 怎么解决"></a>遇到最困难的问题是啥 怎么解决</h3><p>动态换肤 scss变量</p><ol><li>对于 element-plus：因为 element-plus 是第三方的包，所以它 不是完全可控 的，那么对于这种最简单直白的方案，就是直接拿到它编译后的 css 进行色值替换，利用 style 内部样式表 优先级高于 外部样式表 的特性，来进行主题替换<ol><li>获取当前elementplus的所有样式</li><li>定义我们要替换之后的样式</li><li>在原样式中，利用正则替换新样式</li><li>把替换后的样式写入到新style标签中</li></ol></li><li>对于自定义主题：因为自定义主题是 完全可控 的，所以我们实现起来就轻松很多，只需要修改对应的 scss变量即可</li></ol><p>jsx实现无限层级</p><ul><li>树形结构</li><li>表格行可拖拽</li></ul><h3 id="前端兼容性问题"><a href="#前端兼容性问题" class="headerlink" title="前端兼容性问题"></a>前端兼容性问题</h3><p>回答方式 先描述2-3个兼容问题，最后一个总结</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>ie6不支持min-height {min-height: 200px; _height: 350px;}</li><li>IE6/7不支持display:inline-block  {display: inline-block; *display: inline;}</li><li>IE9以下opacity不支持   Firefox/Chrome/Safari/Opera浏览器使用opacity；IE浏览器使用filter</li><li>图片加a标签在IE9中会有边框   img{border: none;}</li></ul><ol><li>根据兼容需求选择技术框架/库(如 jquery 1.x.x )</li><li>根据兼容需求选择兼容工具： html5shiv 、 Respond.js 、 CSS Reset 、 normalize.css 、 Modernizr.js 、 postcss</li><li>条件注释、 CSS Hack 、 js 能力检测做一些修补。Hack ： CSS 中， Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法Filter<br>：表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲， Filter 是 hack 方法中的一种。</li><li>渐进增强和优雅降级（1）渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（2）优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ol><h4 id="css-hack"><a href="#css-hack" class="headerlink" title="css hack"></a>css hack</h4><p><code>*background-color:green</code> 在前面加*的只会对IE6，7生效，其他版本ie和现代浏览器会忽略这条指令<br><code>-background-color:green</code>在前面加-的只会对IE6生效，其他版本ie和现代浏览器会忽略这条指令<br>后面添加“!important”的写法只有IE6不能识别，其它版本IE及现代浏览器都可以识别<br>区别IE 6.7.8</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.bb</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-selector-class">.background-color</span>: <span class="hljs-number">#fff</span>; //ie6.<span class="hljs-number">7.8</span>识别<br>  +<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>; //ie6.<span class="hljs-number">7</span>识别<br>  _background-<span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>; //ie6识别<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动端适配的问题"><a href="#移动端适配的问题" class="headerlink" title="移动端适配的问题"></a>移动端适配的问题</h3><h4 id="2个概念："><a href="#2个概念：" class="headerlink" title="2个概念："></a>2个概念：</h4><p>自适应：根据不同的设备屏幕大小来自动调整尺寸，大小。<br>响应式：会随着屏幕的实时变动而自动调整，是一种自适应。</p><h4 id="4个方案"><a href="#4个方案" class="headerlink" title="4个方案"></a>4个方案</h4><ol><li>百分比</li><li>rem+动态html的font-size  媒体查询设置不同html的根font-size<ol><li>如果动态改变尺寸，不会实时的进行更新（没有实现响应式 lib-flexible） 可以用js动态获取屏幕宽度</li></ol></li><li>vw单位  <ol><li>postcss-px-to-viewport</li><li>配置一下postcss.config.js即可 如下</li></ol></li><li>flex</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// postcss.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&#x27;postcss-px-to-viewport&#x27;</span>: &#123;<br>      <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中最推荐的就是vw方案<br><a href="https://blog.csdn.net/weixin_57677300/article/details/129164050?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129164050%22,%22source%22:%22weixin_57677300%22%7D">参考</a></p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p><a href="https://blog.csdn.net/Teemo_shape/article/details/105579955">https://blog.csdn.net/Teemo_shape/article/details/105579955</a></p><p><a href="https://juejin.cn/post/7031322059414175774">参考 1</a></p><p><a href="https://juejin.cn/post/7061588533214969892">参考 2</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后台管理系统登录功能的实现</title>
    <link href="/2022/12/14/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/12/14/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="登录功能的设计与实现"><a href="#登录功能的设计与实现" class="headerlink" title="登录功能的设计与实现"></a>登录功能的设计与实现</h2><h3 id="登录操作的实现"><a href="#登录操作的实现" class="headerlink" title="登录操作的实现"></a>登录操作的实现</h3><ol><li>封装 axios 模块</li><li>封装 接口请求 模块</li><li>封装登录请求动作</li><li>保存服务端返回的 token</li><li>登录鉴权</li></ol><h3 id="封装-axios-模块"><a href="#封装-axios-模块" class="headerlink" title="封装 axios 模块"></a>封装 axios 模块</h3><h4 id="配置环境变量封装-axios-模块"><a href="#配置环境变量封装-axios-模块" class="headerlink" title="配置环境变量封装 axios 模块"></a>配置环境变量封装 axios 模块</h4><p>axios模块至少需要具备一种能力：根据当前模式的不同，设定不同的 BaseUrl，因为企业级项目在开发状态和生产状态 baseUrl是不同的。<br>可以使用 @vue/cli 所提供的<strong>环境变量</strong>来去进行实现.</p><p>我们可以再项目根目录创建两个文件</p><ol><li><p>.env.development</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"># 标志<br>ENV = <span class="hljs-string">&#x27;development&#x27;</span><br><br># base api<br>VUE_APP_BASE_API = <span class="hljs-string">&#x27;/api&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>.env.production</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"># 标志<br>ENV = <span class="hljs-string">&#x27;production&#x27;</span><br><br># base api<br>VUE_APP_BASE_API = <span class="hljs-string">&#x27;/prod-api&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><p>接着在utils文件夹下添加request.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>  <span class="hljs-attr">baseURL</span>: process.env.VUE_APP_BASE_API,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></td></tr></table></figure><h3 id="封装请求动作"><a href="#封装请求动作" class="headerlink" title="封装请求动作"></a>封装请求动作</h3><ol><li>封装接口请求模块</li><li>封装登录请求动作</li></ol><h4 id="封装接口请求模块"><a href="#封装接口请求模块" class="headerlink" title="封装接口请求模块"></a>封装接口请求模块</h4><p>创建/api/sys.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/request&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> login = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> request(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/sys/login&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    data<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="封装登录请求动作"><a href="#封装登录请求动作" class="headerlink" title="封装登录请求动作"></a>封装登录请求动作</h4><p>该动作我们期望把它封装到 vuex 的 action 中<a href="https://www.cnblogs.com/sweetpitaya/p/16871664.html">为什么</a><br>在 store 下创建 modules 文件夹，创建 user.js 模块，用于处理所有和 <strong>用户相关</strong> 的内容<br>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; login &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/sys&#x27;</span><br><span class="hljs-keyword">import</span> md5 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;md5&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//namespaced为true的作用是告诉vuex，该模块所有的state 、getters、mutations、actions里面的东西调用时都需要加上命名空间，这个命名空间就是该模块被import时命名的名字,调用时：this.$store.state.map.zoom（map是命名空间）;</span><br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;),<br>  <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params">context, userInfo</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; username, password &#125; = userInfo<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        login(&#123;<br>          username,<br>          <span class="hljs-attr">password</span>: md5(password)<br>        &#125;)<br>          .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>            resolve(data)<br>          &#125;)<br>          .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            reject(err)<br>          &#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.mulingyuer.com/archives/360/">namespaced命名空间</a></p><p>调用时：(此处user/就是命名空间)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">store.dispatch(<span class="hljs-string">&#x27;user/login&#x27;</span>, loginForm.value)<br>     .then(<span class="hljs-function">() =&gt;</span> &#123;<br>        loading.value = <span class="hljs-literal">false</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 登录后操作</span><br>      &#125;)<br></code></pre></td></tr></table></figure><p>此时，请求发送会报错，因为请求会被自动键入到当前前端所在的服务中，即此时请求路径为当前前端地址加上<code>/api/sys/login</code>,因此我们在此处需要使用<a href="https://webpack.docschina.org/configuration/dev-server/">webpack DevServer</a>代理将当前的url代理到具体的后台服务地址</p><p>在vue.config.js中，加入以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 配置反向代理</span><br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-comment">// 当地址中有/api的时候会触发代理机制</span><br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-comment">// 要代理的服务器地址  这里不用写 api</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://api.xxx.com/&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否跨域</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>重启服务即可获得数据</p><h4 id="本地缓存处理方案"><a href="#本地缓存处理方案" class="headerlink" title="本地缓存处理方案"></a>本地缓存处理方案</h4><p>通常情况下，在获取到 token 之后，我们会把 token 进行缓存，而缓存的方式将会分为两种</p><ol><li>localStorage （保存在 LocalStorage 是为了方便实现 自动登录功能）</li><li>vuex （保存在 vuex 中是为了后面在其他位置进行使用）</li></ol><h5 id="封装localstorage方法"><a href="#封装localstorage方法" class="headerlink" title="封装localstorage方法"></a>封装localstorage方法</h5><p>创建utils/storage.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存储数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setItem = <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 将数组、对象类型的数据转化为 JSON 字符串进行存储</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    value = <span class="hljs-built_in">JSON</span>.stringify(value)<br>  &#125;<br>  <span class="hljs-built_in">window</span>.localStorage.setItem(key, value)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getItem = <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">window</span>.localStorage.getItem(key)<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(data)<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> data<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> removeItem = <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">window</span>.localStorage.removeItem(key)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除所有数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> removeAllItem = <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">window</span>.localStorage.clear()<br>&#125;<br></code></pre></td></tr></table></figure><p>在user模块中，处理token保存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存</span><br><span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">token</span>: getItem(TOKEN) || <span class="hljs-string">&#x27;&#x27;</span><br>&#125;),<br><span class="hljs-attr">mutations</span>: &#123;<br>  <span class="hljs-function"><span class="hljs-title">setToken</span>(<span class="hljs-params">state, token</span>)</span> &#123;<br>    state.token = token<br>    setItem(TOKEN, token)<br>  &#125;<br>&#125;,<br><span class="hljs-comment">// 取</span><br><span class="hljs-built_in">this</span>.commit(<span class="hljs-string">&#x27;user/setToken&#x27;</span>, data.data.data.token)<br></code></pre></td></tr></table></figure><h4 id="登录后操作"><a href="#登录后操作" class="headerlink" title="登录后操作"></a>登录后操作</h4><p><strong>登录鉴权</strong></p><blockquote><p>当用户未登陆时，不允许进入除 login 之外的其他页面。<br>用户登录后，token 未过期之前，不允许进入 login 页面</p></blockquote><p>在main.js平级 创建permission文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-comment">// 白名单</span><br><span class="hljs-keyword">const</span> whiteList = [<span class="hljs-string">&#x27;/login&#x27;</span>]<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 路由前置守卫</span><br><span class="hljs-comment"> */</span><br>router.beforeEach(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-comment">// 存在 token ，进入主页</span><br>  <span class="hljs-comment">// if (store.state.user.token) &#123;</span><br>  <span class="hljs-comment">// 快捷访问</span><br>  <span class="hljs-keyword">if</span> (store.getters.token) &#123;<br>    <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>      next(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next()<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没有token的情况下，可以进入白名单</span><br>    <span class="hljs-keyword">if</span> (whiteList.indexOf(to.path) &gt; -<span class="hljs-number">1</span>) &#123;<br>      next()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>以上即是后台管理系统-登录功能的思路及实现</p>]]></content>
    
    
    
    <tags>
      
      <tag>登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后台管理系统中统一管理svg的实现</title>
    <link href="/2022/12/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86svg%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/12/13/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86svg%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在我们项目中经常遇到需要展示自定义svg图标的情况，因此我们需要开发一个自定义组件处理<strong>自定义svg图标的形式</strong>。<br>首先，这个组件需要有以下两种能力</p><ol><li>显示外部svg图标</li><li>显示项目内的svg图标<h3 id="组件代码"><a href="#组件代码" class="headerlink" title="组件代码"></a>组件代码</h3><code>SvgIcon.vue</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div<br>    v-if=&quot;isExternal&quot;<br>    :style=&quot;styleExternalIcon&quot;<br>    class=&quot;svg-external-icon svg-icon&quot;<br>    :class=&quot;className&quot;<br>  /&gt;<br>  &lt;svg v-else class=&quot;svg-icon&quot; :class=&quot;className&quot; aria-hidden=&quot;true&quot;&gt;<br>    &lt;use :xlink:href=&quot;iconName&quot; /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; isExternal as external &#125; from &#x27;@/utils/validate&#x27;<br>import &#123; defineProps, computed &#125; from &#x27;vue&#x27;<br>const props = defineProps(&#123;<br>  // icon 图标<br>  icon: &#123;<br>    type: String,<br>    required: true<br>  &#125;,<br>  // 图标类名<br>  className: &#123;<br>    type: String,<br>    default: &#x27;&#x27;<br>  &#125;<br>&#125;)<br><br>/**<br> * 判断是否为外部图标<br> */<br>const isExternal = computed(() =&gt; external(props.icon))<br>/**<br> * 外部图标样式<br> */<br>const styleExternalIcon = computed(() =&gt; (&#123;<br>  mask: `url($&#123;props.icon&#125;) no-repeat 50% 50%`,<br>  &#x27;-webkit-mask&#x27;: `url($&#123;props.icon&#125;) no-repeat 50% 50%`<br>&#125;))<br>/**<br> * 项目内图标<br> */<br>const iconName = computed(() =&gt; `#icon-$&#123;props.icon&#125;`)<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.svg-icon &#123;<br>  width: 1em;<br>  height: 1em;<br>  vertical-align: -0.15em;<br>  fill: currentColor;<br>  overflow: hidden;<br>&#125;<br><br>.svg-external-icon &#123;<br>  background-color: currentColor;<br>  mask-size: cover !important;<br>  display: inline-block;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>在父组件中使用方式如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;svg-icon icon=&quot;https://xxx/user.svg&quot;&gt;&lt;/svg-icon&gt;<br></code></pre></td></tr></table></figure>这样我们就可以显示<strong>外部图标</strong>了</li></ol><h3 id="处理内部svg图标的展示"><a href="#处理内部svg图标的展示" class="headerlink" title="处理内部svg图标的展示"></a>处理内部svg图标的展示</h3><ol><li>首先导入所有内部图标到icons文件夹下</li><li>在icons下创建index.js文件，该文件需完成以下2点<ol><li>导入所有svg图标</li><li>完成SvgIcon的全局注册</li></ol></li></ol><p>代码如下，可参考<a href="https://webpack.docschina.org/guides/dependency-management/#requirecontext">webpack文档</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon&#x27;</span><br><br><span class="hljs-comment">// 通过 require.context() 函数来创建自己的 context</span><br><span class="hljs-keyword">const</span> svgRequire = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;./svg&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>)<br><span class="hljs-comment">// 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。</span><br><span class="hljs-comment">// 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标</span><br><span class="hljs-comment">// 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入</span><br>svgRequire.keys().forEach(<span class="hljs-function"><span class="hljs-params">svgIcon</span> =&gt;</span> svgRequire(svgIcon))<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> app =&gt; &#123;<br>  app.component(<span class="hljs-string">&#x27;svg-icon&#x27;</span>, SvgIcon)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在父组件中使用SvgIcon引入本地svg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 用户名   <br>&lt;svg-icon icon=&quot;user&quot; /&gt;<br>// 密码<br>&lt;svg-icon icon=&quot;password&quot; /&gt;<br>// 眼睛<br>&lt;svg-icon icon=&quot;eye&quot; /&gt;<br></code></pre></td></tr></table></figure><p>此时，图标依然无法显示，因为缺少webpack中专门处理svg图标的一个loader</p><h3 id="svg-sprite-loader"><a href="#svg-sprite-loader" class="headerlink" title="svg-sprite-loader"></a>svg-sprite-loader</h3><p><a href="https://www.npmjs.com/package/svg-sprite-loader">svg-sprite-loader</a> 是 webpack 中专门用来处理 svg 图标的一个 loader,我们需要在项目中加上它</p><ol><li>下载该loader,执行<code>npm i --save-dev svg-sprite-loader</code></li><li>在vue.config.js文件中（没有则新建一个），新增如下配置<br>（<a href="https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">webpack文档</a>）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">dir</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> path.join(__dirname, dir)<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-function"><span class="hljs-title">chainWebpack</span>(<span class="hljs-params">config</span>)</span> &#123;<br>    <span class="hljs-comment">// 设置 svg-sprite-loader</span><br>    config.module<br>      .rule(<span class="hljs-string">&#x27;svg&#x27;</span>)<br>      .exclude.add(resolve(<span class="hljs-string">&#x27;src/icons&#x27;</span>))<br>      .end()<br>    config.module<br>      .rule(<span class="hljs-string">&#x27;icons&#x27;</span>)<br>      .test(<span class="hljs-regexp">/\.svg$/</span>)<br>      .include.add(resolve(<span class="hljs-string">&#x27;src/icons&#x27;</span>))<br>      .end()<br>      .use(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>)<br>      .loader(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>)<br>      .options(&#123;<br>        <span class="hljs-attr">symbolId</span>: <span class="hljs-string">&#x27;icon-[name]&#x27;</span><br>      &#125;)<br>      .end()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>处理完以上配置之后，重新启动项目，即可展示图标</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>svg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require和import的理解</title>
    <link href="/2022/12/05/require%E5%92%8Cimport%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/12/05/require%E5%92%8Cimport%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/huancheng/p/10312822.html">https://www.cnblogs.com/huancheng/p/10312822.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>import</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack官网学习</title>
    <link href="/2022/12/05/webpack%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/12/05/webpack%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack学习与理解"><a href="#webpack学习与理解" class="headerlink" title="webpack学习与理解"></a>webpack学习与理解</h2><p><a href="https://webpack.docschina.org/concepts/">webpack官网</a></p><h3 id="概念（what）"><a href="#概念（what）" class="headerlink" title="概念（what）"></a>概念（what）</h3><p>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p><h3 id="为啥要用webpack（why）"><a href="#为啥要用webpack（why）" class="headerlink" title="为啥要用webpack（why）"></a>为啥要用webpack（why）</h3><p>webpack的作用就是将在node中写好的代码（后端）解析为在浏览器下（前端）可以运行的代码<br>打包的意思就是，不用再像浏览器那样，先引入a.js再引入b.js，完事儿a.js还要暴露为全局变量。而是直接将两个js打包成为一个bundle.js，然后在网页中直接引入bundle.js就行了。<br>比如说我们编写一些比较高级的语法，但是部分浏览器是不支持的，此时我们就需要设置一些pollfill去解决该问题。在例如我们编写的TS和Vue文件，这些浏览器都不能识别，而webpack就会使用对应的babel对其进行转化，转化为浏览器可以识别的文件。</p><h3 id="怎么用（how）"><a href="#怎么用（how）" class="headerlink" title="怎么用（how）"></a>怎么用（how）</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li>入口 entry</li><li>输出 output</li><li>loader</li><li>插件 plugin</li><li>模式 mode</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端代码格式规范整理</title>
    <link href="/2022/12/01/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
    <url>/2022/12/01/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="前端编程格式规范"><a href="#前端编程格式规范" class="headerlink" title="前端编程格式规范"></a>前端编程格式规范</h3><ol><li>代码格式规范</li><li>git 提交规范</li></ol><h4 id="代码格式规范"><a href="#代码格式规范" class="headerlink" title="代码格式规范"></a>代码格式规范</h4><p>通过<code>ESLint + Prettier + VSCode</code> 配置，达到了在保存代码时，自动规范化代码格式的目的</p><h4 id="git-提交规范"><a href="#git-提交规范" class="headerlink" title="git 提交规范"></a>git 提交规范</h4><p>通过<code>husky</code> 来监测 Git hooks 钩子, 并用以下插件完成配置</p><ol><li>约定式提交规范</li><li><code>commitizen</code>：git 提交规范化工具</li><li><code>commitlint</code>：用于检查提交信息</li><li><code>pre-commit</code>： git hooks 钩子</li><li><code>lint-staged</code>：只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送</li></ol><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="代码格式规范-1"><a href="#代码格式规范-1" class="headerlink" title="代码格式规范"></a>代码格式规范</h4><ol><li>在 VSCode 中安装 prettier 插件</li><li>在项目中新建 .prettierrc 文件（perttier 默认配置文件）</li><li>添加配置<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// 不尾随分号</span><br>  <span class="hljs-attr">&quot;semi&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 使用单引号</span><br>  <span class="hljs-attr">&quot;singleQuote&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 多行逗号分割的语法中，最后一行不加逗号</span><br>  <span class="hljs-attr">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在vscode 设置面板中搜索Format On Save，勾选上即可<blockquote><p>注意一个eslint和prettier的冲突问题：有关’space-before-function-paren’的冲突。在eslintrc.js文件中rules选项下新增一条规则并重启vscode即可。<code>&#39;space-before-function-paren&#39;: &#39;off&#39;</code></p></blockquote></li></ol><h4 id="git-提交规范-1"><a href="#git-提交规范-1" class="headerlink" title="git 提交规范"></a>git 提交规范</h4><h5 id="描述信息怎么填写"><a href="#描述信息怎么填写" class="headerlink" title="描述信息怎么填写"></a>描述信息怎么填写</h5><p>使用<code>commitizen</code>，它提供了一个 git cz 的指令用于代替 git commit</p><ol><li>全局安装commitizen<br><code>npm install -g commitizen@4.2.4</code></li><li>安装并配置<code>cz-customizable</code>插件</li><li>1 <code>npm i cz-customizable@6.3.0 --save-dev</code></li><li><ol start="2"><li>添加以下配置到 package.json 中<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>  <span class="hljs-string">&quot;config&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;commitizen&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;node_modules/cz-customizable&quot;</span><br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure></li></ol></li><li>项目根目录下创建 .cz-config.js 自定义提示文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 可选类型</span><br>  <span class="hljs-attr">types</span>: [<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;feat&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;feat:     新功能&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;fix&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fix:      修复&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;docs&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;docs:     文档变更&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;style:    代码格式(不影响代码运行的变动)&#x27;</span> &#125;,<br>    &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;refactor&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;refactor: 重构(既不是增加feature，也不是修复bug)&#x27;</span><br>    &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;perf&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;perf:     性能优化&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test:     增加测试&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;chore&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chore:    构建过程或辅助工具的变动&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;revert&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;revert:   回退&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;build&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;build:    打包&#x27;</span> &#125;<br>  ],<br>  <span class="hljs-comment">// 消息步骤</span><br>  <span class="hljs-attr">messages</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;请选择提交类型:&#x27;</span>,<br>    <span class="hljs-attr">customScope</span>: <span class="hljs-string">&#x27;请输入修改范围(可选):&#x27;</span>,<br>    <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;请简要描述提交(必填):&#x27;</span>,<br>    <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;请输入详细描述(可选):&#x27;</span>,<br>    <span class="hljs-attr">footer</span>: <span class="hljs-string">&#x27;请输入要关闭的issue(可选):&#x27;</span>,<br>    <span class="hljs-attr">confirmCommit</span>: <span class="hljs-string">&#x27;确认使用以上信息提交？(y/n/e/h)&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 跳过问题</span><br>  <span class="hljs-attr">skipQuestions</span>: [<span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;footer&#x27;</span>],<br>  <span class="hljs-comment">// subject文字长度默认是72</span><br>  <span class="hljs-attr">subjectLimit</span>: <span class="hljs-number">72</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>使用 <code>git cz</code> 代替 <code>git commit</code></li></ol><h4 id="强制要求描述信息复合约定规范"><a href="#强制要求描述信息复合约定规范" class="headerlink" title="强制要求描述信息复合约定规范"></a>强制要求描述信息复合约定规范</h4><p>使用git hooks（<a href="https://git-scm.com/docs/githooks">详情</a>）<br>我们需要使用的是pre-commit和commit-msg</p><ol><li>commit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交</li><li>pre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交</li></ol><h5 id="使用-husky-commitlint-检查提交描述是否符合规范要求"><a href="#使用-husky-commitlint-检查提交描述是否符合规范要求" class="headerlink" title="使用 husky + commitlint 检查提交描述是否符合规范要求"></a>使用 husky + commitlint 检查提交描述是否符合规范要求</h5><p>commitlint：用于检查提交信息<br>husky：是git hooks工具</p><h6 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h6><ol><li>安装<br><code>npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4</code></li><li>创建 commitlint.config.js 文件<br><code>echo &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js</code></li><li>增加配置项到commitlint.config.js（<a href="https://github.com/conventional-changelog/commitlint/blob/master/@commitlint/config-conventional/index.js">config-conventional 默认配置点击可查看</a>）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 继承的规则</span><br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>],<br>  <span class="hljs-comment">// 定义规则类型</span><br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-comment">// type 类型定义，表示 git 提交的 type 必须在以下类型范围内</span><br>    <span class="hljs-string">&#x27;type-enum&#x27;</span>: [<br>      <span class="hljs-number">2</span>,<br>      <span class="hljs-string">&#x27;always&#x27;</span>,<br>      [<br>        <span class="hljs-string">&#x27;feat&#x27;</span>, <span class="hljs-comment">// 新功能 feature</span><br>        <span class="hljs-string">&#x27;fix&#x27;</span>, <span class="hljs-comment">// 修复 bug</span><br>        <span class="hljs-string">&#x27;docs&#x27;</span>, <span class="hljs-comment">// 文档注释</span><br>        <span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-comment">// 代码格式(不影响代码运行的变动)</span><br>        <span class="hljs-string">&#x27;refactor&#x27;</span>, <span class="hljs-comment">// 重构(既不增加新功能，也不是修复bug)</span><br>        <span class="hljs-string">&#x27;perf&#x27;</span>, <span class="hljs-comment">// 性能优化</span><br>        <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-comment">// 增加测试</span><br>        <span class="hljs-string">&#x27;chore&#x27;</span>, <span class="hljs-comment">// 构建过程或辅助工具的变动</span><br>        <span class="hljs-string">&#x27;revert&#x27;</span>, <span class="hljs-comment">// 回退</span><br>        <span class="hljs-string">&#x27;build&#x27;</span> <span class="hljs-comment">// 打包</span><br>      ]<br>    ],<br>    <span class="hljs-comment">// subject 大小写不做校验</span><br>    <span class="hljs-string">&#x27;subject-case&#x27;</span>: [<span class="hljs-number">0</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>确保保存为 <strong>UTF-8</strong> 的编码格式 否则会报错</p></blockquote></li></ol><h6 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h6><ol><li><p>安装依赖<br><code>npm install husky@7.0.1 --save-dev</code></p></li><li><p>启动hooks ， 生成 .husky 文件夹<br><code>npx husky install</code></p></li><li><p>在 package.json 中生成 prepare 指令（ 需要 npm &gt; 7.0 版本 ）<br><code>npm set-script prepare &quot;husky install&quot;</code></p></li><li><p>执行 prepare 指令<br><code>npm run prepare</code><br>执行成功显示 husky - Git hooks installed</p></li><li><p>添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 <code>npx --no-install commitlint --edit &quot;$1&quot;</code> 指令<br><code>npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;</code></p></li><li><p>至此，不符合规范的commit将不再可提交</p><h5 id="通过-pre-commit-检测提交时代码规范"><a href="#通过-pre-commit-检测提交时代码规范" class="headerlink" title="通过 pre-commit 检测提交时代码规范"></a>通过 pre-commit 检测提交时代码规范</h5><p>我们期望通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测</p></li><li><p>执行 <code>npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot;</code> 添加 commit 时的 hook （npx eslint –ext .js,.vue src 会在执行到该 hook 时运行）</p></li><li><p>该操作会在.husky文件夹中生成对应文件 pre-commit：</p></li></ol><h5 id="lint-staged-自动修复格式错误"><a href="#lint-staged-自动修复格式错误" class="headerlink" title="lint-staged 自动修复格式错误"></a>lint-staged 自动修复格式错误</h5><p>lint-staged 可以让你当前的代码检查 只检查本次修改更新的代码，并在出现错误的时候，自动修复并且推送,lint-staged无需单独安装，我们生成项目时，vue-cli 已经帮助我们安装过了，所以我们直接使用就可以了</p><ol><li>修改 package.json 配置<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;src/**/*.&#123;js,vue&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;eslint --fix&quot;</span>,<br>      <span class="hljs-string">&quot;git add&quot;</span><br>    ]<br>  &#125;<br><br></code></pre></td></tr></table></figure></li><li>修改 .husky/pre-commit 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>. <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span><br><br>npx lint-staged<br></code></pre></td></tr></table></figure></li></ol><p>至此，发现 暂存区中 不符合 ESlint 的内容，被自动修复</p>]]></content>
    
    
    
    <tags>
      
      <tag>格式化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试双越100道面试真题</title>
    <link href="/2022/11/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%8C%E8%B6%8A100%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
    <url>/2022/11/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%8C%E8%B6%8A100%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3封装组件库学习记录</title>
    <link href="/2022/11/08/vue3%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/08/vue3%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-子组件添加v-bind-”-attrs”即可将父组件中未通过props传递的属性全部注入绑定到子组件中"><a href="#1-子组件添加v-bind-”-attrs”即可将父组件中未通过props传递的属性全部注入绑定到子组件中" class="headerlink" title="1.子组件添加v-bind=”$attrs”即可将父组件中未通过props传递的属性全部注入绑定到子组件中"></a>1.子组件添加v-bind=”$attrs”即可将父组件中未通过props传递的属性全部注入绑定到子组件中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;m-menu<br>  :data=<span class="hljs-string">&quot;data1&quot;</span><br>  background-color=<span class="hljs-string">&quot;red&quot;</span><br>  :defaultActive=<span class="hljs-string">&quot;2&quot;</span><br>  a=<span class="hljs-string">&quot;ccc&quot;</span><br>&gt;&lt;/m-menu&gt;<br><span class="hljs-comment">// 子组件</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-menu</span></span></span><br><span class="hljs-tag"><span class="xml"> <span class="hljs-attr">:default-active</span>=<span class="hljs-string">&quot;defaultActive&quot;</span></span></span><br><span class="hljs-tag"><span class="xml"> <span class="hljs-attr">:router</span>=<span class="hljs-string">&quot;router&quot;</span></span></span><br><span class="hljs-tag"><span class="xml"> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-无限层级菜单：使用tsx实现（因为vue模板不太适合递归渲染生成）"><a href="#2-无限层级菜单：使用tsx实现（因为vue模板不太适合递归渲染生成）" class="headerlink" title="2.无限层级菜单：使用tsx实现（因为vue模板不太适合递归渲染生成）"></a>2.无限层级菜单：使用tsx实现（因为vue模板不太适合递归渲染生成）</h3><p>可以增加自定义键名，将后台返回的数据的键名以props的方式传递给子组件以更自由地接收数据</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> data = [&#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-attr">c</span>:<span class="hljs-string">&#x27;c&#x27;</span><br>&#125;];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;m-sub-comp :name=<span class="hljs-string">&quot;a&quot;</span> :icon=<span class="hljs-string">&quot;b&quot;</span> :children=<span class="hljs-string">&quot;c&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>子组件中可以直接用props.name等进行其他操作</p><h3 id="3-城市选择组件，点击对应字母跳转至该字母开头的城市区域（滚动条定位的过程）可以使用el-scrollIntoView-方法"><a href="#3-城市选择组件，点击对应字母跳转至该字母开头的城市区域（滚动条定位的过程）可以使用el-scrollIntoView-方法" class="headerlink" title="3.城市选择组件，点击对应字母跳转至该字母开头的城市区域（滚动条定位的过程）可以使用el.scrollIntoView()方法"></a>3.城市选择组件，点击对应字母跳转至该字母开头的城市区域（滚动条定位的过程）可以使用<code>el.scrollIntoView()</code>方法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 先给每个字母对应城市区域添加id</span><br><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.getElementById();<br><span class="hljs-keyword">if</span>(el) el.scrollIntoView();<br></code></pre></td></tr></table></figure><h3 id="4-父组件给子组件绑定显示或隐藏的值"><a href="#4-父组件给子组件绑定显示或隐藏的值" class="headerlink" title="4.父组件给子组件绑定显示或隐藏的值"></a>4.父组件给子组件绑定显示或隐藏的值</h3><p>父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;m-son :v-model=&quot;visible&quot; /&gt;<br></code></pre></td></tr></table></figure><p>子组件中： 两次监听，一次监听父组件props的值以修改子组件的显示隐藏值，第二次监听子组件显示隐藏值 以分发事件给父组件，父组件以v-model的形式接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">watch(<br>  <span class="hljs-function">() =&gt;</span> props.visible,<br>  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>    dialogVisible.value = newVal;<br>  &#125;<br>);<br>watch(<br>  <span class="hljs-function">() =&gt;</span> dialogVisible.value,<br>  <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// console.log(&#x27;&#x27;)</span><br>    emits(<span class="hljs-string">&quot;update:visible&quot;</span>, val);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h3 id="5-全局封装注册图标组件"><a href="#5-全局封装注册图标组件" class="headerlink" title="5.全局封装注册图标组件"></a>5.全局封装注册图标组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Icons <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@element-plus/icons-vue&quot;</span>;<br><span class="hljs-comment">// Icons是包含所有图标组件的对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> Icons) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(Icons, i)) &#123;<br>    app.component(<span class="hljs-string">`el-icon-<span class="hljs-subst">$&#123;toLine(i)&#125;</span>`</span>,(Icons <span class="hljs-keyword">as</span> any)[i])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-全局注册所有自定义component组件"><a href="#6-全局注册所有自定义component组件" class="headerlink" title="6.全局注册所有自定义component组件"></a>6.全局注册所有自定义component组件</h3><h4 id="6-1-在components文件夹下新增一个index-ts文件，将所有自定义组件引入并遍历向全局注入"><a href="#6-1-在components文件夹下新增一个index-ts文件，将所有自定义组件引入并遍历向全局注入" class="headerlink" title="6.1.在components文件夹下新增一个index.ts文件，将所有自定义组件引入并遍历向全局注入"></a>6.1.在components文件夹下新增一个index.ts文件，将所有自定义组件引入并遍历向全局注入</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> components:<span class="hljs-built_in">any</span>[] = [<br>  menu,<br>];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">app: App</span>)</span> &#123;<br>    components.map(<span class="hljs-function"><span class="hljs-params">component</span> =&gt;</span> &#123;<br>      app.use(component)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vue3,封装组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习</title>
    <link href="/2022/06/30/TypeScript%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/06/30/TypeScript%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">let</span> b: <span class="hljs-string">&quot;male&quot;</span> | <span class="hljs-string">&quot;female&quot;</span> <span class="hljs-comment">//限制b的值只可以取male或female</span><br><span class="hljs-keyword">let</span> c: <span class="hljs-built_in">any</span><br><span class="hljs-keyword">let</span> numbers: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">// 联合类型</span><br><br><span class="hljs-comment">// 类型别名</span><br><br><span class="hljs-keyword">type</span> NumOrStrArr = (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[];<br><br><span class="hljs-keyword">let</span> number2: NumOrStrArr = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;w&#x27;</span>];<br><br><span class="hljs-comment">// 函数类型 分别指定函数参数和返回值的类型 偏向使用这种方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1: <span class="hljs-built_in">string</span>,num2: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> add1 = (num1: <span class="hljs-built_in">number</span>,<span class="hljs-attr">num2</span>: <span class="hljs-built_in">number</span>):<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 同时指定参数和返回值类型（看着有点别扭）</span><br><span class="hljs-keyword">const</span> add2: <span class="hljs-function">(<span class="hljs-params">num1:<span class="hljs-built_in">number</span>,num2:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params">num1,num2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">great</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 可选参数 在参数名后冒号前添加个问号？即可</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySlice</span>(<span class="hljs-params">start?: <span class="hljs-built_in">number</span>,end?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 对象类型 注意也可以加可选参数</span><br><span class="hljs-keyword">let</span> person: &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?:<span class="hljs-built_in">number</span> <br>  sayHi(name:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">void</span><br>&#125; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zk&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>,name)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><p>当一个对象类型被多次使用时，一般可以使用接口interface来描述对象的类型，以达到<strong>复用</strong>的目的。也就是上方对象类型（可理解为对象模板）</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br><span class="hljs-comment">// 每一行后面可以加分号逗号或者不加都行</span><br>  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">secondName</span>: <span class="hljs-built_in">string</span><br>  sayHi(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span>(<span class="hljs-params">person: Person</span>): <span class="hljs-title">string</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 接口和类型别名的对比</span><br><span class="hljs-comment">// 相同点：都可以给对象指定类型</span><br><span class="hljs-comment">// 不同点：interface只能给对象指定，类型别名可以为任何类型指定别名</span><br><br><span class="hljs-keyword">type</span> Person &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">secondName</span>: <span class="hljs-built_in">string</span><br>  sayHi(): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Point2D &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> Point3D <span class="hljs-keyword">extends</span> Point2D &#123;<br>  <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p3: Point3D = &#123;&#125; <span class="hljs-comment">//此时需要你定义x,y,z的值才行</span><br></code></pre></td></tr></table></figure><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><blockquote><p>指定确切数量的数组</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> position: [<span class="hljs-built_in">number</span>,<span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-comment">// 只能有两个数字元素的数组</span><br></code></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><blockquote><p>能自动推断某个变量的类型</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 1. 声明变量并立即初始化之后,未初始化的还是必须要添加类型注解</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">10</span>; <span class="hljs-comment">// :number可以省略掉</span><br><span class="hljs-comment">// 2. 方法返回值可以推断</span><br><span class="hljs-comment">// function add(num1: number, num2:number)：number &#123;&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2:<span class="hljs-built_in">number</span></span>) </span>&#123;&#125;<span class="hljs-comment">// 这里add括号之后的返回值类型注解可以省略掉</span><br></code></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote><p>使用类型断言指定更具体的类型 a标签link的问题<br>使用<strong>as</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> aLink = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;link&#x27;</span>) <span class="hljs-keyword">as</span> HTMLAnchorElement<br><span class="hljs-comment">// 在浏览器控制台打印 console.dir(),在最后的prototype那边即可看到元素的类型</span><br></code></pre></td></tr></table></figure><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-comment">// 此时str就是一个字面量类型，就是这个字符串就是一个类型，因为const不可变</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeDirection</span>(<span class="hljs-params">direction: <span class="hljs-string">&#x27;up&#x27;</span> | <span class="hljs-string">&#x27;down&#x27;</span> | <span class="hljs-string">&#x27;left&#x27;</span> | <span class="hljs-string">&#x27;right&#x27;</span></span>)</span><br><span class="hljs-function">// 这样比用<span class="hljs-title">string</span>更严谨 更推荐</span><br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Direction &#123;Up,Down,Left,Right&#125;<br><span class="hljs-built_in">enum</span> Direction &#123;Up = <span class="hljs-number">2</span>,Down = <span class="hljs-number">4</span>,Left,Right&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeDirection</span>(<span class="hljs-params">direction:Direction</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(direction)<br>&#125;<br><br>changeDirection(Direction.Up)<span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><p>//必须要有初始值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Direction &#123;Up=<span class="hljs-string">&quot;Up&quot;</span>,Down=<span class="hljs-string">&quot;Down&quot;</span>,Left=<span class="hljs-string">&quot;Left&quot;</span>,Right=<span class="hljs-string">&quot;Right&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// constructor不能有返回值类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> firstName,<span class="hljs-keyword">public</span> middleInitial, <span class="hljs-keyword">public</span> lastName</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.fullName = firstName+ <span class="hljs-string">&quot; &quot;</span> + middleInitial + <span class="hljs-string">&quot; &quot;</span> + lastName;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-string">&quot;Micky&quot;</span>,<span class="hljs-string">&quot;User&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="类实例方法"><a href="#类实例方法" class="headerlink" title="类实例方法"></a>类实例方法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  x = <span class="hljs-number">1</span><br>  y = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// 类实例方法</span><br>  <span class="hljs-function"><span class="hljs-title">scale</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x *= n<br>    <span class="hljs-built_in">this</span>.y *= n<br>  &#125;<br>&#125;<br>p.scale(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h4 id="类继承-extends-amp-implements-interface"><a href="#类继承-extends-amp-implements-interface" class="headerlink" title="类继承 extends &amp; implements(interface)"></a>类继承 extends &amp; implements(interface)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// extends</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mvoe&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">bark</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bark&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// implements让class实现接口 约束</span><br><span class="hljs-comment">// 即Person类必须提供（实现）Singable接口中指定的所有方法和属性</span><br><span class="hljs-keyword">interface</span> Singable &#123;<br>  sing(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">implements</span> <span class="hljs-title">Singable</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sing&#x27;</span>)<span class="hljs-comment">// 要把interface中的方法实现，重写</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员可见性"><a href="#成员可见性" class="headerlink" title="成员可见性"></a>成员可见性</h4><p>public 是默认的，可以不写<br>protected 仅在类和子类中可见，<strong>实例对象也不可见</strong><br>privated 仅在当前类可见，子类和实例对象不可见</p><p>readonly 只读修饰符 防止在构造函数之外对属性赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">readonly</span> age: <span class="hljs-built_in">number</span><br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">age:<span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.age = age<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">20</span><span class="hljs-comment">// 这边会报错 age属性不允许修改</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h4><p>对象或者接口的类型兼容性，属性多的可以赋值给属性少的<br>参数兼容性，参数少的可以赋值给多的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> F1 = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><span class="hljs-keyword">type</span> F2 = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">let</span> f1: F1<br><span class="hljs-keyword">let</span> f2: F2 = f1<span class="hljs-comment">//是可以的</span><br></code></pre></td></tr></table></figure><h3 id="交叉类型-amp"><a href="#交叉类型-amp" class="headerlink" title="交叉类型 &amp;"></a>交叉类型 &amp;</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123; name: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">interface</span> Contact &#123; phone: <span class="hljs-built_in">string</span>&#125;<br><span class="hljs-keyword">type</span> PersonDetail = Person &amp; Contact<span class="hljs-comment">//就是将两个类型合并</span><br><span class="hljs-keyword">let</span> p1: PersonDetail = &#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">phone</span>:<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="交叉类型和接口继承对比"><a href="#交叉类型和接口继承对比" class="headerlink" title="交叉类型和接口继承对比"></a>交叉类型和接口继承对比</h4><p>同名属性之间，处理类型冲突的方式不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span><span class="hljs-comment">//此时代码会报错</span><br>&#125;<br><span class="hljs-keyword">interface</span> C &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">type</span> D = A &amp; C<span class="hljs-comment">// 不会报错 fn的参数变成number和string均可 fn(value: number | string)</span><br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>51课</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3简单上手</title>
    <link href="/2022/06/14/vue3%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/2022/06/14/vue3%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="compostionApi"><a href="#compostionApi" class="headerlink" title="compostionApi"></a>compostionApi</h3><p>能够将同一个逻辑关注点相关代码收集在一起 == 函数式编程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props,context</span>)</span> &#123;<br>    <span class="hljs-comment">// 使用 `toRefs` 创建对 `props` 中的 `user` property 的响应式引用</span><br>    <span class="hljs-keyword">const</span> &#123; user &#125; = toRefs(props)<br>    <span class="hljs-comment">// ref</span><br>    <span class="hljs-keyword">const</span> another = ref([]);<br>    <span class="hljs-comment">//...reactive computed需要导入</span><br>    <span class="hljs-keyword">const</span> state = reactive(&#123;<br>      <span class="hljs-attr">a</span>:<span class="hljs-number">0</span>,<br>      <span class="hljs-attr">b</span>:computed(<span class="hljs-function">() =&gt;</span> a * <span class="hljs-number">2</span>)<br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(props.user)<br>  &#125;<br>    <span class="hljs-comment">// 生命周期的监听 注意create相关已移除，之前create中的代码在setup函数中直接写即可</span><br>    onMounted(getUserRepositories)；<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      state,another<br>      <span class="hljs-comment">// 在template中使用的时候 用state.a</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要作用可以把同一模块的代码合并到一个单独的js文件中，再引入进来，实现模块的隔离<br>单独的js文件 export default function func1 返回想要的变量或方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 拆分后的一部分示例模块</span><br><span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/repositories&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref, onMounted, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUserRepositories</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> repositories = ref([])<br>  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(user.value)<br>  &#125;<br><br>  onMounted(getUserRepositories)<br>  watch(user, getUserRepositories)<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    repositories,<br>    getUserRepositories<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 在主文件中import进来 在setup中 取出js文件return的值</span><br><span class="hljs-keyword">const</span> &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)<br></code></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 计算属性的函数中如果只传入一个回调函数，表示是get</span><br><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> user = reactive(&#123;<br>    <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;f&quot;</span>,<br>    <span class="hljs-attr">lastName</span>:<span class="hljs-string">&quot;l&quot;</span><br>  &#125;);<br>  <span class="hljs-comment">// 返回的是一个ref类型的对象</span><br>  <span class="hljs-keyword">const</span> fullName1 = computed(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span>  user.firstName+ <span class="hljs-string">&#x27;_&#x27;</span> + user.lastName<br>  &#125;)<br>  <span class="hljs-comment">// 如果是get set都有的话，传对象里面有两个方法</span><br>  <span class="hljs-keyword">const</span> fullName2 = computed(&#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span>  user.firstName+ <span class="hljs-string">&#x27;_&#x27;</span> + user.lastName<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>)</span>&#123;<br>      <span class="hljs-keyword">const</span> names = val.split(<span class="hljs-string">&quot;_&quot;</span>);<br>      user.firstName = names[<span class="hljs-number">0</span>];<br>      user.lastName = names[<span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监视属性watch"><a href="#监视属性watch" class="headerlink" title="监视属性watch"></a>监视属性watch</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 初始化的时候默认没有执行</span><br>watch(user, <span class="hljs-function">(<span class="hljs-params">&#123;firstName,lastName&#125;</span>)=&gt;</span>&#123;<br>  fullName3 = firstName+<span class="hljs-string">&quot;_&quot;</span>+lastName<br>&#125;，&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 初始化的时候默认执行，不需要配置immediate</span><br>watchEffect(<span class="hljs-function">()=&gt;</span> &#123;<br>  fullName3 = user.firstName+<span class="hljs-string">&quot;_&quot;</span>+user.lastName<br>&#125;)<br><span class="hljs-comment">// 当使用watch监视非响应式数据的时候，需要改成箭头函数的形式如下</span><br>watch([<span class="hljs-function">()=&gt;</span>user.firstName,<span class="hljs-function">()=&gt;</span>user.lastName],<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>toRefs可以把一个响应式对象转换成普通对象，该对象的每个peoperty都是一个ref</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> state = reactive(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">1</span><br>  &#125;);<br><br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>    toRefs(state).name.value += <span class="hljs-string">&quot;==&quot;</span><span class="hljs-comment">//注意使用value</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...state<span class="hljs-comment">//这样的话模板中直接使用name和age数据不会响应式变化</span><br>    ...toRefs(state)<span class="hljs-comment">//这样传递出来的对象属性就都是响应式的了</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shallowReactive和shallowRef"><a href="#shallowReactive和shallowRef" class="headerlink" title="shallowReactive和shallowRef"></a>shallowReactive和shallowRef</h3><p>仅最外层属性是双向绑定的，不是深层监视（不常用）</p><h3 id="readonly和shallowReadonly"><a href="#readonly和shallowReadonly" class="headerlink" title="readonly和shallowReadonly"></a>readonly和shallowReadonly</h3><p>readonly是深度的只读，对象内所有属性都只读<br>shallowReadonly是浅只读的，对象中还包含对象，嵌套对象就无效了</p><h3 id="toRaw和markRaw"><a href="#toRaw和markRaw" class="headerlink" title="toRaw和markRaw"></a>toRaw和markRaw</h3><p>toRaw把代理对象变成普通对象，数据变化，页面内容不变<br>markRaw标记的对象数据，从此以后都不能成为代理对象，就是不能变化了 （？）</p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>为源响应式 对象上的某个属性创建一个ref对象，二者内部操作的是同一个数据值，更新时二者是同步的<br>ref与toRef区别：拷贝了一份新的数据值单独操作，更新时互相不影响<br>应用：当要将某个prop的ref传递给复合函数时，toRef很有用（复合函数的参数要求是ref格式）</p><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebouncedRef</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T,delay = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeoutId: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// track trigger固定写法</span><br>  <span class="hljs-keyword">return</span> customRef(<span class="hljs-function">(<span class="hljs-params">track,trigger</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>        track();<br>        <span class="hljs-keyword">return</span> value;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue: T</span>)</span> &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>        timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          value = newValue<br>          trigger()<br>        &#125;, delay);<br>      &#125;,<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题Webpack篇</title>
    <link href="/2022/05/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98Webpack%E7%AF%87/"/>
    <url>/2022/05/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98Webpack%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack,</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题网络篇</title>
    <link href="/2022/05/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    <url>/2022/05/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="强弱缓存的理解"><a href="#强弱缓存的理解" class="headerlink" title="强弱缓存的理解"></a>强弱缓存的理解</h3><h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3+ts+vite开发音乐播放器</title>
    <link href="/2022/05/27/vue3-ts-vite%E5%BC%80%E5%8F%91%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2022/05/27/vue3-ts-vite%E5%BC%80%E5%8F%91%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h3><p><a href="https://blog.csdn.net/guoyuanyuan6496/article/details/109244901">https://blog.csdn.net/guoyuanyuan6496/article/details/109244901</a></p><p class="note note-primary">这是一个测试</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题记录</title>
    <link href="/2022/05/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="OD-一面面试题"><a href="#OD-一面面试题" class="headerlink" title="OD 一面面试题"></a>OD 一面面试题</h3><ol><li>做过哪些项目 项目的亮点是什么</li><li>defer和async的区别</li><li>生命周期有哪些和各自特点</li><li>原型链是什么</li><li>闭包的使用，在哪用过，为啥要用</li><li>event loop</li></ol><h3 id="OD-二面面试题"><a href="#OD-二面面试题" class="headerlink" title="OD 二面面试题"></a>OD 二面面试题</h3><ol><li>前端性能优化相关</li><li>前端安全相关做过哪些，xss csrf分别是怎么防护的</li><li>搜索页面是怎么保证在秒级拿到数据的，（不拘泥于前端），模糊查找，前缀模糊查找和后缀模糊查找哪个性能更好（后缀：面试官说的）</li><li>算法数据结构了解哪些？哈希表是啥？怎么插入，删除数据，优点是啥</li><li>react和vue区别是什么？一般技术选型是怎么选的</li><li>有没有做过一个独立需求的落地？怎么选择技术或者框架的</li><li>svg的文件结构，为什么比icon更快</li></ol><h3 id="天润-一面面试题"><a href="#天润-一面面试题" class="headerlink" title="天润 一面面试题"></a>天润 一面面试题</h3><ol><li>新增的ES6语法</li><li>新增的数组方法</li><li>节流防抖代码实现</li><li>vue组件中是怎么通信的</li><li>vue双向数据绑定</li><li>vuex的数据流向</li><li>vue能监听数组数据的变化吗，用什么方法可以触发可监听到的变化 $set</li></ol><h3 id="OD一面"><a href="#OD一面" class="headerlink" title="OD一面"></a>OD一面</h3><ol><li>webpack分包代码怎么配置</li><li>能不能在data里面使用计算属性</li><li>除了代码层面的还有哪些性能优化的方式</li><li>问组件之间优先选择哪种通信方式 为什么</li><li>问箭头函数有什么优点 </li><li>问data compute watch之间有什么依赖关系</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用js实现常见的数据结构</title>
    <link href="/2022/05/11/%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/11/%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="stack栈"><a href="#stack栈" class="headerlink" title="stack栈"></a>stack栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">peek</span>() &#123;<br>    <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">ele</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items.push(ele);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">length</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">ele</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items.push(ele);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoopQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">maxSize</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    <span class="hljs-built_in">this</span>.head = -<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">this</span>.tail = -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_45534061/article/details/113821910">https://blog.csdn.net/qq_45534061/article/details/113821910</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise</title>
    <link href="/2022/04/14/promise/"/>
    <url>/2022/04/14/promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="promise代码"><a href="#promise代码" class="headerlink" title="promise代码"></a>promise代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>  resolve();<br>  <span class="hljs-comment">// reject();</span><br>&#125;);<br>p1.then(<span class="hljs-function">() =&gt;</span> &#123;&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="promise的三个状态"><a href="#promise的三个状态" class="headerlink" title="promise的三个状态"></a>promise的三个状态</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li>pending</li><li>fulfilled(resolved)</li><li>rejected</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>不可逆</li><li>只能从 pending-&gt;fulfilled 或者 pending-&gt;rejected</li></ul><h3 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h3><p>执行resolve()  该promise的状态则 pending-&gt;fulfilled<br>执行reject()  该promise的状态则 pending-&gt;rejected</p><h3 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h3><p>resolved状态的promise可以触发then回调<br>rejected状态的promise可以触发catch回调</p><h2 id="then-catch-怎么影响状态的变化"><a href="#then-catch-怎么影响状态的变化" class="headerlink" title="then\catch 怎么影响状态的变化"></a>then\catch 怎么影响状态的变化</h2><p>then正常返回resolved,如果有报错则 返回rejected<br>catch正常返回resolved,如果有报错则 返回rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;then error&#x27;</span>)<br>&#125;) <span class="hljs-comment">// rejected状态的promise 后续p2的then则不会触发</span><br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;bug&quot;</span>)<br>&#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-comment">//2</span><br>&#125;).then(<span class="hljs-function">()=&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<span class="hljs-comment">//3 注意这边catch正常的返回也是resolved状态的promise，是可以触发后续的then回调的</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试高频题</title>
    <link href="/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <url>/2022/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="手写系列"><a href="#手写系列" class="headerlink" title="手写系列"></a>手写系列</h2><h3 id="题目一：实现深度clone"><a href="#题目一：实现深度clone" class="headerlink" title="题目一：实现深度clone"></a>题目一：实现深度clone</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params"> obj=&#123;&#125; </span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object || obj == null) &#123;</span><br><span class="hljs-string">    return obj;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  let res;</span><br><span class="hljs-string">  if(obj instanceof Array) &#123;</span><br><span class="hljs-string">    res = [];</span><br><span class="hljs-string">  &#125;else &#123;</span><br><span class="hljs-string">    res = &#123;&#125;;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  for(let item in obj) &#123;</span><br><span class="hljs-string">    if(obj.hasOwnProperty(item)) &#123;</span><br><span class="hljs-string">      res[item] = deepClone(obj[item])</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  return res;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="题目二：实现节流和防抖"><a href="#题目二：实现节流和防抖" class="headerlink" title="题目二：实现节流和防抖"></a>题目二：实现节流和防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// throttle 节流</span><br><span class="hljs-comment">// 用户会反复触发一些操作，比如鼠标移动事件，此时只需要指定一个“巡视”的间隔时间，不管用户期间触发多少次，只会在间隔点上执行给定的回调函数 （不停操作）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,threshold = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-number">0</span>;<br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span>(current - start &gt;= threshold) &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments);<br>      start = current;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), threshold, ...arguments);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// debounce 防抖</span><br><span class="hljs-comment">// 给一个固定时间，如果你开始触发动作，并且在这个固定时间内不再有任何动作，我就执行一次，否则我每次都会重新开始计时 搜索框(必须要停)</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span> (<span class="hljs-params">fn, delay = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 重新计时</span><br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), delay, ...arguments);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目三：实现call-apply-bind函数"><a href="#题目三：实现call-apply-bind函数" class="headerlink" title="题目三：实现call,apply,bind函数"></a>题目三：实现call,apply,bind函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//区别 call(assigned this object, other arguments function may need) apply(assigned this object, [other arguments]) bind(not imediately</span><br><span class="hljs-comment">//invoke,return a function,arguments are same as call)</span><br></code></pre></td></tr></table></figure><h3 id="题目四：实现简单的Promise"><a href="#题目四：实现简单的Promise" class="headerlink" title="题目四：实现简单的Promise"></a>题目四：实现简单的Promise</h3><h3 id="题目五：实现new函数"><a href="#题目五：实现new函数" class="headerlink" title="题目五：实现new函数"></a>题目五：实现new函数</h3>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高频题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题运行环境相关</title>
    <link href="/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/04/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="前端运行环境"><a href="#前端运行环境" class="headerlink" title="前端运行环境"></a>前端运行环境</h1><h2 id="网页是如何被渲染出来的"><a href="#网页是如何被渲染出来的" class="headerlink" title="网页是如何被渲染出来的"></a>网页是如何被渲染出来的</h2><blockquote><ol><li>从输入url到渲染出页面的过程</li></ol></blockquote><ol><li>加载资源的形式</li><li>加载资源的过程</li><li>渲染页面的过程</li></ol><p>详细步骤：</p><ol><li>dns解析域名对应的ip</li><li>tcp三次握手  seq = 1 ; seq = 1,ack = 1+1; seq=1+1,ack=1+1</li><li>浏览器发送请求</li><li>服务器处理请求并返回信息</li><li>浏览器解析渲染<ul><li>浏览器将获取的 HTML 文档解析成 DOM 树；</li><li>处理 CSS 标记，构成层叠样式表模型（CSSOM）；</li><li>将 DOM 和 CSSOM 合并为渲染树（rendering tree）；</li><li>渲染树的每个元素的内容都是计算过的，称之为 布局layout；</li><li>将渲染树上的各个节点绘制到屏幕上，称之为 绘制painting；</li></ul></li></ol><blockquote><ol start="2"><li>window.onload和DOMContentLoaded的区别</li></ol></blockquote><p>window.onload 所有的资源全部加载完成</p><p>DOMContentLoaded dom渲染完毕即可 图片视频之类的可能还没加载完</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数组方法</title>
    <link href="/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/27/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="JS常用数组方法"><a href="#JS常用数组方法" class="headerlink" title="JS常用数组方法"></a>JS常用数组方法</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ol><li><p>特点：能存储 有序节点 可以在已知的两个元素中间插入新的元素</p></li><li><p>创建数组的两种方法：<br>var arr = [];<br>var arr = new Array(); //用的居然是小括号 一般不用这个方法</p></li><li><p>获取元素：arr[0];获取下标为0的元素<br>替换元素：arr[3] = “fruit” 如果之前没有下标为3的元素 则在3位置处添加新的元素</p></li><li><p>length 数组长度</p></li><li><p>数组内部可以存储所有类型元素  包括数组和对象<br>var arr = [{name:”john”,age:19},12,”hello”];<br>console.log(arr[0].name);//显示为john</p></li><li><p>queue（队列）方法：pop/push  shift/unshift<br>push在队列末端插入新元素   shift在队列前端取出第一个元素并返回他，后续元素向前移动一格<br>unshift：在队列前端插入新元素 push和unshift都可以一次添加多个元素</p></li><li><p>stack（栈）方法：push/pop<br>push pop都是在末端插入或取出元素 只能是一个元素</p></li><li><p>数组同时支持先进先出(lifo)和后进先出(fifo)   是双端队列</p></li><li><p>从本质上讲  数组也是一个对象   复制数组也是复制的引用</p></li></ol><p>最后  强调 数组必须是用于  有序数据  的特殊结构 如果不按照有序数组来操作 那么就不会享受到数组的优化</p><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ol><li><p>插入提取方法</p><ul><li>arr.push 从尾部插入</li><li>arr.pop 从尾部提取</li><li>arr.shift 从头部提取</li><li>arr.unshift  从头部插入</li></ul></li><li><p>splice方法 ：可以实现 添加 删除 插入元素等操作</p><ul><li>插入或删除的起始下标：1就是替换第二个元素</li><li>删除的个数：0表示添加</li><li>添加或者要更换的元素</li></ul></li></ol><blockquote><p>splice(1,1) <em>删除</em>：从下标为1的位置删掉1个元素 splice返回的就是被删除掉的元素<br>splice(0,3,”let’s”,”dance”) <em>替换</em>：从下标为0的位置删掉3个元素 并用let’s dance替换在被删掉的区域<br>splice(1,0,”hello”,”world”) <em>添加</em>：从下标为1的位置向后添加2个元素 添加在下标为1和2的位置</p></blockquote><ol start="3"><li><p>slice方法：切片功能 slice(a,b) 切出从a下标到b下标之前的的元素 左闭右开（左边包括 右边不包括）</p><p> arr.slice()不带参数调用的话 就是创建一份新的arr副本<br> 其中b是可选的，不写的话就是从a切到末尾。<br> arr.slice()返回的是切出来的值组成的[a,b)<br> 对 <em>原数组</em> 是没有影响的</p></li><li><p>concat方法：<br>链接方法：arr.concat(a,b)将a和b连接到arr数组的最后。 如果a也是数组 则会提取出数组中的数值 添加到arr后面 ，如果不是数组，其他元素都会以本来的形式插入到数组arr中。</p></li><li><p>arr.foreach()方法：可以为数组中每一个元素运行方法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&quot;Bilbo&quot;</span>, <span class="hljs-string">&quot;Gandalf&quot;</span>, <span class="hljs-string">&quot;Nazgul&quot;</span>].forEach(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123;<br>  alert(<span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span> is at index <span class="hljs-subst">$&#123;index&#125;</span> in <span class="hljs-subst">$&#123;array&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="6"><li><p>arr.indexOf(item,from) / arr.lastIndexOf(item,from) /arr.includes(item,from) 返回item元素在数组中的下标<br>from指从哪一个下标位置开始查询</p></li><li><p>转换数组 arr.map() 对数组内所有元素调用某个方法 返回该方法返回值组成的新数组</p></li></ol><p>格式:<code>let res = arr.map(function(item,index,array)&#123;&#125;)</code><br>示例：<code>let length = [&quot;heloo&quot;,&quot;jack&quot;,&quot;tom&quot;].map(item =&gt; item.length);</code></p><ol start="8"><li><p>arr.sort() 对数组进行原位排序  排序之后的结果返回到这个数组本身 等于是修改了原数组 默认是按字符串排序</p></li><li><p>利用sort函数 对数字进行排序操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span> ];<br><br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;); 只需要比较函数返回正数或者负数就可以完成数组的排序<br><br>alert(arr);  <span class="hljs-comment">// 1, 2, 15</span><br>  <span class="hljs-comment">// 还有更简洁的：箭头函数</span><br>arr.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> <span class="hljs-keyword">return</span> a-b;);<span class="hljs-comment">//原答案return都没有写</span><br></code></pre></td></tr></table></figure></li><li><p>arr.reverse()<br>用于颠倒数组中的元素顺序</p></li><li><p>分割字符串<br>let names = ‘Bilbo, Gandalf, Nazgul’;<br>let arr = names.split(‘, ‘);<br>for (let name of arr) {<br>alert( <code>A message to $&#123;name&#125;.</code> ); // A message to Bilbo（和其他名字）<br>}</p></li><li><p>黏合字符串 与上面分割字符串正好相反：arr.join()<br>let arr = [‘Bilbo’, ‘Gandalf’, ‘Nazgul’];<br>let str = arr.join(‘;’); // 使用分号 ; 将数组粘合成字符串<br>alert( str ); // Bilbo;Gandalf;Nazgul</p></li><li><p>arr.reduce()方法：该函数一个接一个地应用于arr数组的所有元素 并将前一次结果作为参数传给下一次调用 其中accumulator是用来储存<em>上一次计算结果</em>的 可以用作类似求和的需求<br>let value = arr.reduce(function(accumulator, item, index, array)<br>示例：<br>let arr = [1, 2, 3, 4, 5];<br>let result = arr.reduce((sum, current) =&gt; sum + current, 0);<br>alert(result); // 15</p></li><li><p>array.isArray() 是数组的话返回true 反之返回false</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS字符串方法</title>
    <link href="/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/23/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="js基础-—-js字符串方法"><a href="#js基础-—-js字符串方法" class="headerlink" title="js基础 — js字符串方法"></a>js基础 — js字符串方法</h2><ol><li>round floor ceil parseInt parseFloat区别<br>round 四舍五入，返回参数+0.5后，向下取整<br>floor 返回小于等于参数的最大整数<br>ceil  返回大于等于参数的最小整数<br>parseInt 解析一个字符串，并返回一个整数 返回舍去参数的小数部分后的整数<br>parseFloat  解析一个字符串，并返回一个浮点数</li></ol><h2 id="整理字符串和数组常用方法"><a href="#整理字符串和数组常用方法" class="headerlink" title="整理字符串和数组常用方法"></a>整理字符串和数组常用方法</h2><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="查找字符串的方法"><a href="#查找字符串的方法" class="headerlink" title="查找字符串的方法"></a>查找字符串的方法</h4><ul><li><p>indexOf() 返回字符串中指定文本首次出现的索引index 没找到返回 -1 第二个参数为检索起始位置  不可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.indexOf(<span class="hljs-string">&quot;china&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure></li><li><p>lastIndexOf() 返回字符串中指定文本最后一次出现的索引 index 没找到返回 -1 同上</p></li><li><p>search()  方法返回字符串中指定文本第一次出现的位置 无法设置第二个参数  可以设置正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.search(<span class="hljs-string">&quot;China&quot;</span>)   =&gt; <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="提取字符串的方法"><a href="#提取字符串的方法" class="headerlink" title="提取字符串的方法"></a>提取字符串的方法</h4><ul><li><p>slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。</p><ul><li>如果参数是负数，则从字符串的结尾开始计数</li><li>如果省略第二个参数，则该方法将裁剪字符串的剩余部分</li><li>从结尾计数，也是裁剪字符串的剩余部分</li></ul></li><li><p>substring(start, end) 类似于slice() 不过不能接受负的索引</p></li><li><p>substr(start, length) 类似于slice() 第二个参数规定被提取部分的长度</p></li></ul><h4 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h4><ul><li>replace() <ul><li>replace()方法不会改变调用它的字符串 它返回的是新字符串</li><li>replace()只替换首个匹配</li><li><a href="https://www.w3school.com.cn/js/js_string_methods.asp">https://www.w3school.com.cn/js/js_string_methods.asp</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为机试算法题.md</title>
    <link href="/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/19/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>计算某字母key出现在指定字符串str中的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = readline().toLowerCase();<br><span class="hljs-keyword">var</span> key = readline().toLowerCase();<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>count = str.split(key).length - <span class="hljs-number">1</span>;<br>print(count)<br></code></pre></td></tr></table></figure></li><li><p>动态规划  dp0-1 钱包问题  （动态规划 =》 将大问题转变成小问题的和 类似dfs）</p><h2 id="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"><a href="#现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品" class="headerlink" title="现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品"></a>现有四个物品，小拓扑背包总容量为8，怎么偷得最大价值的物品</h2><p>物品编号   1  2  3  4<br>物品重量   2  3  4  5</p><h2 id="物品价值-3-4-5-6"><a href="#物品价值-3-4-5-6" class="headerlink" title="物品价值   3  4  5  6"></a>物品价值   3  4  5  6</h2><p>解：记f(k,w)  背包容量为w，有k件物品可以偷，所能偷到的最大价值</p><p>状态转移方程<br>f(k,w) = f(k-1,w)  when wk&gt;w  当第k个物品的重量大于背包容量 等于k-1物品里 偷总重量不超过w的的最大价值<br>f(k,w) = max{ f(k-1,w-wk)+vk,f(k-1,w) }  when wk&lt;=w 当k物品不重于背包容量的话，可以选择偷和不偷  偷的话 最大价值转变成 从k-1个物品里偷重量不超w-k物品的重量  不偷的话 转变成 从k-1个物品里偷w重量的最大价值</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>socket简单上手</title>
    <link href="/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/2021/12/26/socket%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="socket-简单上手"><a href="#socket-简单上手" class="headerlink" title="socket 简单上手"></a>socket 简单上手</h2><blockquote><p>利用express和socket实现一个简易的聊天室 日后可持续添加新功能</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>只需基于node的express框架搭建出一个包含表单和消息列表的html页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm init -y  <span class="hljs-comment">// 初始化package.json文件以安装node框架</span><br>npm i express  <span class="hljs-comment">// 安装express框架</span><br></code></pre></td></tr></table></figure><h3 id="创建服务后台"><a href="#创建服务后台" class="headerlink" title="创建服务后台"></a>创建服务后台</h3><p>利用express提供的能力搭建后台 </p><ul><li>初始化 app 作为 HTTP 服务器的回调函数</li><li>监听3000端口 </li><li>定义了首页路由 <strong>/</strong> </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)();<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).Server(app);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  res.sendFile(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>&#125;);<br><br>http.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening on *:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="添加socket-io"><a href="#添加socket-io" class="headerlink" title="添加socket.io"></a>添加socket.io</h3><p>安装socket.io</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i socket.io<br></code></pre></td></tr></table></figure><h4 id="在index-js中添加socket模块"><a href="#在index-js中添加socket模块" class="headerlink" title="在index.js中添加socket模块"></a>在index.js中添加socket模块</h4><ul><li>通过传入http对象初始化了一个socket.io的实例 </li><li>监听connection事件来接收sockets，并将连接信息打印在console</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(http);<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在index-html-的-标签中添加socket-io-client"><a href="#在index-html-的-标签中添加socket-io-client" class="headerlink" title="在index.html 的  标签中添加socket-io-client"></a>在index.html 的 </body> 标签中添加socket-io-client</h4><p>socket.io-client 暴露了一个 io 全局变量，然后连接服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> socket = io(); <span class="hljs-comment">// 请注意我们在调用 io() 时没有指定任何 URL,因为它默认将尝试连接到提供当前页面的主机</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// io这里可以传入参数（可以log一下参数），参数是当前Socket的所有信息</span></span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="监听connection和disconnect事件"><a href="#监听connection和disconnect事件" class="headerlink" title="监听connection和disconnect事件"></a>监听connection和disconnect事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-comment">// 这里的socket可以拿到socket相关参数 比如每个socket连接的id 区分不同连接的用户</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a user connected&#x27;</span>);<br>  socket.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user disconnected&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="手动触发自定义事件"><a href="#手动触发自定义事件" class="headerlink" title="手动触发自定义事件"></a>手动触发自定义事件</h3><blockquote><p>比如发送消息</p></blockquote><p>当用户输入消息时，服务器接收一个 chat message 事件<br>此处类似vue的事件触发，socket.emit 触发自定义事件并传入参数</p><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-1.11.1.js&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;external nofollow&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> socket = io();</span></span><br><span class="javascript"><span class="xml">    $(<span class="hljs-string">&#x27;form&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">      socket.emit(<span class="hljs-string">&#x27;chat message&#x27;</span>, $(<span class="hljs-string">&#x27;#m&#x27;</span>).val());</span></span><br><span class="javascript"><span class="xml">      $(<span class="hljs-string">&#x27;#m&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;);</span></span><br><span class="javascript"><span class="xml">  &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><p>监听client端的自定义事件：此处事件名为 chat message</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;message: &#x27;</span> + msg);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="socket也提供了广播功能"><a href="#socket也提供了广播功能" class="headerlink" title="socket也提供了广播功能"></a>socket也提供了广播功能</h3><p>让服务器将消息发送给其他用户</p><p>要将事件发送给每个用户，Socket.IO 提供了 io.emit 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">io.emit(<span class="hljs-string">&#x27;some event&#x27;</span>, &#123; <span class="hljs-attr">for</span>: <span class="hljs-string">&#x27;everyone&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>要将消息发给除特定 socket 外的其他用户，可以用 broadcast 标志</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  socket.broadcast.emit(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在client端监听"><a href="#在client端监听" class="headerlink" title="在client端监听"></a>在client端监听</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">socket.on(<span class="hljs-string">&#x27;chat message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>  $(<span class="hljs-string">&#x27;#messages&#x27;</span>).append($(<span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span>).text(msg));<br>&#125;);<br></code></pre></td></tr></table></figure><p>至此：简单的socket上手已完成</p>]]></content>
    
    
    <categories>
      
      <category>Socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题HTML&amp;CSS</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98HTML-CSS/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍下-BFC-及其应用"><a href="#介绍下-BFC-及其应用" class="headerlink" title="介绍下 BFC 及其应用"></a>介绍下 BFC 及其应用</h3><p>BFC(Block Formarting Context) 块级格式化上下文 TODO:</p><h3 id="property和attribute的区别"><a href="#property和attribute的区别" class="headerlink" title="property和attribute的区别"></a>property和attribute的区别</h3><p>property是dom元素对象的一个属性，是js里面的对象 值可以是对象、数组在内的任何类型<br>attribute是html标签上的属性，值只能是字符串</p><p>建议使用property，因为attribute的每次修改都会触发页面重绘</p><h3 id="怎么让一个-div-水平垂直居中"><a href="#怎么让一个-div-水平垂直居中" class="headerlink" title="怎么让一个 div 水平垂直居中"></a>怎么让一个 div 水平垂直居中</h3><ol><li>margin+定位<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50%</span>*width;<br><span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50%</span>*height;<br></code></pre></td></tr></table></figure></li><li>定位+transform<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br></code></pre></td></tr></table></figure></li><li>margin:auto<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">margin</span>: auto;<br></code></pre></td></tr></table></figure></li><li>flex<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">justify-content</span>: center;<br><span class="hljs-attribute">align-items</span>: center;<br></code></pre></td></tr></table></figure></li><li>grid<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* father */</span><br><span class="hljs-attribute">display</span>:grid;<br><span class="hljs-comment">/* child */</span><br>justify-self: center;<br><span class="hljs-attribute">align-self</span>: center;<br></code></pre></td></tr></table></figure></li></ol><h3 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h3><ol><li>默认模式下，当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档</li><li>async模式，当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。（<strong>可能阻断html解析</strong>）</li><li>defer模式，当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。（有顺序）脚本依赖于dom文档中元素时（<strong>完全不会阻断</strong> ）</li></ol><h3 id="从浏览器地址栏输入-url-到请求返回发生了什么"><a href="#从浏览器地址栏输入-url-到请求返回发生了什么" class="headerlink" title="从浏览器地址栏输入 url 到请求返回发生了什么"></a>从浏览器地址栏输入 url 到请求返回发生了什么</h3><p>TODO:  补充</p><ol><li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求</li><li>DNS 域名解析</li><li>TCP 连接</li><li>http 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器渲染页面</li><li>断开 TCP 连接</li></ol><h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认<strong>客户端</strong>的<strong>发送</strong>能力，第二次握手，确认了<strong>服务端</strong>的<strong>发送</strong>能力和<strong>接收</strong>能力，所以第三次握手才可以确认<strong>客户端</strong>的<strong>接收</strong>能力。不然容易出现丢包的现象。</p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>区别在于盒子内容宽/高度不同</p><ul><li>标准盒模型  ：  content</li><li>IE盒模型   ：  content + padding + border<br>切换方式：box-sizing<br>content-box: 标准盒<br>border-box:  IE盒</li></ul><h3 id="重排-reflow-和-重绘-repaint"><a href="#重排-reflow-和-重绘-repaint" class="headerlink" title="重排 reflow 和 重绘 repaint"></a>重排 reflow 和 重绘 repaint</h3><p>重排： 几何信息变化（位置和大小）<br>重绘： 将渲染树的每个节点都转化为屏幕上的实际像素</p><blockquote><p>如何减小重排和重绘<br>最小化重绘和重排，用类名class改样式<br>批量操作dom 减少offsetWidth等计算属性的使用，可用临时变量保存<br>开启GPU加速 tranform或will-change属性，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</p></blockquote><h3 id="主页置灰效果"><a href="#主页置灰效果" class="headerlink" title="主页置灰效果"></a>主页置灰效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs style">html &#123;<br>    -webkit-filter: grayscale(100%);<br>    /* Chrome, Safari, Opera */<br>    filter: grayscale(100%);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题VUE篇</title>
    <link href="/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/"/>
    <url>/2021/12/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98VUE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h2><h3 id="Vue-的最大的优势是什么"><a href="#Vue-的最大的优势是什么" class="headerlink" title="Vue 的最大的优势是什么"></a>Vue 的最大的优势是什么</h3><ol><li>数据可以双向绑定  mvvm</li><li>组件化开发</li><li>单页面应用，减少后台请求</li><li>第三方库比较好用</li></ol><h3 id="mvvm-和-mvc-区别是什么"><a href="#mvvm-和-mvc-区别是什么" class="headerlink" title="mvvm 和 mvc 区别是什么"></a>mvvm 和 mvc 区别是什么</h3><ul><li>mvvm(model view viewmodel) </li></ul><p>viewModel是核心<br>可以将model-&gt;view  by数据绑定 ；<br>可以将view-&gt;model  bydom事件监听  即 双向绑定</p><ul><li>mvc(model view controller)<br>c-&gt;vm vm是从c中抽离业务逻辑 相当于是在c基础上封装了一层</li></ul><h3 id="Vue-数据双向绑定的原理是什么"><a href="#Vue-数据双向绑定的原理是什么" class="headerlink" title="Vue 数据双向绑定的原理是什么"></a>Vue 数据双向绑定的原理是什么</h3><p>数据劫持结合发布者-订阅者模式<br>数据劫持 Observer<br>Dep 收集订阅者</p><p>Object.defineProperty()<br>待补充</p><h3 id="Object-defineProperty-和-Proxy-的区别"><a href="#Object-defineProperty-和-Proxy-的区别" class="headerlink" title="Object.defineProperty 和 Proxy 的区别"></a>Object.defineProperty 和 Proxy 的区别</h3><ul><li>proxy</li></ul><ul><li>Object.defineProperty</li></ul><h3 id="Vue的生命周期-（现在有11个）"><a href="#Vue的生命周期-（现在有11个）" class="headerlink" title="Vue的生命周期  （现在有11个）"></a>Vue的生命周期  （现在有11个）</h3><ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>activated        keep-alive激活时调用</li><li>deactivated      keep-alive停用时调用</li><li>beforeDestory</li><li>destoryed</li><li>errorCaptured   捕获到子孙组件的错误时调用</li></ol><p>了解各部分是干啥的</p><h3 id="组件之间是如何传值的"><a href="#组件之间是如何传值的" class="headerlink" title="组件之间是如何传值的"></a>组件之间是如何传值的</h3><p>父子组件: props $emit<br>祖孙组件: provide inject<br>兄弟组件: eventbus<br>其他方式: vuex</p><h3 id="data为啥必须是函数"><a href="#data为啥必须是函数" class="headerlink" title="data为啥必须是函数"></a>data为啥必须是函数</h3><p>确保vue的各个实例之间的数据不会相互影响 – TODO:可优化说辞</p><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p><h3 id="data-compute-watch之间有什么依赖关系"><a href="#data-compute-watch之间有什么依赖关系" class="headerlink" title="data compute watch之间有什么依赖关系"></a>data compute watch之间有什么依赖关系</h3><h3 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h3><h3 id="插槽相关"><a href="#插槽相关" class="headerlink" title="插槽相关"></a>插槽相关</h3><h3 id="怎么监听路由参数的变化"><a href="#怎么监听路由参数的变化" class="headerlink" title="怎么监听路由参数的变化"></a>怎么监听路由参数的变化</h3><ul><li>watch $route(to, from)</li><li>beforeRouteUpdate(to, from, next)</li></ul><h3 id="如何显示组件缓存"><a href="#如何显示组件缓存" class="headerlink" title="如何显示组件缓存"></a>如何显示组件缓存</h3><p>keep-alive – TODO: 详细补充下</p><h3 id="常用的修饰符"><a href="#常用的修饰符" class="headerlink" title="常用的修饰符"></a>常用的修饰符</h3><ul><li>prevent</li><li>stop</li><li>self</li><li>capture</li></ul><h3 id="封装过-Vue-的组件吗"><a href="#封装过-Vue-的组件吗" class="headerlink" title="封装过 Vue 的组件吗"></a>封装过 Vue 的组件吗</h3><p>☆</p><h3 id="Vue踩过的坑"><a href="#Vue踩过的坑" class="headerlink" title="Vue踩过的坑"></a>Vue踩过的坑</h3><ul><li>给data中的对象直接添加属性并赋值 无效果<br>解决方法：Vue.set(object, attribute, value)新增的属性也是响应式的</li><li>在created中操作dom报错，无法获取到dom<br>解决方法：Vue.nextTick()</li></ul><h3 id="Vue-渲染模板时怎么保留模板中的-HTML-注释呢"><a href="#Vue-渲染模板时怎么保留模板中的-HTML-注释呢" class="headerlink" title="Vue 渲染模板时怎么保留模板中的 HTML 注释呢"></a>Vue 渲染模板时怎么保留模板中的 HTML 注释呢</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template comments&gt; ... &lt;/template&gt;<br><span class="hljs-comment">// 将组件中comments选项设置为true即可</span><br></code></pre></td></tr></table></figure><h3 id="Vue的template编译的理解"><a href="#Vue的template编译的理解" class="headerlink" title="Vue的template编译的理解"></a>Vue的template编译的理解</h3><p>简单说： 先转化成AST树，再得到render函数，并返回VNode<br>详细版:</p><h3 id="Vue的两种路由模式-hash和history"><a href="#Vue的两种路由模式-hash和history" class="headerlink" title="Vue的两种路由模式 hash和history"></a>Vue的两种路由模式 hash和history</h3><ol><li>hash模式，就是连接中有#的，#后面的被称为hash，hash虽然在url中，但是不包括在HTTP请求中，hash变化也不会重新加载页面</li><li>history模式，采用h5新特性，切提供了两个新方法：pushState和replaceState可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</li></ol><h3 id="route-和-router-的区别是什么"><a href="#route-和-router-的区别是什么" class="headerlink" title="$route 和$router 的区别是什么"></a>$route 和$router 的区别是什么</h3><ul><li>$route 是路由信息对象，包括一些路由信息参数如。path, params, hash, query, fullPath, matched, name</li><li>$router 是VueRouter的实例，相当于一个全局的路由器对象，包含很多属性和子对象，如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)</li></ul><h3 id="vue-router官网记录"><a href="#vue-router官网记录" class="headerlink" title="vue router官网记录"></a>vue router官网记录</h3><p>router文件中必须要有routes，路由数组：存放多个不同路由(放的是路由信息)，对应上面的$route</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>   &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,<br>      <span class="hljs-attr">component</span>: AboutComponent<br>   &#125;<br>]<br></code></pre></td></tr></table></figure><p>router实例是VueRouter这个插件的实例，routes路由信息是传给router实例的配置参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>   <span class="hljs-attr">routes</span>: routes<br>&#125;)<br></code></pre></td></tr></table></figure><p>创建并挂在根实例，记得要通过router配置参数注入路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>   router<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由</p><p>routes的meta字段是路由元信息<br>一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.some(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>https://v3.router.vuejs.org/zh/guide/advanced/data-fetching.html#%E5%AF%BC%E8%88%AA%E5%AE%8C%E6%88%90%E5%90%8E%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE</code></p><h3 id="Vue-Router的动态路由，怎么获取传过来的动态参数-☆"><a href="#Vue-Router的动态路由，怎么获取传过来的动态参数-☆" class="headerlink" title="Vue-Router的动态路由，怎么获取传过来的动态参数 ☆"></a>Vue-Router的动态路由，怎么获取传过来的动态参数 ☆</h3><p>场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染<br>动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配<br>到一个路由时，参数会被设置到 this.$router.params 中，并且可以在每个组件<br>中使用。<br>like this: <code>&#123; path: &#39;/user/:id&#39;, component: User &#125;</code><br>在匹配到该路由之后，动态参数会被设置到this.$route.params<br><code>template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;</code><br>也可以是多个参数<br>like this: <code>/user/:username/post/:post_id</code> 与路由一一对应</p><h3 id="Vue-Router-的钩子函数都有哪些"><a href="#Vue-Router-的钩子函数都有哪些" class="headerlink" title="Vue-Router 的钩子函数都有哪些"></a>Vue-Router 的钩子函数都有哪些</h3><p>即 路由守卫 记住，在任务导航守卫中都要触发next函数<br>主要分为三类</p><ol><li>全局钩子beforeEach(to,from,next:function) beforeResolve afterEach</li><li>路由独享钩子 beforeEnter  // 在routes数组中给某个特定的route单独设置路由狗子，参数一致</li><li>组件内钩子<ul><li>beforeRouterEnter // 不！能！获取组件实例 <code>this</code></li><li>beforeRouterUpdate // 在当前路由改变，但是该组件被复用时调用 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候</li><li>beforeRouterLeave // 导航离开该组件的对应路由时调用 可以访问组件实例 <code>this</code> （禁止用户在还未保存修改前突然离开）</li><li>用处：一般用的是beforeEach，可以判断用户身份，未登录则导航到Login页面<h3 id="路由传值的方式有哪几种"><a href="#路由传值的方式有哪几种" class="headerlink" title="路由传值的方式有哪几种"></a>路由传值的方式有哪几种</h3></li></ul></li></ol><p>params<br>query</p><h3 id="vue组件的定时器怎么销毁"><a href="#vue组件的定时器怎么销毁" class="headerlink" title="vue组件的定时器怎么销毁"></a>vue组件的定时器怎么销毁</h3><ul><li>如果页面上有很多个定时器，在data选项中添加一个timer对象，给每个定时器去一个名字一一映射在对象timer中，然后在beforeDestory函数中for循环clearInterval掉</li><li>如果只有一个定时器，可以用<code>this.$once(&#39;hook:beforeDestory&#39;,()=&gt;&#123; clearInterval(timer) &#125;)</code></li></ul><h3 id="Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"><a href="#Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法" class="headerlink" title="Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"></a>Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法</h3><blockquote><p>可以触发更新</p></blockquote><ul><li><p>push()</p></li><li><p>pop()</p></li><li><p>unshift()</p></li><li><p>shift()</p></li><li><p>splice()</p></li><li><p>sort()</p></li><li><p>reverse()</p></li><li><p>filter()</p></li><li><p>concat()</p></li><li><p>slice()</p></li></ul><blockquote><p>不可以触发更新</p></blockquote><ul><li>直接利用索引设置新数组值  this.arr[index] = newV;</li><li>直接修改数组的长度  this.arr.length = newL;</li></ul><blockquote><p>解决第一种</p></blockquote><p>this.$set(this.aarr,index,newValue)<br>this.arr.splice(index,1,newValue)</p><blockquote><p>解决第二种</p></blockquote><p>this.arr.splice(newLength)</p><h3 id="怎么重置Vue中的data"><a href="#怎么重置Vue中的data" class="headerlink" title="怎么重置Vue中的data"></a>怎么重置Vue中的data</h3><p>Object.assign(target, source) 方法用于将所有可枚举属性的值从一个或多个源对<br>象复制到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.$data, <span class="hljs-built_in">this</span>.$options.data(<span class="hljs-built_in">this</span>))<br></code></pre></td></tr></table></figure><h3 id="Vue首屏加载优化"><a href="#Vue首屏加载优化" class="headerlink" title="Vue首屏加载优化"></a>Vue首屏加载优化</h3><ul><li>不常改变的库放到index.html中，用cdn引入</li><li>路由懒加载</li><li>不生成map文件</li><li>vue组件尽量不全局引入</li><li>开启gzip压缩</li><li>首页单独做服务端渲染</li></ul><h3 id="Vue的nextTick原理"><a href="#Vue的nextTick原理" class="headerlink" title="Vue的nextTick原理"></a>Vue的nextTick原理</h3><p>如果需要必须对数据更改并刷新后的DOM做处理时</p><blockquote><p>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中</p></blockquote><p>原理：利用异步队列</p><p>在每个 macro-task 运行完以后，UI 都会重渲染，那么在 micro-task （异步事件回调） 中就完成数据更新，当前 次事件循环 结束就可以得到最新的 UI 了。反之如果新建一个 macro-task 来做数据更新，那么渲染就会进行两次。</p><p>总结</p><ol><li>vue用异步队列的方式来控制DOM更新和nextTick回调先后执行</li><li>micro-task因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li><li>因为兼容性问题，vue不得不做了microtask向macrotask的降级方案</li></ol><h3 id="mixin用过吗"><a href="#mixin用过吗" class="headerlink" title="mixin用过吗"></a>mixin用过吗</h3><h3 id="虚拟dom的介绍及其优点"><a href="#虚拟dom的介绍及其优点" class="headerlink" title="虚拟dom的介绍及其优点"></a>虚拟dom的介绍及其优点</h3><h3 id="vue底层是怎么实现对数组的监听的"><a href="#vue底层是怎么实现对数组的监听的" class="headerlink" title="vue底层是怎么实现对数组的监听的"></a>vue底层是怎么实现对数组的监听的</h3><h3 id="待丰富"><a href="#待丰富" class="headerlink" title="待丰富"></a>待丰富</h3><p>Vue-Router的动态路由，怎么获取传过来的动态参数</p><p>路由传值的方式有哪几种</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue, 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题JS篇</title>
    <link href="/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/"/>
    <url>/2021/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98JS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="JS基础篇"><a href="#JS基础篇" class="headerlink" title="JS基础篇"></a>JS基础篇</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><code>var reg = /^(A|D|W|S)&#123;1&#125;[0-9]&#123;1,2&#125;$/;</code></p><h3 id="padStart、padEnd、parseInt的第二参数"><a href="#padStart、padEnd、parseInt的第二参数" class="headerlink" title="padStart、padEnd、parseInt的第二参数"></a>padStart、padEnd、parseInt的第二参数</h3><p>padStart的第一参数n 是指将目标字符串用第二参数c扩充到n位（是一共n位 不是n个c）<br>parseInt第二参数是 将第一个参数以几进制转换2-36</p><h3 id="手写js深拷贝"><a href="#手写js深拷贝" class="headerlink" title="手写js深拷贝"></a>手写js深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 这边留意 双等号意味着既不是null也不是undefined</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-comment">// 初始化返回值</span><br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 核心</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span>(obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 递归调用 这边要反复看 自己默写的是result</span><br>      result[item] = deepClone(obj[item])<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归可以深入研究下 添加到toDo中 递归理不清的问题</p></blockquote><h3 id="typeof的用法"><a href="#typeof的用法" class="headerlink" title="typeof的用法"></a>typeof的用法</h3><ol><li>可以返回所有的基本数据类型 undefined string number boolean</li><li>引用数据类型只能返回object，不能具体区分是array还是object</li><li>typeof function返回值就是function<br>举例：typeof(class c{}) 也是function</li></ol><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>题目：</p><ol><li>如何准确判断一个变量是不是数组</li><li>手写一个jquery，考虑插件和扩展性</li><li>class的原型本质，怎么理解</li></ol><h3 id="class的用法"><a href="#class的用法" class="headerlink" title="class的用法"></a>class的用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 构造函数 就是在初始化新实例/对象的时候执行的方法</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.num = num;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, 学号：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.num&#125;</span>`</span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> xialuo = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;夏洛&quot;</span>,<span class="hljs-number">120</span>);<br>xialuo.sayHi();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-comment">// 继承 调用super函数 处理父亲有的参数</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,num,gender</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name,num);<br>    <span class="hljs-comment">// 自己独有的自己绑定</span><br>    <span class="hljs-built_in">this</span>.gender = gender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有哪几种继承方式"><a href="#有哪几种继承方式" class="headerlink" title="有哪几种继承方式"></a>有哪几种继承方式</h3><h3 id="instanceof进行类型判断"><a href="#instanceof进行类型判断" class="headerlink" title="instanceof进行类型判断"></a>instanceof进行类型判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xialuo <span class="hljs-keyword">instanceof</span> Student <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="节流防抖代码实现"><a href="#节流防抖代码实现" class="headerlink" title="节流防抖代码实现"></a>节流防抖代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,threshold = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-number">0</span>;<br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span>(current - start &gt;= threshold) &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments);<br>      start = current;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), threshold, ...arguments);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 防抖</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span> (<span class="hljs-params">fn, delay = <span class="hljs-number">200</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 重新计时</span><br>    timeout &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(fn.bind(<span class="hljs-built_in">this</span>), delay, ...arguments);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ol><li>每个class都有显式原型prototype</li><li>每个class实例化后的对象都有隐式原型__proto__</li><li>实例的隐式原型指向对应class的显式原型</li><li>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.<strong>proto</strong> === Student.proptotype</li></ol><p><img src="../../../../img/prototype.png" alt="原型图"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>闭包指一个函数有权访问另一个函数作用域中的变量</p><h4 id="创建闭包的常见方法"><a href="#创建闭包的常见方法" class="headerlink" title="创建闭包的常见方法"></a>创建闭包的常见方法</h4><p>创建闭包最常见方式，就是在一个函数内部创建另一个函数</p><h4 id="闭包的表现"><a href="#闭包的表现" class="headerlink" title="闭包的表现"></a>闭包的表现</h4><ol><li>函数作为参数被传递<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = create()<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>fn() <span class="hljs-comment">// log值为100</span><br></code></pre></td></tr></table></figure></li><li>函数作为返回值被返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span><br>  fn()<br>&#125;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br>print(fn) <span class="hljs-comment">// 打印值仍为100</span><br></code></pre></td></tr></table></figure><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4></li></ol><ul><li>封装变量（在function中定义私有变量，return一个function，变量即不会被拿到或修改）</li></ul><blockquote><p>所有（闭包）自由变量的查找  是在函数<strong>定义</strong>的地方，向上级作用域查找 不是在执行的地方</p></blockquote><h4 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h4><ol><li>隐藏数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 闭包cache  数据隐藏</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = &#123;&#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,val</span>) </span>&#123;<br>      data[key] = val<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> data[key]<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> c = createCache()<br>c.set(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(c.get(<span class="hljs-string">&quot;a&quot;</span>))<br></code></pre></td></tr></table></figure></li><li>循环绑定事件<br>for循环中给标签添加监听事件addEventListener<br>调用的时候循环已经结束 调用时的增量i为循环结束时i的取值了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="this的使用场景"><a href="#this的使用场景" class="headerlink" title="this的使用场景"></a>this的使用场景</h3><ol><li>作为普通函数  window</li><li>使用call bind apply （三个的区别 call可直接换this指向 bind是有返回值 返回值再调用）</li><li>作为对象方法被调用   指代的就是这个对象本身</li><li>在class方法中调用   当前实例本身 setTimeout注意</li><li>箭头函数 ()=&gt;{this} 和上级作用域的值一致<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对应上方点2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br>fn1.call(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;) <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-keyword">const</span> fn2 = fn1.bind(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;)<br>fn2(); <span class="hljs-comment">// &#123;x:100&#125;</span><br><span class="hljs-function"><span class="hljs-title">setTimeout</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// this === window</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>this取什么值是在函数被<strong>执行</strong>的时候确定的，不是在定义的时候</p></blockquote><h4 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h4><h5 id="手写bind函数"><a href="#手写bind函数" class="headerlink" title="手写bind函数"></a>手写bind函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// bind function</span><br><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将参数拆分成数组</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-comment">// 获取this</span><br>  <span class="hljs-keyword">const</span> t = args.shift()<br>  <span class="hljs-comment">// fn1.bind(...) 中的 fn1 实例</span><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span><br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> self.apply(t,args)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><blockquote><p>基于js是单线程语言  callback回调<br>异步不会阻塞代码执行<br>同步会阻塞代码执行</p></blockquote><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="同步异步的区别是什么"><a href="#同步异步的区别是什么" class="headerlink" title="同步异步的区别是什么"></a>同步异步的区别是什么</h5><p>异步不会阻塞代码执行<br>同步会阻塞代码执行</p><h5 id="手写用promise加载一张图片"><a href="#手写用promise加载一张图片" class="headerlink" title="手写用promise加载一张图片"></a>手写用promise加载一张图片</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImg</span>(<span class="hljs-params">src</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;img&quot;</span>)<br>      img.onload = <span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(img)<br>      &#125;<br>      img.onerror = <span class="hljs-function">() =&gt;</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>))<br>      &#125;<br>      img.src = src<br>    &#125;<br>  )<br>&#125;<br>loadImg(url).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.width)<br>  <span class="hljs-keyword">return</span> img <span class="hljs-comment">// 普通对象 loadImg返回的对象值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(img.height)<br>  <span class="hljs-keyword">return</span> loadImg(url2)  <span class="hljs-comment">// 返回的是new promise 后面的then取到的loadImg请求的返回值</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">img2</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h5 id="前端使用异步的场景有哪些"><a href="#前端使用异步的场景有哪些" class="headerlink" title="前端使用异步的场景有哪些"></a>前端使用异步的场景有哪些</h5><p>请求后台数据</p><h2 id="JS异步-进阶"><a href="#JS异步-进阶" class="headerlink" title="JS异步-进阶"></a>JS异步-进阶</h2><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><ul><li>event loop过程1<ul><li>同步代码，一行一行放在call Stack执行</li><li>遇到异步，会先记录下，等待时机（定时，网络请求）</li><li>时机到了，就会移动到callback queue</li></ul></li><li>event loop过程2<ul><li>如果call stack为空（同步代码执行完），event loop开始工作</li><li>轮训查找callback queue，如果有则移动到call stack</li><li>然后继续轮训查找</li></ul></li></ul><h3 id="dom事件与event-loop关系"><a href="#dom事件与event-loop关系" class="headerlink" title="dom事件与event loop关系"></a>dom事件与event loop关系</h3><ol><li>js是单线程的</li><li>异步都是基于event loop的</li><li>dom事件也使用回调，也是基于event loop</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).on(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">// 注意这里的click是立即执行的，但是function会被立刻放到webapi的库中，</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;btn clicked&#x27;</span>); <span class="hljs-comment">// 当用户点击click时，function会被放入到callback queue中</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><ul><li>宏任务<ul><li>setTimeout</li><li>setImmediate</li><li>setInterval</li><li>requestAnimationFrame</li><li>I/O</li><li>UI rendering</li></ul></li><li>微任务<ul><li>process.nextTick</li><li>promise (then)</li><li>object.observe</li><li>mutationObserve</li></ul></li></ul><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h3 id="箭头函数的优点"><a href="#箭头函数的优点" class="headerlink" title="箭头函数的优点"></a>箭头函数的优点</h3><ol><li>简洁的语法</li><li>可以隐式返回，可省略大括号和return，减少代码量</li><li>this的指向问题，箭头函数内的 this 是词法绑定的，与外层函数保持一致</li></ol><h3 id="箭头函数的缺点"><a href="#箭头函数的缺点" class="headerlink" title="箭头函数的缺点"></a>箭头函数的缺点</h3><ol><li>做为构造函数的时候不能使用箭头函数</li><li>真正需要this的时候如给元素绑定click事件的时候,执行的回调函数不能使用箭头函数。</li><li>我们需要使用arguments对象的时候不能使箭头函数。箭头函数中没有arguments对象。</li><li>对象的方法也不可以使用箭头函数</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试,</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6常用技巧</title>
    <link href="/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/11/25/ES6%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="对象取值方式"><a href="#对象取值方式" class="headerlink" title="对象取值方式"></a>对象取值方式</h3><blockquote><p>用解构赋值的方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj;<br><span class="hljs-keyword">const</span> res = a + b; <br></code></pre></td></tr></table></figure><p>如果想创建的变量名和对象的属性名不一致，可用取别名的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">a</span>:myName&#125; = obj;<br></code></pre></td></tr></table></figure><blockquote><p>注意：解构的对象不能为undefined和null，会报错<br>可以给一个默认值：空对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;a,b,c&#125; = obj || &#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并数据方式"><a href="#合并数据方式" class="headerlink" title="合并数据方式"></a>合并数据方式</h3><p>一般方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// array</span><br><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> c = a.concat(b);<br><span class="hljs-comment">// object</span><br><span class="hljs-keyword">const</span> d = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> e = &#123;<br>  <span class="hljs-attr">f</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> g = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,d,e)<span class="hljs-comment">//a:1,f:1 注意Object.assign是浅拷贝</span><br></code></pre></td></tr></table></figure><p>ES6方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> c = [...new <span class="hljs-built_in">Set</span>([...a,...b])];<br><span class="hljs-keyword">const</span> g = &#123;...d,...e&#125; <span class="hljs-comment">//解构赋值也是浅拷贝</span><br></code></pre></td></tr></table></figure><h3 id="if中判断条件"><a href="#if中判断条件" class="headerlink" title="if中判断条件"></a>if中判断条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span> || type == <span class="hljs-number">2</span> || type == <span class="hljs-number">3</span> ) &#123;...&#125;<br><span class="hljs-comment">// 改进之后 用es6新增的includes方法</span><br><span class="hljs-keyword">const</span> condition = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">if</span>(condition.includes(type))<br></code></pre></td></tr></table></figure><h3 id="获取对象属性值的方法"><a href="#获取对象属性值的方法" class="headerlink" title="获取对象属性值的方法"></a>获取对象属性值的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = obj &amp;&amp; obj.name<br><span class="hljs-comment">// 改进之后 es6的可选链操作符</span><br><span class="hljs-keyword">const</span> name = obj?.name<br></code></pre></td></tr></table></figure><h3 id="输入框非空的判断"><a href="#输入框非空的判断" class="headerlink" title="输入框非空的判断"></a>输入框非空的判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// 改进后 空值合并运算符</span><br><span class="hljs-keyword">if</span>(value ?? <span class="hljs-string">&#x27;&#x27;</span> !== <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="添加动态变化属性名的对象属性"><a href="#添加动态变化属性名的对象属性" class="headerlink" title="添加动态变化属性名的对象属性"></a>添加动态变化属性名的对象属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> key = <span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>;<br>obj[key] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br><span class="hljs-comment">// 改进之后 对象属性名用表达式</span><br>obj[<span class="hljs-string">`topic<span class="hljs-subst">$&#123;index&#125;</span>`</span>] = <span class="hljs-string">&#x27;话题内容&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async和await</title>
    <link href="/2021/11/08/async%E5%92%8Cawait/"/>
    <url>/2021/11/08/async%E5%92%8Cawait/</url>
    
    <content type="html"><![CDATA[<h1 id="async-await要点"><a href="#async-await要点" class="headerlink" title="async await要点"></a>async await要点</h1><ol><li>await 后面可以追加 promise 对象，获取 resolve 的值</li><li>await 必须包裹在 async 函数里面</li><li>async 函数执行返回的也是一个 promise 对象</li><li>try-catch 截获 promise 中 reject 的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>async&amp;await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Virtual DOM理解</title>
    <link href="/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/"/>
    <url>/2021/10/31/Virtual-DOM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><blockquote><p>用原生的JavaScript对象去描述一个DOM节点</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2底层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐分享</title>
    <link href="/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"/>
    <url>/2021/10/31/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h1><blockquote><p>这个文件用来记录喜欢的音乐</p></blockquote><h3 id="To-Be-Continued"><a href="#To-Be-Continued" class="headerlink" title="To Be Continued"></a>To Be Continued</h3><blockquote><p>2022/4/14  生存指南</p></blockquote><blockquote><p>2022/4/18  一样的月光</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AllToDo</title>
    <link href="/2021/10/31/AllToDo/"/>
    <url>/2021/10/31/AllToDo/</url>
    
    <content type="html"><![CDATA[<h1 id="所有的TODO"><a href="#所有的TODO" class="headerlink" title="所有的TODO"></a>所有的TODO</h1><blockquote><p>每次修改完记得提交到github</p></blockquote><p>什么都容易遗忘 基础都得夯实<br>html css js 移动端 webApi jquery node echarts vue react 微信小程序  </p><p>当前最重要任务  <strong>看面试题</strong><br>看面试题书 将重要的写成博客</p><h3 id="blog配置相关"><a href="#blog配置相关" class="headerlink" title="blog配置相关"></a>blog配置相关</h3><ol><li>添加代码提交规范 commitlint插件 + husky插件  10.31</li></ol><h3 id="blog内容相关"><a href="#blog内容相关" class="headerlink" title="blog内容相关"></a>blog内容相关</h3><ol><li>【网络】get和post传值的区别  10.31</li><li>【vue2】promise原理理解（实现代码）  10.31</li><li>【vue2底层】vue2底层学习笔记  10.31</li><li>【js】call方法作用及使用方式  10.31</li><li>【vue】模块化规范-require和import区别 11.8</li><li>【js】常用ES6技巧</li><li>【js】常用深浅拷贝记录</li><li>【基础】递归方法的实现</li><li>【js】手写new函数 bind（面试题已写） call apply 12.14</li><li>【css】@mixin</li><li>【css】用纯html+css3实现轮播图</li><li>【css】grid布局  1.1</li><li>【echarts】至少要用过一些</li></ol><h3 id="可提升方面"><a href="#可提升方面" class="headerlink" title="可提升方面"></a>可提升方面</h3><ol><li>js优化能力： 封装成类   封装成类的能力太弱</li></ol><h3 id="当前任务"><a href="#当前任务" class="headerlink" title="当前任务"></a>当前任务</h3><h4 id="完成一个简易版qq-socket-io-vue-express-mysql"><a href="#完成一个简易版qq-socket-io-vue-express-mysql" class="headerlink" title="完成一个简易版qq   socket.io+vue+express+mysql"></a>完成一个简易版qq   socket.io+vue+express+mysql</h4><p>两个页面 私聊 + 群聊<br>vue create 一个项目出来 完成</p><h4 id="qq项目"><a href="#qq项目" class="headerlink" title="qq项目"></a>qq项目</h4><p>qq前端项目   vue3-qq  注册  登录  聊天  三个页面<br>qq后端express 用express-generator   封装successModel  errorModel 返回请求成功或失败的返回值  参考blog-express  导出module.exports  引入require</p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ToDo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/31/hello-world/"/>
    <url>/2021/10/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>How to publish a new article by hexo</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="How-to-use-Fluid"><a href="#How-to-use-Fluid" class="headerlink" title="How to use Fluid"></a>How to use Fluid</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-string">`markdown`</span> 均可 便签<br>&#123;% endnote %&#125;<br><br>&#123;% label primary @text %&#125;  label<br><br>&#123;% cb text, checked?, incline? %&#125;  checkbox<br><br>&#123;% btn url, text, title %&#125; button<br><br><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
