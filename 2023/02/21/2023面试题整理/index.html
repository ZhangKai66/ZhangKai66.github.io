

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/ultraman.png">
  <link rel="icon" href="/img/ultraman.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="记录学习前端的历程">
  <meta name="author" content="Kai Zhang">
  <meta name="keywords" content="前端,frontend">
  <meta name="description" content="js 手写题手写深拷贝1234567891011121314151617181920212223242526272829303132function deepClone(obj &#x3D; &amp;#123;&amp;#125;) &amp;#123;  &#x2F;&#x2F; 是null或者不是对象和数组 直接返回  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D; null) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="2023面试题整理">
<meta property="og:url" content="https://zhangkai66.github.io.git/2023/02/21/2023%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="ZhangKai&#39;s Blog">
<meta property="og:description" content="js 手写题手写深拷贝1234567891011121314151617181920212223242526272829303132function deepClone(obj &#x3D; &amp;#123;&amp;#125;) &amp;#123;  &#x2F;&#x2F; 是null或者不是对象和数组 直接返回  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D; null) &amp;#123;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-21T08:31:32.000Z">
<meta property="article:modified_time" content="2023-03-15T14:10:11.524Z">
<meta property="article:author" content="Kai Zhang">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
  
  <title>2023面试题整理 - ZhangKai&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhangkai66.github.io.git","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jamarcus</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/beach.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="2023面试题整理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-21 16:31" pubdate>
        February 21, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      41k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      127 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">2023面试题整理</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：6 days ago
                
              </p>
            
            <div class="markdown-body">
              <h2 id="js-手写题"><a href="#js-手写题" class="headerlink" title="js 手写题"></a>js 手写题</h2><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 是null或者不是对象和数组 直接返回</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 保证key不是原型的属性</span><br>      result[item] = deepClone(obj[item]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 方法2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-comment">// 1 判断是否是非应用类型或者null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-comment">// 2 创建一个容器</span><br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor()<br>    <span class="hljs-comment">// 3 拿到对象的keys，给容器赋值</span><br>    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> cloneObj[v] = deepClone(obj[v]))<br>    <span class="hljs-comment">// 4 返回容器</span><br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="手写-call-apply-bind-函数"><a href="#手写-call-apply-bind-函数" class="headerlink" title="手写 call apply bind 函数"></a>手写 call apply bind 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">context, args</span>) </span>&#123;<br>  context = context || <span class="hljs-built_in">window</span><br>  args = args ? args : [];<br>  context.fn = <span class="hljs-built_in">this</span>;<span class="hljs-comment">// this是调用的函数</span><br>  <span class="hljs-keyword">const</span> res = context.fn(...args);<br>  <span class="hljs-keyword">delete</span> context.fn;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 剩下的都一样</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  context = context || <span class="hljs-built_in">window</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">this</span> <br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newFn</span>(<span class="hljs-params">...fnArgs</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> res<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> newFn) &#123;<br>      res = <span class="hljs-keyword">new</span> fn(...args, ...fnArgs)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      res = fn.call(context, ...args, ...fnArgs)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="手写一个简易的jquery，考虑插件和扩展性"><a href="#手写一个简易的jquery，考虑插件和扩展性" class="headerlink" title="手写一个简易的jquery，考虑插件和扩展性"></a>手写一个简易的jquery，考虑插件和扩展性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(Selector);<br>    <span class="hljs-keyword">const</span> length = result.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;length;i++) &#123;<br>      <span class="hljs-built_in">this</span>[i] = result[i]<br>    &#125;<br>    <span class="hljs-built_in">this</span>.length = length<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">index</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[index]<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">each</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.length;i++) &#123;<br>      <span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">this</span>[i];<br>      fn(elem)<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type,fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.each(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> &#123;<br>      elem.addEventListener(type,fn,<span class="hljs-literal">false</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 插件</span><br>jQuery.prototype.dialog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>&#123;<br>  alert(info)<br>&#125;<br><br><span class="hljs-comment">// 造轮子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJquery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(selector);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="手写-new-函数"><a href="#手写-new-函数" class="headerlink" title="手写 new 函数"></a>手写 new 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNew</span>(<span class="hljs-params">Fn, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> newObj = <span class="hljs-built_in">Object</span>.create(Fn);<br>  <span class="hljs-keyword">const</span> res = Fn.apply(newObj, args);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> ? res : newObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newFunc</span>(<span class="hljs-params">father, ...rest</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.__proto__ = father.prototype;<br>  <span class="hljs-keyword">var</span> result2 = father.apply(result, rest);<br>  <span class="hljs-keyword">if</span> (<br>    (<span class="hljs-keyword">typeof</span> result2 === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> result2 === <span class="hljs-string">&#x27;function&#x27;</span>) &amp;&amp;<br>    result2 !== <span class="hljs-literal">null</span><br>  ) &#123;<br>    <span class="hljs-keyword">return</span> result2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件总线-发布订阅模式-event-bus-（EventMitter）"><a href="#事件总线-发布订阅模式-event-bus-（EventMitter）" class="headerlink" title="事件总线 | 发布订阅模式 event bus （EventMitter）"></a>事件总线 | 发布订阅模式 event bus （EventMitter）</h3><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCurried</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args1.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-literal">null</span>, ...args1)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">null</span>, [...args1, ...args2])<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. set</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr)];<br>&#125;<br><span class="hljs-comment">// 2. 双层for循环splice去重</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] == arr[j]) &#123;<br>        <span class="hljs-comment">//第一个等同于第二个，splice方法删除第二个</span><br>        arr.splice(j, <span class="hljs-number">1</span>);<br>        j--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">// 3. 单层for循环加indexOf</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> array = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; arr.length;i++) &#123;<br>    <span class="hljs-keyword">if</span>(array.indexOf(arr[i]) === -<span class="hljs-number">1</span>) &#123;<br>      array.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-comment">// 4. sort之后 前后不同的加入数组</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  arr = arr.sort();<br>  <span class="hljs-keyword">let</span> res = [arr[<span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i&lt;arr.length;i++) &#123;<br>    <span class="hljs-keyword">if</span>(arr[i] !== arr[i-<span class="hljs-number">1</span>]) &#123;<br>      array.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 5. includes</span><br><span class="hljs-comment">// 6. map数据结构去重 把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果</span><br><span class="hljs-comment">//7. filter</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> array.indexOf(item) === index;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">target, origin</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&quot;object&quot;</span> || target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> origin !== <span class="hljs-string">&quot;function&quot;</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;origin must be function&quot;</span>);<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(target); <span class="hljs-comment">// 相当于 proto = target.__proto__;</span><br>  <span class="hljs-keyword">while</span> (proto) &#123;<br>    <span class="hljs-keyword">if</span> (proto === origin.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>TODO:重点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr,depth = <span class="hljs-number">1</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(depth &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> pre.concat(<span class="hljs-built_in">Array</span>.isArray(cur) ? flat(cur,depth - <span class="hljs-number">1</span>) : cur)<br>    &#125;,[])<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.slice()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>不管点多少次 一段时间内只执行一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用时间戳</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> preTime = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> nowTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt; wait) &#123;<br>      func.apply(context, args);<br>      preTime = nowTime;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (!timeout) &#123;<br>      <span class="hljs-comment">// 在timeout这段时间内timer都是存在的，就不会执行func，timeout时间一过就会再次执行</span><br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>不管点多少次 点击结束后一段时间才执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 如果有定时器 就清除定时器啥也不执行，没有定时器后delay秒再执行方法</span><br>    <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-keyword">let</span> callNow = !timeout;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) func.apply(context, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb,initialValue</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">let</span> total = initialValue || arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = initialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    total = cb(total,arr[i],i,arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实现简单的-promise"><a href="#实现简单的-promise" class="headerlink" title="实现简单的 promise"></a>实现简单的 promise</h3><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><h3 id="异步控制并发数"><a href="#异步控制并发数" class="headerlink" title="异步控制并发数"></a>异步控制并发数</h3><h3 id="es5-和-es6-继承"><a href="#es5-和-es6-继承" class="headerlink" title="es5 和 es6 继承"></a>es5 和 es6 继承</h3><h3 id="数组排序-快速排序"><a href="#数组排序-快速排序" class="headerlink" title="数组排序 快速排序"></a>数组排序 快速排序</h3><p>TODO: 背</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>  quickSort(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums);<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">start, end, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>    <span class="hljs-keyword">const</span> mid = sort(start, end, arr);<br>    quickSort(start, mid - <span class="hljs-number">1</span>, arr);<br>    quickSort(mid + <span class="hljs-number">1</span>, end, arr);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">start, end, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> base = arr[start];<br>  <span class="hljs-keyword">let</span> left = start;<br>  <span class="hljs-keyword">let</span> right = end;<br>  <span class="hljs-keyword">while</span> (left !== right) &#123;<br>    <span class="hljs-keyword">while</span> (arr[right] &gt;= base &amp;&amp; right &gt; left) &#123;<br>      right--;<br>    &#125;<br>    arr[left] = arr[right];<br>    <span class="hljs-keyword">while</span> (arr[left] &lt;= base &amp;&amp; right &gt; left) &#123;<br>      left++;<br>    &#125;<br>    arr[right] = arr[left];<br>  &#125;<br>  arr[left] = base;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="获取-url-参数"><a href="#获取-url-参数" class="headerlink" title="获取 url 参数"></a>获取 url 参数</h3><h2 id="html-amp-css-相关"><a href="#html-amp-css-相关" class="headerlink" title="html&amp;css 相关"></a>html&amp;css 相关</h2><h3 id="谷歌浏览器怎么支持小于12px的文字"><a href="#谷歌浏览器怎么支持小于12px的文字" class="headerlink" title="谷歌浏览器怎么支持小于12px的文字"></a>谷歌浏览器怎么支持小于12px的文字</h3><ol>
<li>transform:scale()  推荐这种</li>
<li>zoom：50% css缩小到原来的一半 有兼容问题，会触发重排</li>
</ol>
<h3 id="html5新特性"><a href="#html5新特性" class="headerlink" title="html5新特性"></a>html5新特性</h3><ol>
<li>语义化标签   header footer nav</li>
<li>表单新属性  color date datetime number url search</li>
<li>canvas绘图 </li>
<li>音视频 audio video</li>
<li>svg绘图  可伸缩矢量图</li>
<li>地理定位  getCurrentPosition()获取用户位置</li>
<li>拖放api div draggable=”true”</li>
<li>websocket 全双工通信机制 实时聊天</li>
<li>webworker Web Worker可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。</li>
<li>webstorage localstorage sessionstorage</li>
</ol>
<h3 id="html语义化标签怎么理解"><a href="#html语义化标签怎么理解" class="headerlink" title="html语义化标签怎么理解"></a>html语义化标签怎么理解</h3><ul>
<li>让人更容易读懂</li>
<li>让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息</li>
<li>没有css情况下，也能呈现很好的内容结构</li>
</ul>
<h3 id="script-标签的-defer-和-async-区别"><a href="#script-标签的-defer-和-async-区别" class="headerlink" title="script 标签的 defer 和 async 区别"></a>script 标签的 defer 和 async 区别</h3><p>script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html<br>async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行。async脚本的 下载 不会阻塞页面的解析渲染。async脚本的<strong>执行</strong>会阻塞页面的解析渲染 <strong>异步下载，立即执行</strong><br>defer script: 完全不阻碍html的解析，解析完成后再按照<strong>顺序</strong>执行脚本 <strong>异步下载，解析完执行</strong></p>
<p>区别在于：多个脚本异步载入时，defer会按照文档中排列的顺序按序执行，而async是谁先完成载入谁先执行，是无序的</p>
<h3 id="relative和absolute区别"><a href="#relative和absolute区别" class="headerlink" title="relative和absolute区别"></a>relative和absolute区别</h3><ol>
<li>定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在，而定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在（不占位置了）。</li>
<li>absolute不受父元素里的其他元素影响，而relative会受到父元素里的其他元素影响</li>
<li>relative相对的总是<strong>自身原来的位置</strong>，无论其父元素是何种定位方式，而absolute总是相对于最近<strong>定义为absolute或relative的父层元素</strong></li>
</ol>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>两种盒模型：标准盒模型、IE盒模型<br>相同点：都是由 content + padding + border + margin构成<br>不同点：盒子内容的宽/高度<br>标准盒模型： 只包含content    box-sizing: content-box<br>IE盒模型： content + padding + border box-sizing: border-box</p>
<h3 id="选择器及其优先级"><a href="#选择器及其优先级" class="headerlink" title="选择器及其优先级"></a>选择器及其优先级</h3><p>!important &gt; style(内联) &gt; id &gt; class</p>
<h3 id="reflow（重排-回流）和-repaint（重绘）理解"><a href="#reflow（重排-回流）和-repaint（重绘）理解" class="headerlink" title="reflow（重排/回流）和 repaint（重绘）理解"></a>reflow（重排/回流）和 repaint（重绘）理解</h3><h4 id="重排-回流："><a href="#重排-回流：" class="headerlink" title="重排/回流："></a>重排/回流：</h4><p><strong>第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流</strong><br>元素的<strong>几何信息</strong>被影响导致浏览器需要<strong>重新计算</strong>元素在视口内的几何属性（位置和尺寸）</p>
<h4 id="引发回流的几种情况"><a href="#引发回流的几种情况" class="headerlink" title="引发回流的几种情况"></a>引发回流的几种情况</h4><ol>
<li>DOM结构发生变改变，如添加新的节点或者移除节点</li>
<li>改变布局，如修改了width height padding font-size等值。</li>
<li>改变窗口 resize,修改了窗口的尺寸。</li>
<li>调用 getComputedStyle方法获取尺寸、位置信息。</li>
</ol>
<h4 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h4><p><strong>第一次渲染内容称之为绘制，之后重新渲染称之为重绘</strong><br>通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的<strong>实际像素</strong>的阶段</p>
<h4 id="引发重绘的几种情况"><a href="#引发重绘的几种情况" class="headerlink" title="引发重绘的几种情况"></a>引发重绘的几种情况</h4><p>修改背景色、文字颜色、边框颜色、样式等。</p>
<h3 id="如何减少重排和重绘"><a href="#如何减少重排和重绘" class="headerlink" title="如何减少重排和重绘"></a>如何减少重排和重绘</h3><ul>
<li>最小化重绘和重排，修改样式尽量集中一次性修改</li>
<li>尽量避免频繁的操作DOM</li>
<li>批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中</li>
<li>尽量避免通过 <code>getComputedStyle</code> 获取尺寸位置信息</li>
<li>使用 <strong>absolute</strong> 或 <strong>fixed</strong> 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显</li>
<li>开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘 TODO:D</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903779700047885">参考</a></p>
<h3 id="BFC-的理解"><a href="#BFC-的理解" class="headerlink" title="BFC 的理解"></a>BFC 的理解</h3><p>block format context: 块级格式上下文 相当于一个独自的渲染区域 （内部布局不会影响外部）</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>父元素垂直外边距不会与子元素重叠</li>
<li>bfc的元素不会被浮动元素覆盖</li>
<li>开启bfc的元素可以包含浮动元素</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>清除浮动主要是为了解决父元素因为子级元素浮动引起的内部高度为0的问题</li>
<li>处理外边距塌陷问题</li>
<li>使浮动元素不遮挡普通元素</li>
</ol>
<h4 id="如何开启bfc"><a href="#如何开启bfc" class="headerlink" title="如何开启bfc"></a>如何开启bfc</h4><ol>
<li>overflow:hidden</li>
<li>before after伪类 clear:both</li>
</ol>
<h3 id="实现两栏布局（左侧固定和右侧自适应）-5-种"><a href="#实现两栏布局（左侧固定和右侧自适应）-5-种" class="headerlink" title="实现两栏布局（左侧固定和右侧自适应） 5 种"></a>实现两栏布局（左侧固定和右侧自适应） 5 种</h3><ol>
<li>浮动<br>左侧元素宽度固定，向左浮动，右边元素margin-left设为固定宽度，<strong>width:auto</strong></li>
<li>浮动<br>左边元素宽度固定 ，设置向左浮动。右侧元素设置 <strong>overflow: hidden;</strong> 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
<li>flex<br>左边固定宽度，右边<strong>flex:1</strong></li>
<li>绝对定位<br>左边元素absolute，宽度固定，右边margin-left设为左边元素的宽度</li>
<li>绝对定位<br>左边元素宽度固定，右边元素 absolute  定位， left  为宽度大小，其余方向定位为 0</li>
</ol>
<h3 id="实现圣杯布局和双飞翼布局（三分栏）"><a href="#实现圣杯布局和双飞翼布局（三分栏）" class="headerlink" title="实现圣杯布局和双飞翼布局（三分栏）"></a>实现圣杯布局和双飞翼布局（三分栏）</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><ol>
<li>三栏布局，中间一栏最先加载和渲染（内容最重要，中间内容在html中最先写好从而最先加载）。</li>
<li>两侧内容固定，中间内容随着宽度自适应。</li>
<li>一般用于 PC 网页。</li>
</ol>
<h4 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h4><ol>
<li>使用 float 布局。</li>
<li>两侧使用 margin 负值，以便和中间内容横向重叠。</li>
<li>防止中间内容被两侧覆盖，圣杯布局用(父元素) padding ，双飞翼布局用（子元素） margin </li>
</ol>
<h3 id="水平垂直居中的实现"><a href="#水平垂直居中的实现" class="headerlink" title="水平垂直居中的实现"></a>水平垂直居中的实现</h3><ol>
<li><p>绝对定位 <strong>不需要管宽高</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>绝对定位 各方向为0 margin设为auto  盒子必须有宽高</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>绝对定位 left和top定位之后通过margin-left和margin-top修改  必须有宽高</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.son</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>flex 不定宽高</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="flex：1-的含义"><a href="#flex：1-的含义" class="headerlink" title="flex：1 的含义"></a>flex：1 的含义</h3><p>flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。<br>flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。<br>flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .</p>
<h3 id="line-height-如何继承"><a href="#line-height-如何继承" class="headerlink" title="line-height 如何继承"></a>line-height 如何继承</h3><ol>
<li>父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。</li>
<li>父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。</li>
<li>父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。</li>
</ol>
<h3 id="文字超出省略，用什么css"><a href="#文字超出省略，用什么css" class="headerlink" title="文字超出省略，用什么css"></a>文字超出省略，用什么css</h3><h4 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box1</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 不换行 */</span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 超出省略 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box2</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">display</span>: -webkit-box; <span class="hljs-comment">/* 将对象作为弹性伸缩盒子模型显示 */</span><br>    -webkit-box-orient: vertical; <span class="hljs-comment">/* 设置子元素排列方式 */</span><br>    -webkit-line-clamp: <span class="hljs-number">3</span>; <span class="hljs-comment">/* 显示几行，超出的省略 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="怎么画一条0-5px的线"><a href="#怎么画一条0-5px的线" class="headerlink" title="怎么画一条0.5px的线"></a>怎么画一条0.5px的线</h3><ol>
<li>height: 1px; transform: scale(0.5)<br>注意宽度也会变化，记得将宽度设为本来的200%</li>
</ol>
<h3 id="网页中有大量图片加载很慢，怎么优化"><a href="#网页中有大量图片加载很慢，怎么优化" class="headerlink" title="网页中有大量图片加载很慢，怎么优化"></a>网页中有大量图片加载很慢，怎么优化</h3><ol>
<li>图片懒加载 监听滚动条事件，判断图片位置与浏览器顶端和页面的距离，前者小于后者，优先加载</li>
<li>使用图片预加载技术，将当前展示图片的前一张和后一张优先下载</li>
<li>csssprite和svgsprite</li>
</ol>
<h2 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h2><h3 id="同源和跨域"><a href="#同源和跨域" class="headerlink" title="同源和跨域"></a>同源和跨域</h3><h4 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h4><p>指：域名www、协议http、端口8080相同。</p>
<p>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收。即请求发送了，服务器响应了，但是无法被浏览器接收</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>若干标签可以允许跨域</p>
<ol>
<li>img</li>
<li>link href</li>
<li>script src</li>
</ol>
<h4 id="ajax跨域问题"><a href="#ajax跨域问题" class="headerlink" title="ajax跨域问题"></a>ajax跨域问题</h4><p>cors 跨域资源共享 服务端进行配置即可</p>
<p>jsonp </p>
<p>首先是利用script标签的src属性来实现跨域。<br>服务端返回一个定义好的js函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合。<br>缺点：</p>
<ol>
<li>只支持get，且需要后端配合</li>
<li>有可能有恶意代码</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题</li>
</ol>
<p><code>var str = params.query.callback + &#39;(&#39; + JSON.stringify(data) + &#39;)&#39;;</code></p>
<h3 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h3><ol>
<li>箭头函数没有this，它只会从自己作用域链上一层继承this，call，apply，bind也不能改变this指向</li>
<li>箭头函数没有自己的arguments对象向，可以再箭头函数中使用rest参数替代arguments来访问箭头函数的参数列表 <code>(...args) =&gt; &#123;&#125;</code></li>
<li>箭头函数不能通过new关键字调用，没有原型，super，new.target值等</li>
</ol>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><ol>
<li>let const 块级作用域</li>
<li>模板字符串 <code>$&#123;muban&#125;</code></li>
<li>展开运算符 <code>...arr</code></li>
<li>箭头函数  <code>() =&gt; &#123;&#125;</code></li>
<li>解构赋值 <code>let &#123;name&#125; = obj</code></li>
<li>类语法糖class</li>
<li>map set数据结构</li>
</ol>
<h3 id="call-apply-bind-函数的区别"><a href="#call-apply-bind-函数的区别" class="headerlink" title="call apply bind 函数的区别"></a>call apply bind 函数的区别</h3><p>call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，即修改函数体内this的指向</p>
<p>call和apply用法类似，call方法接受的是参数列表即多个参数以逗号分隔，而apply方法接受的是一个参数数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params">arg1,arg2</span>)</span> &#123;&#125;<br>func.apply(func1,[arg1,arg2]) <span class="hljs-comment">//参数数量不确定时，可以通过arguments把参数全部push进去</span><br>func.call(func1,arg1,arg2)<br></code></pre></td></tr></table></figure>

<p><strong>bind</strong>和call/apply最大的区别，一个函数被call和apply的时候会立即执行函数，但是bind会创建一个<strong>新函数</strong>，<strong>不会立即执行</strong></p>
<h3 id="new函数创建实例对象的步骤"><a href="#new函数创建实例对象的步骤" class="headerlink" title="new函数创建实例对象的步骤"></a>new函数创建实例对象的步骤</h3><ol>
<li><p>创建一个空对象obj</p>
</li>
<li><p>将obj的原型指向构造函数，这样obj就可以访问到构造函数的原型</p>
</li>
<li><p>执行构造函数，this指向obj，这样obj就可以访问到构造函数的属性</p>
</li>
<li><p>返回obj</p>
</li>
<li><p>创建一个新的对象</p>
</li>
<li><p>继承父类原型上的方法.</p>
</li>
<li><p>添加父类的属性到新的对象上并初始化. 保存方法的执行结果.</p>
</li>
<li><p>如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNew</span>(<span class="hljs-params">Fn, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> newObj = <span class="hljs-built_in">Object</span>.create(Fn);<br>  <span class="hljs-keyword">const</span> res = Fn.apply(newObj, args);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> ? res : newObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>值类型的变量直接存储数据（<strong>栈</strong>上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据<strong>堆</strong>中。</p>
<p>引用类型：当<strong>声明</strong>一个类时，只在<strong>栈</strong>中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 <strong>new</strong> 创建一个类的实例时，分配<strong>堆</strong>上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</p>
<h3 id="typeof-能判断哪些类型"><a href="#typeof-能判断哪些类型" class="headerlink" title="typeof 能判断哪些类型"></a>typeof 能判断哪些类型</h3><p>所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)</p>
<ol>
<li>识别所有值类型</li>
<li>识别函数 返回 ‘function’</li>
<li>判断是否是引用类型</li>
</ol>
<p>注意： typeof null | [1,2]  =&gt; “object”</p>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h3><p>== 只要求值相等即可 即经过类型转换为同一类型后值相等即可<br>=== 不仅值相等 类型也要相同</p>
<p>使用过程中，除了 == null 之外，其他一律用 ===<br>if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)</p>
<p>truly变量： !!a === true的变量<br>falsely变量  !!a === false的变量 ( 0 NaN “” null undefined false )</p>
<p>逻辑判断：<br>10 &amp;&amp; 0 前面是truly值，&amp;&amp;直接返回后面的值<br>“” || ‘abc’ 前面是falsely值， ||直接返回后面的值</p>
<h3 id="为啥-0-1-0-2-！-0-3"><a href="#为啥-0-1-0-2-！-0-3" class="headerlink" title="为啥 0.1+0.2 ！== 0.3"></a>为啥 0.1+0.2 ！== 0.3</h3><p>是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等<br>浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值</p>
<p>正确的比较方法 是使用js提供的最小精度值 Number.EPSILON<br><code>Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON</code></p>
<h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><p>原型：<br>每个class都有显式原型prototype<br>每个class实例化后的对象都有隐式原型__proto__<br>实例的隐式原型指向对应class的显式原型<br>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype</p>
<p>原型链：<br>首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。</p>
<h4 id="原型对象对实例的作用"><a href="#原型对象对实例的作用" class="headerlink" title="原型对象对实例的作用"></a>原型对象对实例的作用</h4><p>如果要给一个构造函数Foo创建出来的多个实例都添加一个方法，就可以在实例的原型上添加对应的方法，这样这个原型的所有实例便都有这个方法了</p>
<p>prototype是函数独有的属性 从一个函数指向一个对象 是该函数的原型对象<br>proto属性是所有对象都有的，它指向构造函数的原型对象</p>
<h3 id="如何判断一个变量是不是数组"><a href="#如何判断一个变量是不是数组" class="headerlink" title="如何判断一个变量是不是数组"></a>如何判断一个变量是不是数组</h3><ol>
<li>param instanceof Array (return true/false)</li>
<li>Array.isArray 更好 因为能检测iframes</li>
</ol>
<p>xialuo instanceof Student  (true)</p>
<h3 id="class的原型本质，怎么理解"><a href="#class的原型本质，怎么理解" class="headerlink" title="class的原型本质，怎么理解"></a>class的原型本质，怎么理解</h3><p>TODO:原型和原型链的图示</p>
<p>class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类<br>继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法</p>
<h3 id="js的几种继承方式"><a href="#js的几种继承方式" class="headerlink" title="js的几种继承方式"></a>js的几种继承方式</h3><p>TODO:重新整理</p>
<ul>
<li>原型链继承：</li>
</ul>
<p>优点：通过原型继承多个引用类型的属性和方法</p>
<p>缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。</p>
<ul>
<li>借用构造函数</li>
</ul>
<p>优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染</p>
<p>缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）</p>
<ul>
<li>组合继承</li>
</ul>
<p>优点： 集合了原型继承和盗用构造函数继承的优点</p>
<p>缺点：存在效率问题，Super始终会被调用两次</p>
<ul>
<li>原型式继承</li>
</ul>
<p>优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性</p>
<p>缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染</p>
<ul>
<li>寄生式继承</li>
</ul>
<p>优点：根据一个对象克隆创建另一个对象，并增强对象</p>
<p>缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍</p>
<ul>
<li>寄生式组合继承</li>
</ul>
<p>优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>作用域（scope） ：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是<strong>隔离变量</strong>，不同作用域下的同名变量不会有冲突。</p>
<ul>
<li>全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）</li>
<li>函数作用域 （函数内部定义的变量）</li>
<li>块级作用域 （let const声明的变量）</li>
</ul>
<p>作用域链</p>
<ul>
<li>自由变量 当前作用域中没有定义的变量，称为自由变量。</li>
<li>作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链</li>
<li>作用域与执行上下文的区别<ul>
<li>解释阶段（作用域规则确定）</li>
<li>执行阶段（执行上下文）</li>
</ul>
</li>
</ul>
<p>执行上下文在<strong>运行时</strong>确定（this的指向问题），随时可能改变，作用域（变量的值）在<strong>解释阶段（类似编译）</strong>就确定，并且不会改变。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等</p>
<h3 id="什么是块级作用域"><a href="#什么是块级作用域" class="headerlink" title="什么是块级作用域"></a>什么是块级作用域</h3><p>任何一对花括号({})中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。es6才有的</p>
<p>每个执行上下文都分为 变量环境 和 词法环境<br>var声明的变量在编译阶段都被存放到变量环境中，let声明的变量在编译阶段会被存放到词法环境中</p>
<p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>怎么回答： 怎么实现闭包 为啥要用闭包 那些地方会用到闭包</p>
<ol>
<li><p>有权访问其他函数作用域中变量的函数</p>
</li>
<li><p>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量</p>
</li>
</ol>
<p>所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方</p>
<h4 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h4><p>在一个函数内部创建另一个函数</p>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><p>可以读取函数内部的变量<br>可以阻止变量被回收</p>
<h4 id="为啥要用闭包"><a href="#为啥要用闭包" class="headerlink" title="为啥要用闭包"></a>为啥要用闭包</h4><p>利用闭包可以突破链作用域，将局部变量传到内部</p>
<h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><p>比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收</p>
<h4 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h4><ol>
<li><p>循环绑定监听事件,给标签循环添加监听事件<br>解决方式：1. 立即执行函数 2. es6声明 let const等（如下）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>节流防抖<br>在函数外部定义的timer,返回的是个函数，在函数内部修改timer的值实现定时效果</p>
</li>
<li><p>setTimeout 自执行方法</p>
</li>
<li><p>所有的回调函数</p>
</li>
</ol>
<h3 id="require-和-import"><a href="#require-和-import" class="headerlink" title="require 和 import"></a>require 和 import</h3><p>1.import在代码编译时被加载，所以必须放在文件开头，require在代码运行时被加载，所以require理论上可以运用在代码的任何地方，所以import性能更好。<br>2.import引入的对象被修改时，源对象也会被修改，相当于浅拷贝，require引入的对象被修改时，源对象不会被修改，官网称值拷贝，我们可以理解为深拷贝。<br>3.import有利于tree-shaking（移除JavaScript上下文中未引用的代码），require对tree-shaking不友好。<br>4.import会触发代码分割（把代码分离到不同的bundle中，然后可以按需加载或者并行加载这些文件），require不会触发。<br>5.import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法，require 是 AMD规范引入方式。</p>
<h3 id="promise理解"><a href="#promise理解" class="headerlink" title="promise理解"></a>promise理解</h3><p>promise是ES6中为了避免回调地狱的一种异步解决方案</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>状态不受外界影响</li>
<li>状态一旦改变就不会再变</li>
</ol>
<h4 id="实例对象方法"><a href="#实例对象方法" class="headerlink" title="实例对象方法"></a>实例对象方法</h4><ol>
<li>then</li>
<li>catch</li>
<li>finally</li>
<li>resolve() reject()</li>
<li>all() 所有resolved 才是resolved 其他都是rejected</li>
<li>race() 第一个完成状态变化的成功了最终就是resolved 失败就是rejected</li>
<li>any() 有一个成功就resolved，都失败就rejected</li>
<li>allSettled() then接收的参数是所有promise对象异步操作的执行结果 如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> &#125;,<br>  &#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <span class="hljs-attr">value</span>: -<span class="hljs-number">1</span> &#125;<br>]<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="promise简易实现"><a href="#promise简易实现" class="headerlink" title="promise简易实现"></a>promise简易实现</h3><p>其中有点类似发布订阅模式 收集依赖 触发通知 取出依赖执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 存放成功的回调</span><br>    <span class="hljs-built_in">this</span>.onResolvedCallbacks = [];<br>    <span class="hljs-comment">// 存放失败的回调</span><br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks= [];<br><br>    <span class="hljs-keyword">let</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status ===  PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = FULFILLED;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-comment">// 依次将对应的函数执行</span><br>        <span class="hljs-built_in">this</span>.onResolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span>=&gt;</span>fn());<br>      &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">let</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status ===  PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = REJECTED;<br>        <span class="hljs-built_in">this</span>.reason = reason;<br>        <span class="hljs-comment">// 依次将对应的函数执行</span><br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span>=&gt;</span>fn());<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve,reject)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      reject(error)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === FULFILLED) &#123;<br>      onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === REJECTED) &#123;<br>      onRejected(<span class="hljs-built_in">this</span>.reason)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span><br>      <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>        onFulfilled(<span class="hljs-built_in">this</span>.value)<br>      &#125;);<br><br>      <span class="hljs-comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span><br>      <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(<span class="hljs-function">()=&gt;</span> &#123;<br>        onRejected(<span class="hljs-built_in">this</span>.reason);<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="迭代方法-数组遍历方法"><a href="#迭代方法-数组遍历方法" class="headerlink" title="迭代方法 数组遍历方法"></a>迭代方法 数组遍历方法</h3><ol>
<li>every 有一个不满足返回false，都满足返回true  不会改变原数组</li>
<li>some   有一个元素满足要求返回true，否则false 不改变原数组</li>
<li>forEach  返回undefined                 不改变原数组</li>
<li>filter  返回新数组，元素为符合条件的所有元素  不改变原数组</li>
<li>map  返回新数组，元素为调用函数处理后的值    不改变原数组（性能比forEach低）</li>
<li>find  返回第一个满足的项或者undefined     不改变原数组</li>
<li>findIndex 返回第一个满足的项的下标或者-1     不改变原数组</li>
</ol>
<p>其他</p>
<ol>
<li>for</li>
<li>forin  对象 效率最低</li>
<li>forof  数组 支持break等，缺点没有index</li>
</ol>
<p>普通for循环才是最优雅的，优化后的for循环最快<br>数组方法无法中途停止循环，所以都不可以使用break和continue；<br>for循环之类的不可以return，但是能正常使用break和continue；</p>
<h3 id="shift-和-unshift-和-push-和-pop的返回值"><a href="#shift-和-unshift-和-push-和-pop的返回值" class="headerlink" title="shift 和 unshift 和 push 和 pop的返回值"></a>shift 和 unshift 和 push 和 pop的返回值</h3><p>shift 和 pop 返回值 被删除的值<br>unshift 和 push 返回添加之后数组的长度</p>
<h3 id="map-和-set的区别"><a href="#map-和-set的区别" class="headerlink" title="map 和 set的区别"></a>map 和 set的区别</h3><p>map 字典 键值对 set get has size<br>set 值唯一的数组 add delete</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>任务：找到<strong>哪些被分配的内存确实已经不再需要了</strong></p>
<ol>
<li><p>引用计数垃圾收集<br>理解为 对象有没有其他对象引用它，如果没有就标记为<strong>零引用</strong>，对象将被垃圾回收机制回收<br>限制：循环引用的风险</p>
</li>
<li><p>标记-清除算法<br>理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收<br>限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）</p>
</li>
</ol>
<h3 id="this-的用法及含义"><a href="#this-的用法及含义" class="headerlink" title="this 的用法及含义"></a>this 的用法及含义</h3><p><strong>this取什么值是在函数被执行的时候确定的，不是在定义的时候</strong></p>
<p>this的指向问题</p>
<ol>
<li>作为普通函数 window</li>
<li>使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）</li>
<li>作为对象方法被调用 指代的就是这个对象本身</li>
<li>在class方法中调用 当前实例本身 setTimeout注意</li>
<li>箭头函数  <code>()=&gt;&#123;this&#125;</code> 和上级作用域的值一致</li>
</ol>
<h3 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h3><ol>
<li>cookie<ol>
<li>特点<ol>
<li>本身用于浏览器和server通讯</li>
<li>可用<code>document.cookie = &#39;xxx&#39;</code>来修改</li>
</ol>
</li>
<li>缺点<ol>
<li>存储大小限制为4KB</li>
<li>http请求需要发送到服务端，增加请求数量</li>
<li>只能用document.cookie修改</li>
</ol>
</li>
</ol>
</li>
<li>localStorage 和 sessionStorage<ol>
<li>特点<ol>
<li>最大可存储 5MB</li>
<li>api 简单易用，setItem getItem</li>
<li>不会跟随 http 请求发送给服务端</li>
</ol>
</li>
<li>区别<ol>
<li>localStorage 会永久存储，除非手动删除</li>
<li>sessionStorage 数据只存在当前会话，浏览器关闭则清空</li>
<li>一般用 localStorage 较多</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="http-缓存（强制缓存-协商缓存）"><a href="#http-缓存（强制缓存-协商缓存）" class="headerlink" title="http 缓存（强制缓存 | 协商缓存）"></a>http 缓存（强制缓存 | 协商缓存）</h3><h4 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h4><p>网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p>
<h4 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h4><p>http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等</p>
<ol>
<li>Expires</li>
<li>Cache-Control<ol>
<li>max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒</li>
<li>s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；</li>
<li>public：指示响应可被任何缓存区缓存；</li>
<li>private：只能针对个人用户，而不能被代理服务器缓存；</li>
<li>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</li>
<li>no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</li>
</ol>
</li>
</ol>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>过程：</p>
<ol>
<li>初次请求，服务器返回资源和cache-control</li>
<li>再次请求，本地缓存直接返回资源</li>
</ol>
<p>cache-control</p>
<h4 id="协商缓存（对比缓存）"><a href="#协商缓存（对比缓存）" class="headerlink" title="协商缓存（对比缓存）"></a>协商缓存（对比缓存）</h4><ul>
<li>服务端缓存策略。</li>
<li>服务端判断客户端资源，是否和服务端资源一样。</li>
<li>一致则返回 304，否则返回 200 和最新的资源。<br>过程：</li>
</ul>
<ol>
<li>初次请求，服务器端返回资源和资源标识</li>
<li>再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识</li>
</ol>
<p>资源标识：保存在Response Headers中</p>
<ol>
<li>Last-Modified： 资源的最后修改时间</li>
<li>Etag： 资源的唯一标识</li>
</ol>
<h5 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified  If-Modified-Since"></a>Last-modified  If-Modified-Since</h5><p>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p>
<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag  If-None-Match"></a>Etag  If-None-Match</h5><p>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 <strong>If-None-match</strong>（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Etag的优先级比last-modified高</p>
<p>last-modified的不足：</p>
<ol>
<li>只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间</li>
<li>如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，<strong>不会影响阻塞</strong>后面的代码执行</p>
<ol>
<li>最开始实现异步都是采用<strong>回调函数</strong>实现的，但是有个缺点：回调地狱</li>
<li>为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）</li>
<li>ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解</li>
</ol>
<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>异步任务不进入主线程，而是进入<strong>任务队列</strong>，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。</p>
<ol>
<li>event loop过程1<ol>
<li>同步代码，一行一行放在call Stack（执行栈）执行</li>
<li>遇到异步，会先记录下并交给其他线程处理，等待时机（定时，网络请求）</li>
<li>时机到了，就会移动到callback queue</li>
</ol>
</li>
<li>event loop过程2<ol>
<li>如果call stack为空（同步代码执行完），event loop开始工作</li>
<li>轮训查找callback queue，如果有则移动到call stack<ol>
<li>优先检查微任务队列是否有任务，没有的话再去宏任务队列检查</li>
</ol>
</li>
<li>然后继续轮训查找</li>
</ol>
</li>
</ol>
<p>另一种说法： *</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前微任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ol>
<p>总结：</p>
<ol>
<li>tasks 按序执行，浏览器会在 tasks 之间执行渲染。</li>
<li>microtasks 按序执行，在下面情况时执行：<ol>
<li>在每个回调之后，只要没有其它代码正在运行。</li>
<li>在每个 task 的末尾</li>
</ol>
</li>
</ol>
<h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><p>异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)</p>
<p>宏任务 -（当前微任务） - 渲染 - 宏任务 。。。</p>
<p><strong>微任务比宏任务执行时间要早</strong></p>
<p>常见宏任务：</p>
<ol>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate(Node)</li>
<li>点击事件或键盘事件 i/o事件</li>
<li>Ajax</li>
<li>script整体代码段</li>
<li>promise里面的代码</li>
</ol>
<p>常见微任务</p>
<ol>
<li><strong>promise.then</strong>,<strong>await</strong>（与then类似）,promise.catch</li>
<li>object.observe</li>
<li>new MutationObserver(浏览器环境)</li>
<li>process.nextTick(node)</li>
</ol>
<p>注意：async函数在await之前的代码都是<strong>同步</strong>执行的，可以理解为await之前的代码属于new Promise传入的代码，<strong>await之后的代码都是在Promise.then中的回调</strong></p>
<h3 id="柯里化-1"><a href="#柯里化-1" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a+ b + c<br>&#125;<br><span class="hljs-comment">// 柯里化之后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> a + b + c<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 调用时</span><br>sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h4 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h4><p>我们处理函数时，希望函数功能尽可能单一</p>
<h4 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h4><p>(个人感觉不重要，理解什么是柯里化即可)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCurried</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args1.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-literal">null</span>, ...args1)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">null</span>, [...args1, ...args2])<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b + c + d + e<br>&#125;<br><span class="hljs-keyword">let</span> resFunc = myCurried(sum)<br><span class="hljs-built_in">console</span>.log(resFunc(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">23</span>))<br><span class="hljs-comment">//解析:</span><br><span class="hljs-comment">//1、这里的fn.length获取的是函数传入参数的长度</span><br><span class="hljs-comment">//2、这里使用递归的思想</span><br></code></pre></td></tr></table></figure>

<h3 id="箭头函数的优缺点"><a href="#箭头函数的优缺点" class="headerlink" title="箭头函数的优缺点"></a>箭头函数的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>简写了函数</li>
<li><strong>改变this的指向为当前外部对象</strong></li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>没有arguments参数</li>
<li>无法通过apply bind call来改变this的指向</li>
</ol>
<h4 id="不能用于哪些场景"><a href="#不能用于哪些场景" class="headerlink" title="不能用于哪些场景"></a>不能用于哪些场景</h4><ol>
<li>不能用于对象内方法</li>
<li>不能用于对象原型</li>
<li>不能用于构造函数</li>
<li>动态上下文中的函数，addEventListener的回调函数，其中的this指向有问题</li>
<li>vue生命周期和method方法不能写成箭头函数的形式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-attr">getA</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log( obj.getA() ) <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="AMD-和-CommonJS-的理解"><a href="#AMD-和-CommonJS-的理解" class="headerlink" title="AMD 和 CommonJS 的理解"></a>AMD 和 CommonJS 的理解</h3><p>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数<br>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的</p>
<h2 id="vue-相关"><a href="#vue-相关" class="headerlink" title="vue 相关"></a>vue 相关</h2><h3 id="vue-和-react的区别-对比等"><a href="#vue-和-react的区别-对比等" class="headerlink" title="vue 和 react的区别 对比等"></a>vue 和 react的区别 对比等</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ol>
<li>都是数据驱动视图</li>
<li>都是组件化思想</li>
<li>都有虚拟dom</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li>vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定</li>
<li>vue相对语法简单，适用于小型项目，react更侧重于大型应用</li>
<li>vue渲染更快体积更小，react生态圈更大有更多工具</li>
</ol>
<h3 id="vue-的优势"><a href="#vue-的优势" class="headerlink" title="vue 的优势"></a>vue 的优势</h3><ol>
<li>轻量级框架</li>
<li>双向数据绑定（即响应式数据绑定）  – 最大优点</li>
<li>组件化开发</li>
<li>虚拟dom 节省了大量性能 比react快</li>
</ol>
<h3 id="computed和watch区别"><a href="#computed和watch区别" class="headerlink" title="computed和watch区别"></a>computed和watch区别</h3><ol>
<li>computed 依赖于其他属性值 并且computed的值有<strong>缓存</strong></li>
<li>watch 监听某些数据的回调</li>
</ol>
<h3 id="mvvm-和-mvc-区别"><a href="#mvvm-和-mvc-区别" class="headerlink" title="mvvm 和 mvc 区别"></a>mvvm 和 mvc 区别</h3><ol>
<li>mvc和mvvm都是一种设计思想。 主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量DOM操作使页面渲染性能降低，加载速度变慢的问题 。</li>
<li>MVVM与MVC最大的区别就是：它<strong>实现了View和Model的自动同步</strong>：当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的显示，它会自动变化。 （数据变化页面直接跟着变化）</li>
<li>整体看来，MVVM比MVC精简很多，我们不用再用选择器频繁地操作DOM。</li>
</ol>
<h3 id="vue-双向绑定的原理"><a href="#vue-双向绑定的原理" class="headerlink" title="vue 双向绑定的原理"></a>vue 双向绑定的原理</h3><p>采用数据劫持和发布者-订阅者模式<br>数据劫持是通过 Object.defineProperty实现的，defineProperty可以控制对象属性的一些特有操作比如读写，是否可枚举等。其中最重要的就是get和set方法,可以通过defineProperty重写get和set方法来自定义对象属性的读取和设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(Book, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    name = value;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你取了一个书名叫做&#x27;</span> + value);<br>  &#125;,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;《&#x27;</span> + name + <span class="hljs-string">&#x27;》&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="具体的实现（了解）"><a href="#具体的实现（了解）" class="headerlink" title="具体的实现（了解）"></a>具体的实现（了解）</h4><ol>
<li>实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li>
<li>实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li>
<li>实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenhuichao/p/10818396.html">参考</a></p>
<h3 id="vue2-和-vue3-双向绑定原理的区别-：proxy"><a href="#vue2-和-vue3-双向绑定原理的区别-：proxy" class="headerlink" title="vue2 和 vue3 双向绑定原理的区别 ：proxy"></a>vue2 和 vue3 双向绑定原理的区别 ：proxy</h3><p>vue2如上<br>vue3采用的是proxy来实现双向绑定的</p>
<h4 id="为啥vue3要改用proxy"><a href="#为啥vue3要改用proxy" class="headerlink" title="为啥vue3要改用proxy"></a>为啥vue3要改用proxy</h4><p>object.defineProperty的缺点</p>
<ol>
<li>因为只能监听对象的属性，所以需要深度遍历，监听需要一次性递归 (遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。</li>
<li>无法监听新增属性/删除属性(Vue.set Vue.delete，未在 data 中定义的属性会报 undefined)</li>
<li>无法原生监听数组，需要特殊处理（比如直接根据下标来修改值不能实时响应）</li>
</ol>
<p><code>let proxy = new Proxy(target,handler)</code><br>proxy支持13种拦截方式，相比老版更加丰富</p>
<p>可以理解为在对象之前设置一个<strong>对整个对象的拦截</strong>，当监听的对象被访问的时候，都必须经过这层拦截。可以在这拦截中对原对象处理，返回需要的数据格式。</p>
<p>Reflect是ES6为了操作对象而新增的API，个人理解为之前Object的优化，并完美支持proxy</p>
<h4 id="proxy的缺点"><a href="#proxy的缺点" class="headerlink" title="proxy的缺点"></a>proxy的缺点</h4><p>proxy 无法兼容所有浏览器，无法进行polyfill</p>
<h3 id="data-为啥是函数"><a href="#data-为啥是函数" class="headerlink" title="data 为啥是函数"></a>data 为啥是函数</h3><p>因为<strong>组件是可以复用</strong>的, JS里对象是<strong>引用</strong>关系, 如果组件data是一个对象, 那么在子组件中的data属性值会<strong>互相污染</strong>, 产生副作用。所以一个组件的data选项必须是一个函数, 这样才让每个实例可以维护一份被返回对象的独立拷贝。</p>
<h3 id="ref是什么"><a href="#ref是什么" class="headerlink" title="ref是什么"></a>ref是什么</h3><p>引用<br><code>this.$refs.refName</code><br>加在普通元素 可以获取到对应的dom元素<br>加在子组件上，用this.ref.name 获取到的是组件实例，可以使用组件的所有方法</p>
<h3 id="data-computed-watch-的依赖关系"><a href="#data-computed-watch-的依赖关系" class="headerlink" title="data computed watch 的依赖关系"></a>data computed watch 的依赖关系</h3><p>computed计算属性和watch都是以vue的依赖追踪机制为基础的，即依赖数据发生变化，所有一来这个数据的相关数据也自动发生变化<br>computed是一个值受多个属性影响<br>watch是监听一个属性的值发生变化时对其他多条数据的影响</p>
<h3 id="为啥-v-for-和-v-if-不建议一起用"><a href="#为啥-v-for-和-v-if-不建议一起用" class="headerlink" title="为啥 v-for 和 v-if 不建议一起用"></a>为啥 v-for 和 v-if 不建议一起用</h3><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度。</p>
<p>建议使用计算属性替代</p>
<h3 id="插槽（匿名，具名，作用域）及用法"><a href="#插槽（匿名，具名，作用域）及用法" class="headerlink" title="插槽（匿名，具名，作用域）及用法"></a>插槽（匿名，具名，作用域）及用法</h3><h4 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h4><p><code>&lt;slot /&gt;</code></p>
<h4 id="具名插槽-一一对应即可"><a href="#具名插槽-一一对应即可" class="headerlink" title="具名插槽  一一对应即可"></a>具名插槽  一一对应即可</h4><p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 slot=&quot;header&quot;&gt;h1&lt;/h1&gt;<br>&lt;h1 slot=&quot;footer&quot;&gt;h1&lt;/h1&gt;<br></code></pre></td></tr></table></figure>

<h4 id="作用域插槽-带数据的插槽-可用slot-scope获取数据"><a href="#作用域插槽-带数据的插槽-可用slot-scope获取数据" class="headerlink" title="作用域插槽 - 带数据的插槽 可用slot-scope获取数据"></a>作用域插槽 - 带数据的插槽 可用slot-scope获取数据</h4><ul>
<li>子组件中<br><code>&lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;</code> </li>
<li>父组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template slot-scope=&quot;user&quot;&gt;<br>  &lt;div class=&quot;tmpl&quot;&gt;<br>    &lt;span v-for=&quot;item in user.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h3><ol>
<li>beforeCreate 刚创建实例，没有数据和计算属性等 可以访问到 $el 和 $options</li>
<li>created 实例创建完，可以访问data和methods，$el上的属性还不存在</li>
<li>beforeMount 实例已挂载到dom上，但是dom还没更新</li>
<li>mounted 实例已挂在到dom，dom已更新，<code>$el</code>属性可见，用<code>this.$el</code>可以访问</li>
<li>beforeUpdate data已更新，dom未更新</li>
<li>updated dom和data都更新完毕</li>
<li>beforeDestory 实例销毁前，此时事件监听和watcher都已移除，但是dom还没移除</li>
<li>destoryed 实例销毁后，事件监听和watcher和dom都移除</li>
<li>activated  keep-alive激活时调用</li>
<li>deactivated  keep-alive停用时调用</li>
<li>errorCaptured 捕获子组件的错误 会向上冒泡 可以在此处进行错误处理</li>
</ol>
<p>beforeDestory注意点<br>自定义的全局事件要在退出该页面钱进行解绑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">mounted () &#123;<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.handleScroll)<br>&#125;,<br>beforeDestroy () &#123;<br>  <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.handleScroll)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><p>TODO:待丰富</p>
<ol>
<li>父 -&gt; 子  props</li>
<li>子 -&gt; 父  events($emits)</li>
<li>$parent / $children 两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。</li>
<li>总线机制bus event bus  ($emit $on)<br>要创建一个公共bus.js 然后在其他组件中引入 作为中间传达的工具</li>
<li>vuex</li>
<li>$attrs  / $listeners  两个对象 $attrs是非props属性 $listeners是非原生事件 <code>v-bind=&quot;$attrs&quot;</code></li>
<li>祖 -&gt; 孙 provide / inject</li>
</ol>
<h3 id="vue-循环为啥要加-key"><a href="#vue-循环为啥要加-key" class="headerlink" title="vue 循环为啥要加 key"></a>vue 循环为啥要加 key</h3><p>类似唯一身份标志，主要用来做dom diff算法用的</p>
<p>diff算法是同级比较，比较当前标签上的key还有它当前的标签名，如果key和标签名都一样时只是做了一个移动的操作，不会重新创建元素和删除元素</p>
<p>默认使用 就地复用的策略，</p>
<h4 id="为啥不能用index做key"><a href="#为啥不能用index做key" class="headerlink" title="为啥不能用index做key"></a>为啥不能用index做key</h4><ol>
<li><p>性能问题：如果在数组前新增一个新元素，整个数组的key都发生了变化，就跟没有key是一个效果了  （在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM更新，从而导致效率低）</p>
</li>
<li><p>数据错位：新增input，新增的input还残留之前一个input绑定的数据 （如果结构中包含输入类的 DOM，会产生错误的 DOM 更新）</p>
</li>
</ol>
<h3 id="封装过的-vue-组件"><a href="#封装过的-vue-组件" class="headerlink" title="封装过的 vue 组件"></a>封装过的 vue 组件</h3><ol>
<li>城市选择组件 搜索 首字母跳转</li>
<li>全局封装注册图标组件 app.component</li>
<li>表格、表单等</li>
</ol>
<h3 id="vue-的-template-是怎么编译的"><a href="#vue-的-template-是怎么编译的" class="headerlink" title="vue 的 template 是怎么编译的"></a>vue 的 template 是怎么编译的</h3><p>TODO:</p>
<ol>
<li>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串</li>
<li>之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。</li>
<li>当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。</li>
<li>如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM</li>
</ol>
<h3 id="vue-的两种路由模式-hash-和-history"><a href="#vue-的两种路由模式-hash-和-history" class="headerlink" title="vue 的两种路由模式 hash 和 history"></a>vue 的两种路由模式 hash 和 history</h3><h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><ol>
<li>hash模式是url后面带有#的情况，#后面的值不会包含在http请求，所有改变hash的值不会引起页面的重新加载，不会像服务器重新发起请求</li>
<li>不利于seo优化</li>
<li>只能修改#后面的部分，因此只能跳转与当前url同文档的url</li>
</ol>
<p>hash原理： onhashchange事件，页面每次hash值得变化都会触发hashchange事件</p>
<p>会创建hashHistory对象，会被浏览器记录下来，在访问不同的路由会发生两种事件：hashHistory.push()：将新的路由添加到浏览器访问的历史栈顶，<br>hashHistory.replace()替换到当前栈</p>
<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><ol>
<li>url不带#参数，看起来更美观</li>
<li>history模式依赖于前后端交互，即url修改就会请求后端url，如果后端没配置对应的/user/id的路由处理，就会返回404报错</li>
<li>history模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中，可以传递复杂的数据</li>
<li>可以访问当前url同源的任意url</li>
<li>history原理：history.pushState事件，当浏览器跳转到新的状态时会触发popstate事件 window.history的相关api</li>
</ol>
<h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h3><p>$route 是”路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 (信息)<br>$router 是”路由实例(VueRouter)”对象，相当于一个全局的路由器对象,包括了路由的跳转方法，钩子函数等。如history对象，this.$router.push（）返回上一个history也是使用$router.go(-1)  (实例)</p>
<h3 id="动态路由怎么获取传递的动态参数"><a href="#动态路由怎么获取传递的动态参数" class="headerlink" title="动态路由怎么获取传递的动态参数"></a>动态路由怎么获取传递的动态参数</h3><p>场景：User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染<br>动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配<br>到一个路由时，参数会被设置到 this.$route.params 中，并且可以在每个组件<br>中使用。<br><code>&#123; path: &#39;/user/:id&#39;, component: User &#125;</code><br>在匹配到该路由之后，动态参数会被设置到this.$route.params</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;<br></code></pre></td></tr></table></figure>
<p>也可以是多个参数<br><code>/user/:username/post/:post_id</code> 与路由一一对应</p>
<h4 id="params和query的区别是什么"><a href="#params和query的区别是什么" class="headerlink" title="params和query的区别是什么"></a>params和query的区别是什么</h4><ol>
<li>query 要用 path 来引入，params 需要用 name 来引入</li>
<li>接收参数时，分别是<code>this.$route.query.name</code>  和 <code>this.$route.params.name</code> (注意：是<code>$route</code>而不是<code>$router</code>)</li>
<li>query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址中显示，params 不显示</li>
<li>params 传值一刷新就没了，query 传值刷新还存在（因为是保存在地址栏中的）</li>
</ol>
<h3 id="路由传值的实现方式"><a href="#路由传值的实现方式" class="headerlink" title="路由传值的实现方式"></a>路由传值的实现方式</h3><p>共2种 params - name 和 query - path</p>
<h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">data:&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>  ...<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.username &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这边的name是给path取的别名，name最重要的一点就是配合params进行路由的参数传递</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Login<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home<br>  &#125;<br>]<br><br><span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.username &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="vue-router-的钩子函数-路由守卫"><a href="#vue-router-的钩子函数-路由守卫" class="headerlink" title="vue-router 的钩子函数 路由守卫"></a>vue-router 的钩子函数 路由守卫</h3><p>TODO:背</p>
<ol>
<li>全局钩子<ol>
<li>beforeEach  <code>router.beforeEach(to,from,next)</code></li>
<li>afterEach</li>
<li>beforeResolve</li>
</ol>
</li>
<li>路由独享钩子<ol>
<li>beforeEnter  写在路由配置中，访问到这个路径会触发这个钩子函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/foo&#x27;</span>,<br>    <span class="hljs-attr">componenet</span>: Foo,<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;&#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>组件内钩子<ol>
<li>beforeRouterEnter 写在组件中，即将渲染组件的时候触发 不能访问this</li>
<li>beforeRouterUpdate</li>
<li>beforeRouterLeave<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 写在vue组件中</span><br> <span class="hljs-function"><span class="hljs-title">beforeRouterLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="vue-的-nextTick"><a href="#vue-的-nextTick" class="headerlink" title="vue 的 nextTick"></a>vue 的 nextTick</h3><p>nextTick: 将回调推迟到下一个 DOM 更新周期之后执行<br>该钩子函数执行时所有的DOM挂载和渲染都已完成</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中</li>
<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</li>
</ol>
<h3 id="mixin-的用法"><a href="#mixin-的用法" class="headerlink" title="mixin 的用法"></a>mixin 的用法</h3><p>mixin 是用来分发 vue 组件中的可复用功能，可包含任意组件选项</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li>在被其他组件引入后，mixin中的方法和属性也就并入到该组件中</li>
<li>数据对象在内部会进行递归合并，并在发生冲突时以<strong>组件数据优先</strong></li>
<li>同名钩子函数会被合并为一个数组，都被调用，<strong>mixin的钩子先执行</strong></li>
<li>也可以全局注入，不过会影响后面的所有vue实例，不建议</li>
</ol>
<p>实战举例： e-charts的resize.js</p>
<h3 id="虚拟-dom-的理解及其优点"><a href="#虚拟-dom-的理解及其优点" class="headerlink" title="虚拟 dom 的理解及其优点"></a>虚拟 dom 的理解及其优点</h3><p>虚拟DOM本质上是<strong>JavaScript对象</strong>,是对真实DOM的抽象 状态变更时，用对象记录新树和旧树的差异<br>最后把差异更新到真正的dom中</p>
<p>多次渲染DOM是很消耗前端性能的，所以减少dom的操作成为了优化前端性能的必要手段</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>保证性能下限 大幅度减少了dom的操作，减少了重绘和回流的次数，提高了性能</li>
<li>无需手动操作DOM virtualDOM的diff和patch都是在一次更新中自动进行的，无需手动操作</li>
<li>跨平台 本质是js对象，dom是与平台强相关的，js对象可以更方便的跨平台操作</li>
</ol>
<h3 id="图片懒加载的实现"><a href="#图片懒加载的实现" class="headerlink" title="图片懒加载的实现"></a>图片懒加载的实现</h3><p>可以利用html5的属性data-xxx来保存图片的路径，当我们需要加载图片的时候才将data-xxx的值赋予src,就能实现图片的按需加载</p>
<p>vue-lazyload</p>
<h3 id="vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决"><a href="#vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决" class="headerlink" title="vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决"></a>vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决</h3><ol>
<li>索引设置元素   <code>this.array[index] = newValue</code><ol>
<li>解决方式 <code>this.$set(this.array,index,newValue)</code> 或者 <code>this.array.splice(index,1,newValue)</code></li>
</ol>
</li>
<li>直接修改数组长度 <code>this.array.length = newLength</code><ol>
<li>解决方式   <code>this.array.splice(newLength)</code></li>
</ol>
</li>
</ol>
<h3 id="vue-底层是怎么实现对数组的监听的"><a href="#vue-底层是怎么实现对数组的监听的" class="headerlink" title="vue 底层是怎么实现对数组的监听的"></a>vue 底层是怎么实现对数组的监听的</h3><p>在将数组处理成响应式数据后，如果使用数组原始方法改变数组时，数组值会发生变化，但是并不会触发数组的setter来通知所有依赖该数组的地方进行更新，为此，vue通过<strong>重写数组的某些方法</strong>来监听数组变化，重写后的方法中会手动触发通知该数组的所有依赖进行更新。</p>
<p>重写的数组方法：<br>push pop shift unshift splice sort reverse</p>
<h3 id="vue如何监听js报错"><a href="#vue如何监听js报错" class="headerlink" title="vue如何监听js报错"></a>vue如何监听js报错</h3><ol>
<li>errorCaptured生命周期</li>
<li>window.onerror</li>
<li>errorHandler 全局错误处理 <code>app.config.errorHandler = function() &#123;&#125;</code></li>
</ol>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>状态管理模式</p>
<h4 id="包含哪几种属性"><a href="#包含哪几种属性" class="headerlink" title="包含哪几种属性"></a>包含哪几种属性</h4><ul>
<li>state  类似于vue的data mapState映射全局的state的getters到当前组件的computed中 <code>...mapState([&#39;count&#39;])</code></li>
<li>getters 是store的计算属性 可在多组件之间复用 <code>$store.getters.getter名</code></li>
<li>mutation 修改数据 类似methods <code>this.$store.commit(&#39;mutation名&#39;)</code></li>
<li>action 异步修改数据 <code>this.$store.dispatch(&#39;actions的名字&#39;, 参数)</code></li>
<li>module 模块拆分</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第二种访问方式</span><br><span class="hljs-attr">methods</span>: &#123;<br>  ...mapActions([<span class="hljs-string">&#x27;actionsName&#x27;</span>]),<br>  ...mapMutations([<span class="hljs-string">&#x27;mutationName&#x27;</span>])<br>&#125;<br><span class="hljs-attr">computed</span>: &#123;<br>  ...mapGetters([<span class="hljs-string">&#x27;xxx&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="vuex-和-本地存储的区别"><a href="#vuex-和-本地存储的区别" class="headerlink" title="vuex 和 本地存储的区别"></a>vuex 和 本地存储的区别</h3><p>vuex刷新数据会丢失</p>
<h3 id="vue-踩过的坑"><a href="#vue-踩过的坑" class="headerlink" title="vue 踩过的坑"></a>vue 踩过的坑</h3><ol>
<li>给data中的对象直接添加属性并赋值 无效果 删除属性要用vue.delete<br>解决方法：Vue.set(object, attribute, value)新增的属性也是响应式的</li>
<li>在created中操作dom报错，无法获取到dom<br>解决方法：Vue.nextTick()</li>
<li>内存泄漏 全局变量 自定义事件定时器等未销毁 </li>
<li>路由切换时页面scroll到顶部 <ol>
<li>从商品列表页进入到详情页后再返回列表页就会scroll到顶部<br>解决办法：<br>在列表页缓存数据和scrollTop值 当再次返回列表页时，渲染组件执行scrollTo方法<br>mpa+app的new webview 两个页面 </li>
</ol>
</li>
</ol>
<h3 id="如何统一监听vue组件报错"><a href="#如何统一监听vue组件报错" class="headerlink" title="如何统一监听vue组件报错"></a>如何统一监听vue组件报错</h3><ol>
<li>window.onerror 能全局监听所有js错误 但不能识别vue组件信息 window.addEventListener(‘error’)</li>
<li>errorCaptured 在app.vue文件中写 可以监听所有子组件的报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">errorCapturedL (err,vm,info) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;eeror&#x27;</span>,rr,vm,info);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">//可以阻止向上传播到window.error等</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>errorHandler main.js中配置 不会向上传播<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = createApp(App)<br>app.config.errorHandler = <span class="hljs-function">(<span class="hljs-params">error,vm,info</span>) =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li>异步错误 errorHandler捕获不到<br>可以用 全局onerror监听 也可以用unhandledrejection监听</li>
</ol>
<h3 id="vue的渲染过程"><a href="#vue的渲染过程" class="headerlink" title="vue的渲染过程"></a>vue的渲染过程</h3><ol>
<li>调用 compile 函数,生成 render 函数字符串 ,编译过程如下:<ol>
<li>parse 函数解析 template,生成 ast(抽象语法树) </li>
<li>optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)</li>
<li>generate 函数生成 render 函数字符串</li>
</ol>
</li>
<li>调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象</li>
<li>调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</li>
</ol>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><ol>
<li><p>常见分类<br>1xx - 服务器收到请求。<br>2xx - 请求成功，如 200。<br>3xx - 重定向，如 302。<br>4xx - 客户端错误，如 404。<br>5xx - 服务端错误，如 500。</p>
</li>
<li><p>常见状态码<br>200 - 成功。<br>301 - 永久重定向（配合 location，浏览器自动处理）。<br>302 - 临时重定向（配合 location，浏览器自动处理）。<br>304 - 资源未被修改。<br>403 - 没权限。<br>404 - 资源未找到。<br>500 - 服务器错误。<br>504 - 网关超时</p>
</li>
</ol>
<h3 id="https比http的优势"><a href="#https比http的优势" class="headerlink" title="https比http的优势"></a>https比http的优势</h3><p>安全性</p>
<ol>
<li>https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</li>
<li>使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器<br>seo<br>https在搜索结果中的排名会比http更高</li>
</ol>
<h3 id="http工作原理"><a href="#http工作原理" class="headerlink" title="http工作原理"></a>http工作原理</h3><p>HTTP协议工作于客户端-服务端架构上，浏览器作为HTTP客户端通过URL向HTTP服务端发送所有请求。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>支持客户/服务器模式</li>
<li>应用广泛且跨平台</li>
<li>简单快速且灵活</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>无状态</li>
<li>无连接</li>
<li>明文传输 调试遍历但信息易被窃取</li>
<li>不安全 https引入ssl/tls解决这个问题</li>
</ol>
<h3 id="网络分层7层模型"><a href="#网络分层7层模型" class="headerlink" title="网络分层7层模型"></a>网络分层7层模型</h3><p>应用层： 应用层、表示层、会话层（http ftp smtp dns）<br>传输层 （tcp和udp）<br>网络层 （ip）<br>物理和数据链路层 （以太网）</p>
<h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>网络连接是TCP。传输内容是HTTP</p>
<p>第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；<strong>我要传输</strong><br>第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；<strong>服务端收到</strong><br>第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。<strong>客户端收到</strong><br>其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段</p>
<p>第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态； <strong>我要断开</strong><br>第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态； <strong>好的收到，还有一个包</strong><br>第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态； <strong>我数据发送完了，随时关闭</strong><br>第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手  <strong>好的拜拜，你关闭吧，不用恢复</strong><br>A客户端等待2msl 无回复则关闭</p>
<p>理解：</p>
<p>三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。</p>
<p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。</p>
<h3 id="HTTPS-的握手过程"><a href="#HTTPS-的握手过程" class="headerlink" title="HTTPS 的握手过程"></a>HTTPS 的握手过程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012219045/article/details/100537007">https://blog.csdn.net/u012219045/article/details/100537007</a></p>
<ol>
<li>客户端发起HTTPS请求</li>
<li>服务端的配置</li>
<li>传送证书</li>
<li>客户端解析证书</li>
<li>传送加密信息</li>
<li>服务段解密信息</li>
<li>传输加密后的信息</li>
<li>客户端解密信息</li>
</ol>
<h3 id="Get-和-Post"><a href="#Get-和-Post" class="headerlink" title="Get 和 Post"></a>Get 和 Post</h3><ol>
<li>GET是默认的HTTP请求方法 参数以key-value形式存放在url中，get更不安全</li>
<li>get提交数据大小有限制，因为浏览器URL的长度有限制，post没有</li>
<li>get可以被缓存，post不能</li>
<li>get只允许ascii码，post没有限制</li>
</ol>
<h3 id="从-url-被输入到请求返回发生了什么"><a href="#从-url-被输入到请求返回发生了什么" class="headerlink" title="从 url 被输入到请求返回发生了什么"></a>从 url 被输入到请求返回发生了什么</h3><ol>
<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。<ol>
<li>强缓存</li>
<li>协商缓存</li>
</ol>
</li>
<li>DNS 域名解析  域名转化为对应的ip</li>
<li>TCP 连接<blockquote>
<p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</p>
</blockquote>
</li>
<li>HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器渲染页面（important）<ol>
<li>先将HTML加载到浏览器的内部。</li>
<li>从上往下开始解析HTML。</li>
<li>当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。</li>
<li>浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。</li>
<li>HTML解析完毕之后，等待CSS解析。</li>
<li>CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）</li>
<li>在渲染树(Render Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上</li>
</ol>
</li>
<li>断开 TCP 连接</li>
</ol>
<h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>上面</p>
<h3 id="前端缓存的几种缓存方式"><a href="#前端缓存的几种缓存方式" class="headerlink" title="前端缓存的几种缓存方式"></a>前端缓存的几种缓存方式</h3><p>HTTP缓存和浏览器缓存<br>http缓存包括 强缓存和协商缓存 如上面<br>浏览器缓存分为本地存储 即cookie localStorage和sessionStorage 如上 </p>
<h3 id="ajax、axios、fetch的区别"><a href="#ajax、axios、fetch的区别" class="headerlink" title="ajax、axios、fetch的区别"></a>ajax、axios、fetch的区别</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><p>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。</p>
<h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的<br>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p>Axios 是一种基于Promise封装的HTTP客户端</p>
<h3 id="web安全及防护"><a href="#web安全及防护" class="headerlink" title="web安全及防护"></a>web安全及防护</h3><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>通过SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<p>防范措施：</p>
<ol>
<li>密码要加密存储</li>
<li>使用框架及模板提交前检查代码输入内容</li>
<li>所有输入的内容都要进行过滤</li>
</ol>
<h4 id="xss攻击-跨站脚本攻击"><a href="#xss攻击-跨站脚本攻击" class="headerlink" title="xss攻击 跨站脚本攻击"></a>xss攻击 跨站脚本攻击</h4><p>反射型xss<br>基于dom的xss<br>存储型xss</p>
<p>防范措施：</p>
<ol>
<li>输入过滤，前端进行过滤之后后端在写入或访问数据库之前也要进行过滤</li>
<li>在使用innerHtml和outerHtml和document.write等要特别小心，不可信的数据不能插到页面上 v-html也不推荐使用，js的eval()、setTimeout()、setInterval()等会将字符串转成代码运行也不推荐使用</li>
<li>启用CSP（Content Security Policy） 内容安全策略</li>
</ol>
<h4 id="csrf-跨站请求伪造"><a href="#csrf-跨站请求伪造" class="headerlink" title="csrf 跨站请求伪造"></a>csrf 跨站请求伪造</h4><p>引诱受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br>特点：是冒充受害者提交操作<br>防范措施：</p>
<ol>
<li>同源检测 origin header</li>
<li>csrf token请求时携带token</li>
</ol>
<h2 id="webpack-相关"><a href="#webpack-相关" class="headerlink" title="webpack 相关"></a>webpack 相关</h2><h3 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h3><ol>
<li>Entry 入口，Webpack执行构建的第一步将从Entry开始，可抽象成输入</li>
<li>Output 出口，告诉Webpack在哪里输出它打包好的代码以及如何命名，</li>
<li>Module 模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块</li>
<li>Chunk 代码块，一个Chunk由多个模块组合而成，用于代码合并与分割</li>
<li>Loader 模块转换器，用于把模块原内容按照需求转换成新内容</li>
<li>Plugin 扩展插件，在Webpack构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li>
</ol>
<h3 id="webpack的基本功能"><a href="#webpack的基本功能" class="headerlink" title="webpack的基本功能"></a>webpack的基本功能</h3><ol>
<li>代码转化 ts编译成js，scss编译成css</li>
<li>文件优化 压缩js css html代码</li>
<li>代码分割 提取多页面的公共代码，提取首屏不需要执行部分的代码让其异步加载</li>
<li>模块合并 在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li>
<li>自动刷新 自动构建，刷新浏览器</li>
<li>代码校验 在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li>
<li>自动发布 更新完代码后，自动构建出线上发布代码并传输给发布系统</li>
</ol>
<h3 id="Webpack如何配置多入口文件"><a href="#Webpack如何配置多入口文件" class="headerlink" title="Webpack如何配置多入口文件"></a>Webpack如何配置多入口文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">entry: &#123;<br>  <span class="hljs-attr">home</span>: resolve(__dirname, <span class="hljs-string">&quot;src/home/index.js&quot;</span>),<br>  <span class="hljs-attr">about</span>: resolve(__dirname, <span class="hljs-string">&quot;src/about/index.js&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><p>loader是<strong>文件加载器</strong>，能够加载资源文件，并对文件进行一些处理，如编译，压缩 等，最终一起打包到指定的文件中，loader运行在<strong>项目打包</strong>之前</p>
<p>plugin赋予了webpack各种灵活的<strong>功能</strong>，如打包优化，资源管理，环境变量，注入等，目的是为了解决loader无法实现的功能，plugins运行在整个项目的<strong>编译</strong>时期</p>
<h3 id="常见-loader"><a href="#常见-loader" class="headerlink" title="常见 loader"></a>常见 loader</h3><ol>
<li>css-loader读取合并CSS文件</li>
<li>style-loader把CSS内容注入到JavaScript里</li>
<li>sass-loader解析sass文件（安装sass-loader，node-sass）</li>
<li>postcss-loader自动添加浏览器兼容前缀（postcss.config配置）</li>
<li>url-loader将文件转换为base64 URI。</li>
<li>vue-loader处理vue文件</li>
</ol>
<h3 id="常见-plugins"><a href="#常见-plugins" class="headerlink" title="常见 plugins"></a>常见 plugins</h3><p>HtmlWbpackPlugin自动在打包结束后生成html文件，并引入bundle.js<br>cleanwebPackPlugin打包自动删除上次打包文件<br>uglifyjs-webpack-plugin（js代码丑化压缩）</p>
<h3 id="webpack-打包的流程"><a href="#webpack-打包的流程" class="headerlink" title="webpack 打包的流程"></a>webpack 打包的流程</h3><ol>
<li><strong>初始化参数</strong>  webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数</li>
<li><strong>编译准备</strong> 这一步我们会通过调用webpack()方法返回一个compiler对象，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译</li>
<li><strong>模块编译</strong> 从入口模块进行分析，调用匹配文件的loaders对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作</li>
<li><strong>完成编译</strong> 在递归完成后，每个引用模块通过loaders处理完成同时得到模块之间的相互依赖关系</li>
<li><strong>输出文件</strong> 整理模块依赖关系，同时将处理后的文件输出到ouput的磁盘目录中。</li>
</ol>
<h2 id="typescript-和-vue3-相关"><a href="#typescript-和-vue3-相关" class="headerlink" title="typescript 和 vue3 相关"></a>typescript 和 vue3 相关</h2><h3 id="ts比js的优势"><a href="#ts比js的优势" class="headerlink" title="ts比js的优势"></a>ts比js的优势</h3><p>ts是js的超集，在js的基础上添加了<strong>类型系统</strong>，用于强大的<strong>静态类型检查</strong>能力，并且继承了js的所有编程类型，js代码在ts环境也可以很好的运行</p>
<h3 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h3><ol>
<li>双向数据绑定的原理发生了改变 defineProperty和proxy</li>
<li>最大区别： composition api组合式api 与 vue2的options api相比更简便和整洁</li>
<li>生命周期钩子变了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue2--------------vue3<br>beforeCreate  -&gt; setup()<br>created       -&gt; setup()<br>beforeMount   -&gt; onBeforeMount<br>mounted       -&gt; onMounted<br>beforeUpdate  -&gt; onBeforeUpdate<br>updated       -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed     -&gt; onUnmounted<br>activated     -&gt; onActivated<br>deactivated   -&gt; onDeactivated<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><h3 id="echarts-js图表宽度自适应的问题"><a href="#echarts-js图表宽度自适应的问题" class="headerlink" title="echarts.js图表宽度自适应的问题"></a>echarts.js图表宽度自适应的问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单个图表</span><br><span class="hljs-built_in">window</span>.onresize = myChart.resize;   <br><br><span class="hljs-comment">//多个图标可以这样写：</span><br><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.myChart.resize()<br>    <span class="hljs-built_in">this</span>.myChart1.resize()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="echarts标签文字过多导致显示不全解决方案"><a href="#echarts标签文字过多导致显示不全解决方案" class="headerlink" title="echarts标签文字过多导致显示不全解决方案"></a>echarts标签文字过多导致显示不全解决方案</h3><h4 id="echarts-x轴标签文字过多导致显示不全"><a href="#echarts-x轴标签文字过多导致显示不全" class="headerlink" title="echarts x轴标签文字过多导致显示不全"></a>echarts x轴标签文字过多导致显示不全</h4><p>解决办法1：xAxis.axisLabel 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">axisLabel: &#123;  <br>  <span class="hljs-attr">interval</span>:<span class="hljs-number">0</span>,  <br>  <span class="hljs-attr">rotate</span>:<span class="hljs-number">40</span>  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>解决办法2：调用formatter文字竖直显示 axisLabel的Formartter方法</p>
<h2 id="uniapp-相关"><a href="#uniapp-相关" class="headerlink" title="uniapp 相关"></a>uniapp 相关</h2><h3 id="谈谈你对uniapp的理解"><a href="#谈谈你对uniapp的理解" class="headerlink" title="谈谈你对uniapp的理解"></a>谈谈你对uniapp的理解</h3><p>uni-app是一个使用vue.js开发所有前端应用的框架，开发编写一套代码，可以发布到多个平台<br>优点：</p>
<ol>
<li>跨平台</li>
<li>运行体验良好</li>
<li>开放生态，组件丰富</li>
<li>通用技术栈<br>缺点：</li>
<li>动画使用不方便，css动画多了会卡顿</li>
<li>兼容性问题较多</li>
</ol>
<h3 id="uni中如何为不同的平台设置不同的代码"><a href="#uni中如何为不同的平台设置不同的代码" class="headerlink" title="uni中如何为不同的平台设置不同的代码"></a>uni中如何为不同的平台设置不同的代码</h3><ol>
<li>条件注释<br>以 #ifdef 或 #ifndef 加 %PLATFORM% 开头，以 #endif 结尾<br><code>#ifdef APP-PLUS  ...$content...  #endif</code></li>
</ol>
<h3 id="uniapp中封装接口请求相较于微信小程序有什么要注意的"><a href="#uniapp中封装接口请求相较于微信小程序有什么要注意的" class="headerlink" title="uniapp中封装接口请求相较于微信小程序有什么要注意的"></a>uniapp中封装接口请求相较于微信小程序有什么要注意的</h3><p>如果uniapp要在web端进行适配,要注意请求跨域问题—需要配置代理;可以通过在 vue.config.js 中配置Proxy代理解决</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">devServer: &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/xxx-api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="uni-app中的本地存储数据和接收数据是什么"><a href="#uni-app中的本地存储数据和接收数据是什么" class="headerlink" title="uni-app中的本地存储数据和接收数据是什么"></a>uni-app中的本地存储数据和接收数据是什么</h3><p>存储： uni.setStorageSync(‘name’,‘LZJAPYX,ZDL’);<br>获取： uni.getStorageSync(‘name’) // 以健名取键值<br>删除： uni.removeStorageSync(‘name’) // 删除该键名的数据<br>异步存储：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存</span><br>uni.setStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;你好，word&quot;</span>      <span class="hljs-comment">// 键值</span><br>&#125;);<br><span class="hljs-comment">// 取</span><br>uni.getStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log.(res.data)    <span class="hljs-comment">// 你好，word</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 删</span><br>uni.reomveStorage(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;name&quot;</span>,          <span class="hljs-comment">// 键名</span><br>    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log.(res)    <span class="hljs-comment">// ok</span><br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h3 id="uni-app-路由与页面跳转"><a href="#uni-app-路由与页面跳转" class="headerlink" title="uni-app 路由与页面跳转"></a>uni-app 路由与页面跳转</h3><ol>
<li>uni.navigateTo({url: “/路径?参数=参数值”});    保留当前页面，只能跳转非tabBar页面</li>
<li>uni.switchTab({url: “/路径?参数=参数值”});    关闭所有非tabbar页面，只能打开tabbar页面</li>
<li>uni.redirectTo({url: “/路径?参数=参数值”});    关闭卸载当前页面，只能打开非tabBar页面</li>
<li>uni.reLaunch({url: “/路径?参数=参数值”});    关闭卸载所有页面，可以打开任意页面</li>
<li>uni.navigateBack({delta: 2});    返回上一页面 delta：返回页数</li>
<li>标签&lt; navigator &gt;    open-type属性决定跳转方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;navigator url=<span class="hljs-string">&quot;../message/message?id=99&quot;</span>&gt;界面跳转传参&lt;/navigator&gt;<br><br><span class="hljs-comment">//获取路由参数，在界面的onLoad方法中获取</span><br><span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params">options</span>)</span> &#123;<br>	<span class="hljs-built_in">console</span>.log(options)<br>&#125;,<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="uni-app全局变量怎么定义，怎么获取"><a href="#uni-app全局变量怎么定义，怎么获取" class="headerlink" title="uni-app全局变量怎么定义，怎么获取"></a>uni-app全局变量怎么定义，怎么获取</h3><p>在app.js中设置globalData设置，在需要的地方的js文件let app=getApp() app.globalData.数据</p>
<h3 id="uni中生命周期"><a href="#uni中生命周期" class="headerlink" title="uni中生命周期"></a>uni中生命周期</h3><ul>
<li>app页面<ul>
<li>onLaunch    当uni-app 初始化完成时触发（全局只触发一次）</li>
<li>onShow    当 uni-app 启动，或从后台进入前台显示</li>
<li>onHide    当 uni-app 从前台进入后台</li>
<li>onError    当 uni-app 报错时触发</li>
<li>onUniNViewMessage    对 nvue 页面发送的数据进行监听</li>
<li>onUnhandledRejection    对未处理的 Promise 拒绝事件监听函数</li>
<li>onPageNotFound    页面不存在监听函数</li>
<li>onThemeChange    监听系统主题变化</li>
</ul>
</li>
<li>pages页面 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ytfty24124/article/details/128087256">参考</a><ul>
<li>onInit</li>
<li>onLoad</li>
<li>onShow</li>
<li>onReady</li>
<li>onHide</li>
<li>onUnload</li>
<li>onResize</li>
<li>onPullDownRefresh</li>
<li>onReachBottom</li>
<li>onTabItemTop</li>
</ul>
</li>
<li>vue生命周期</li>
</ul>
<h3 id="提高微信小程序速度的方法"><a href="#提高微信小程序速度的方法" class="headerlink" title="提高微信小程序速度的方法"></a>提高微信小程序速度的方法</h3><ol>
<li>控制代码包的大小：<ol>
<li>代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项</li>
<li>及时清理无用的代码和资源文件</li>
<li>减少资源包中的图片等资源的数量和大小</li>
</ol>
</li>
<li>分包加载,预加载：<ol>
<li>将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包</li>
</ol>
</li>
<li>预请求：<ol>
<li>请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地</li>
</ol>
</li>
<li>避免不当的使用setData：<ol>
<li>不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用</li>
</ol>
</li>
<li>使用自定义组件：<ol>
<li>对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用</li>
</ol>
</li>
</ol>
<h2 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h2><h3 id="前端性能优化的措施-整理"><a href="#前端性能优化的措施-整理" class="headerlink" title="前端性能优化的措施 整理"></a>前端性能优化的措施 整理</h3><ul>
<li>html css js<ul>
<li><strong>雪碧图 base64等减少请求数量</strong></li>
<li><strong>图片懒加载</strong></li>
<li>使用webp格式的图片 <strong>压缩html，css，js和图片</strong></li>
<li>注意资源加载位置，加载时机，可添加异步script标签</li>
<li>不使用css @import 会导致css无法并行下载，有个依赖顺序，会加长css解析延迟的时间</li>
<li>能用css实现的效果就不要用js实现</li>
<li>少用css表达式，计算评率太高</li>
</ul>
</li>
<li>dom相关<ul>
<li>给元素设置高度或者最小高度，以防页面晃动</li>
<li>图片设置尺寸，不然从无到有会有回流</li>
<li><strong>需要多次重绘的元素开启GPU加速</strong>  transform opacity filter<ul>
<li>transform: translate3d(xx,xx,xx);</li>
<li>transform: translateZ(0); left这些每次都会触发repaint会有卡顿现象</li>
</ul>
</li>
<li>批量操作dom，减少dom操作次数，拼接完字符串再更新dom</li>
<li><strong>事件代理</strong></li>
<li><strong>防抖和节流</strong></li>
</ul>
</li>
<li>网络相关<ul>
<li>使用<strong>缓存</strong></li>
<li><strong>开启gzip压缩</strong></li>
<li>使用cdn</li>
</ul>
</li>
<li>打包相关<ul>
<li>打包公共代码 CommonsChunkPlugin插件</li>
<li>动态导入和<strong>按需加载</strong></li>
<li>删除无用代码 treeShaking uglifyjs和purifyCSS</li>
</ul>
</li>
</ul>
<h3 id="h5页面首屏优化"><a href="#h5页面首屏优化" class="headerlink" title="h5页面首屏优化"></a>h5页面首屏优化</h3><ol>
<li>路由懒加载<ol>
<li>适用于spa </li>
<li>路由拆分</li>
</ol>
</li>
<li>ssr服务器端渲染<ol>
<li>如果是纯h5页面，ssr是性能优化的最佳方案 nuxtjs nextjs</li>
</ol>
</li>
<li>app预取 app h5 jsbridge</li>
<li>分页<ol>
<li>针对列表页</li>
<li>默认只展示第一页内容</li>
<li>上划加载更多</li>
</ol>
</li>
<li>图片懒加载<ol>
<li>针对详情页</li>
<li>默认只展示文本内容，然后触发图片懒加载</li>
<li>注意提前设置图片尺寸，尽量只重绘不重排</li>
</ol>
</li>
</ol>
<p>注意要 结合优化结果分析，比如优化完之后首屏渲染速度提升了0.5s</p>
<h3 id="vue-首屏加载优化方案"><a href="#vue-首屏加载优化方案" class="headerlink" title="vue 首屏加载优化方案"></a>vue 首屏加载优化方案</h3><ol>
<li>使用cdn加载第三方库</li>
<li>图片资源压缩（精灵图）和使用图片懒加载（虚拟列表可以讲讲）</li>
<li>vue-router路由懒加载</li>
<li>gzip压缩 webpack中使用compression-webpack-plugin插件</li>
<li>移除 编译文件中的map文件 <code>productionSourceMap: false</code></li>
<li>代码层面优化 <ol>
<li>合理使用v-if和v-show</li>
<li>记得及时销毁定时器 更多的参考上方前端性能优化</li>
</ol>
</li>
</ol>
<h3 id="实际工作中做过哪些vue优化"><a href="#实际工作中做过哪些vue优化" class="headerlink" title="实际工作中做过哪些vue优化"></a>实际工作中做过哪些vue优化</h3><ol>
<li>v-if（彻底销毁）和v-show（css隐藏组件）</li>
<li>v-for使用key</li>
<li>computed缓存</li>
<li>keep-alive组件 如tabs</li>
<li>把异步组件拆包出来 需要时异步加载 不需要的时候不加载 加快首页的加载 defineAsyncComponent</li>
<li>路由懒加载 component <code>()=&gt; import(&#39;xxx&#39;)</code></li>
<li>ssr</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="单元测试相关"><a href="#单元测试相关" class="headerlink" title="单元测试相关"></a>单元测试相关</h3><p>当前单元测试主要工具有Mocha和Jest<br>Mocha+Chai<br>Jest的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./sum&#x27;</span>);<br><br>describe(<span class="hljs-string">&#x27;sum function test&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&#x27;sum(1, 2) === 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    expect(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  <span class="hljs-comment">// 这里 test 和 it 没有明显区别，it 是指: it should xxx, test 是指 test xxx</span><br>  test(<span class="hljs-string">&#x27;sum(1, 2) === 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    expect(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>配置test在package.json中<br><code>scripts: &#123;&quot;test&quot;: &quot;jest&quot;&#125;</code> npm run test即可</p>
<p>必须要用require的方式引用被测试方法，因为import是es6的模块化关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; fetchUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../src/fetchUser&#x27;</span>;<br><br>test(<span class="hljs-string">&#x27;fetchUser() 可以请求到一个用户名字为 moji&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data =  <span class="hljs-keyword">await</span> fetchUser();<br><br>  expect(data.name).toBe(<span class="hljs-string">&#x27;moji&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 测试异步函数需要添加插件@babel/plugin-transform-runtime，因为默认babel/preset-env不支持async await</span><br></code></pre></td></tr></table></figure>

<h3 id="svg的优势"><a href="#svg的优势" class="headerlink" title="svg的优势"></a>svg的优势</h3><p>svg是可伸缩矢量图形</p>
<ol>
<li>svg图像可以被任意的文本编辑器创建和编辑</li>
<li>svg图像可以被搜索、索引化和脚本化，可压缩性更强</li>
<li>svg图像是可伸缩的</li>
<li>svg可在任何分辨率下被高质量打印 </li>
</ol>
<h3 id="后端如果一次性返回10万条数据，怎么渲染"><a href="#后端如果一次性返回10万条数据，怎么渲染" class="headerlink" title="后端如果一次性返回10万条数据，怎么渲染"></a>后端如果一次性返回10万条数据，怎么渲染</h3><ol>
<li>首先 这个设计不合理</li>
<li>自定义nodejs中间层 获取并拆分这10w条数据 成本过高</li>
<li>虚拟列表<ol>
<li>只渲染可视区域DOM 其他都用空div撑起高度 借用第三方lib vue-virtual-scroll-list 不建议用，实现复杂且效果不一定好</li>
</ol>
</li>
</ol>
<h3 id="前端常用的设计模式有哪些，并说明使用场景"><a href="#前端常用的设计模式有哪些，并说明使用场景" class="headerlink" title="前端常用的设计模式有哪些，并说明使用场景"></a>前端常用的设计模式有哪些，并说明使用场景</h3><ul>
<li>开放封闭原则<ol>
<li>对扩展开放</li>
<li>对修改封闭</li>
</ol>
</li>
</ul>
<ol>
<li>工厂模式<br>jQuery这种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factory</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo()<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>单例模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>  private <span class="hljs-keyword">static</span> instance: SingleTon | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br>  private <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>  public <span class="hljs-keyword">static</span> getInstance(): singleTon &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.instance === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> SingleTon()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> s = SingleTon.getInstance()<br></code></pre></td></tr></table></figure></li>
<li>代理模式 ES6 proxy</li>
<li>观察者模式 addEventListener监听事件</li>
<li>发布订阅模式 event.on event.emit()</li>
<li>装饰器模式 原功能不变，增加一些新功能  Decorator</li>
</ol>
<h3 id="观察者模式和发布订阅模式的区别"><a href="#观察者模式和发布订阅模式的区别" class="headerlink" title="观察者模式和发布订阅模式的区别"></a>观察者模式和发布订阅模式的区别</h3><p>subject和observer直接绑定没有中间媒介 ：addEventListern<br>Publisher和observer互不认识，需要中间媒介event channel ：EventBus<br>发布订阅模式相比观察者模式多了一个调度中心<br>发布订阅模式是在观察者模式的基础上做的优化升级。观察者模式是发布订阅模式的一种特殊实现<br>观察者和被观察者，是松耦合的关系<br>发布者和订阅者，则完全解耦</p>
<h3 id="如果一个h5很慢，你该如何排查性能问题"><a href="#如果一个h5很慢，你该如何排查性能问题" class="headerlink" title="如果一个h5很慢，你该如何排查性能问题"></a>如果一个h5很慢，你该如何排查性能问题</h3><ul>
<li>前端性能指标 <ul>
<li>first paint (fp)</li>
<li>first contentful paint (fp)</li>
<li>domContentload(dcl)</li>
<li>load(l)</li>
</ul>
</li>
</ul>
<p>用chrome的devtools的 performance 可以看到上述各指标的时间<br>性能分析工具 lighthouse</p>
<h3 id="遇到最困难的问题是啥-怎么解决"><a href="#遇到最困难的问题是啥-怎么解决" class="headerlink" title="遇到最困难的问题是啥 怎么解决"></a>遇到最困难的问题是啥 怎么解决</h3><p>动态换肤 scss变量</p>
<ol>
<li>对于 element-plus：因为 element-plus 是第三方的包，所以它 不是完全可控 的，那么对于这种最简单直白的方案，就是直接拿到它编译后的 css 进行色值替换，利用 style 内部样式表 优先级高于 外部样式表 的特性，来进行主题替换<ol>
<li>获取当前elementplus的所有样式</li>
<li>定义我们要替换之后的样式</li>
<li>在原样式中，利用正则替换新样式</li>
<li>把替换后的样式写入到新style标签中</li>
</ol>
</li>
<li>对于自定义主题：因为自定义主题是 完全可控 的，所以我们实现起来就轻松很多，只需要修改对应的 scss变量即可</li>
</ol>
<p>jsx实现无限层级</p>
<ul>
<li>树形结构</li>
<li>表格行可拖拽</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7031322059414175774">参考 1</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7061588533214969892">参考 2</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/14/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/">
                        <span class="hidden-mobile">后台管理系统登录功能的实现</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"SENRU08HPXafOGhG2XAwDq4Q-gzGzoHsz","appKey":"SmBXysKuOGYdFfLXpPenWmvh","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/ZhangKai66" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        苏ICP备202102904号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
