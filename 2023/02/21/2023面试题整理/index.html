

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/ultraman.png">
  <link rel="icon" href="/img/ultraman.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="记录学习前端的历程">
  <meta name="author" content="Kai Zhang">
  <meta name="keywords" content="前端,frontend">
  <meta name="description" content="js 手写题手写深拷贝1234567891011121314151617181920212223242526272829303132function deepClone(obj &#x3D; &amp;#123;&amp;#125;) &amp;#123;  &#x2F;&#x2F; 是null或者不是对象和数组 直接返回  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D; null) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="2023面试题整理">
<meta property="og:url" content="https://zhangkai66.github.io.git/2023/02/21/2023%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="ZhangKai&#39;s Blog">
<meta property="og:description" content="js 手写题手写深拷贝1234567891011121314151617181920212223242526272829303132function deepClone(obj &#x3D; &amp;#123;&amp;#125;) &amp;#123;  &#x2F;&#x2F; 是null或者不是对象和数组 直接返回  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D; null) &amp;#123;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-21T08:31:32.000Z">
<meta property="article:modified_time" content="2023-02-21T08:32:25.876Z">
<meta property="article:author" content="Kai Zhang">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
  
  <title>2023面试题整理 - ZhangKai&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhangkai66.github.io.git","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jamarcus</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/beach.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="2023面试题整理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-21 16:31" pubdate>
        February 21, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      35 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">2023面试题整理</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：a few seconds ago
                
              </p>
            
            <div class="markdown-body">
              <h2 id="js-手写题"><a href="#js-手写题" class="headerlink" title="js 手写题"></a>js 手写题</h2><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 是null或者不是对象和数组 直接返回</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>    result = [];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(item)) &#123;<br>      <span class="hljs-comment">// 保证key不是原型的属性</span><br>      result[item] = deepClone(obj[item]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 方法2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-comment">// 1 判断是否是非应用类型或者null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-comment">// 2 创建一个容器</span><br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor()<br>    <span class="hljs-comment">// 3 拿到对象的keys，给容器赋值</span><br>    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> cloneObj[v] = deepClone(obj[v]))<br>    <span class="hljs-comment">// 4 返回容器</span><br>    <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="手写-call-apply-bind-函数"><a href="#手写-call-apply-bind-函数" class="headerlink" title="手写 call apply bind 函数"></a>手写 call apply bind 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="手写一个简易的jquery，考虑插件和扩展性"><a href="#手写一个简易的jquery，考虑插件和扩展性" class="headerlink" title="手写一个简易的jquery，考虑插件和扩展性"></a>手写一个简易的jquery，考虑插件和扩展性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.querySelectorAll(Selector);<br>    <span class="hljs-keyword">const</span> length = result.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;length;i++) &#123;<br>      <span class="hljs-built_in">this</span>[i] = result[i]<br>    &#125;<br>    <span class="hljs-built_in">this</span>.length = length<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">index</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[index]<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">each</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.length;i++) &#123;<br>      <span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">this</span>[i];<br>      fn(elem)<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type,fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.each(<span class="hljs-function"><span class="hljs-params">elem</span> =&gt;</span> &#123;<br>      elem.addEventListener(type,fn,<span class="hljs-literal">false</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 插件</span><br>jQuery.prototype.dialog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>&#123;<br>  alert(info)<br>&#125;<br><br><span class="hljs-comment">// 造轮子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJquery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">jQuery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">selector</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(selector);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="手写-new-函数"><a href="#手写-new-函数" class="headerlink" title="手写 new 函数"></a>手写 new 函数</h3><h3 id="事件总线-发布订阅模式-event-bus-（EventMitter）"><a href="#事件总线-发布订阅模式-event-bus-（EventMitter）" class="headerlink" title="事件总线 | 发布订阅模式 event bus （EventMitter）"></a>事件总线 | 发布订阅模式 event bus （EventMitter）</h3><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h3 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h3><h3 id="实现简单的-promise"><a href="#实现简单的-promise" class="headerlink" title="实现简单的 promise"></a>实现简单的 promise</h3><h3 id="手写-deep-clone"><a href="#手写-deep-clone" class="headerlink" title="手写 deep clone"></a>手写 deep clone</h3><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><h3 id="异步控制并发数"><a href="#异步控制并发数" class="headerlink" title="异步控制并发数"></a>异步控制并发数</h3><h3 id="es5-和-es6-继承"><a href="#es5-和-es6-继承" class="headerlink" title="es5 和 es6 继承"></a>es5 和 es6 继承</h3><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><h3 id="获取-url-参数"><a href="#获取-url-参数" class="headerlink" title="获取 url 参数"></a>获取 url 参数</h3><h2 id="html-amp-css-相关"><a href="#html-amp-css-相关" class="headerlink" title="html&amp;css 相关"></a>html&amp;css 相关</h2><h3 id="html语义化标签怎么理解"><a href="#html语义化标签怎么理解" class="headerlink" title="html语义化标签怎么理解"></a>html语义化标签怎么理解</h3><ul>
<li>让人更容易读懂</li>
<li>让搜索引擎更容易读懂，有利于爬虫爬取更多的有效信息</li>
<li>没有css情况下，也能呈现很好的内容结构</li>
</ul>
<h3 id="script-标签的-defer-和-async-区别"><a href="#script-标签的-defer-和-async-区别" class="headerlink" title="script 标签的 defer 和 async 区别"></a>script 标签的 defer 和 async 区别</h3><p>script: 会阻碍html解析，只有下载好并执行完脚本才会继续解析html<br>async script: 解析html过程中会进行脚本的异步下载，下载成功立马执行，有可能阻断html的解析 <strong>异步下载，立即执行</strong><br>defer script: 完全不阻碍html的解析，解析完成后再按照顺序执行脚本 <strong>异步下载，解析完执行</strong></p>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>两种盒模型：标准盒模型、IE盒模型<br>相同点：都是由 content + padding + border + margin构成<br>不同点：盒子内容的宽/高度<br>标准盒模型： 只包含content    box-sizin: content-box<br>IE盒模型： content + padding + border box-sizing: border-box</p>
<h3 id="选择器及其优先级"><a href="#选择器及其优先级" class="headerlink" title="选择器及其优先级"></a>选择器及其优先级</h3><p>!important &gt; style(内联) &gt; id &gt; class</p>
<h3 id="reflow（重排-回流）和-repaint（重绘）理解"><a href="#reflow（重排-回流）和-repaint（重绘）理解" class="headerlink" title="reflow（重排/回流）和 repaint（重绘）理解"></a>reflow（重排/回流）和 repaint（重绘）理解</h3><h4 id="重排-回流："><a href="#重排-回流：" class="headerlink" title="重排/回流："></a>重排/回流：</h4><p><strong>第一次确定节点的大小和位置，称为布局，之后针对节点大小，位置改变重新计算称之为回流</strong><br>元素的<strong>几何信息</strong>被影响导致浏览器需要<strong>重新计算</strong>元素在视口内的几何属性（位置和尺寸）</p>
<h4 id="引发回流的几种情况"><a href="#引发回流的几种情况" class="headerlink" title="引发回流的几种情况"></a>引发回流的几种情况</h4><ol>
<li>DOM结构发生变改变，如添加新的节点或者移除节点</li>
<li>改变布局，如修改了width height padding font-size等值。</li>
<li>改变窗口 resize,修改了窗口的尺寸。</li>
<li>调用 getComputedStyle方法获取尺寸、位置信息。</li>
</ol>
<h4 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h4><p><strong>第一次渲染内容称之为绘制，之后重新渲染称之为重绘</strong><br>通过构造渲染树和重排（回流）阶段，我们知道了可见节点的样式和具体的几何信息，接下来将渲染树的每个节点转换为屏幕上的<strong>实际像素</strong>的阶段</p>
<h4 id="引发重绘的几种情况"><a href="#引发重绘的几种情况" class="headerlink" title="引发重绘的几种情况"></a>引发重绘的几种情况</h4><p>修改背景色、文字颜色、边框颜色、样式等。</p>
<h3 id="如何减少重排和重绘"><a href="#如何减少重排和重绘" class="headerlink" title="如何减少重排和重绘"></a>如何减少重排和重绘</h3><ul>
<li>最小化重绘和重排，修改样式尽量集中一次性修改</li>
<li>尽量避免频繁的操作DOM</li>
<li>批量操作DOM 比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中</li>
<li>尽量避免通过 <code>getComputedStyle</code> 获取尺寸位置信息</li>
<li>使用 <strong>absolute</strong> 或 <strong>fixed</strong> 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显</li>
<li>开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染(每个合成层都是单独渲染的)。当元素的内容没有发生改变，就没有必要进行重绘</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903779700047885">参考</a></p>
<h3 id="BFC-的理解"><a href="#BFC-的理解" class="headerlink" title="BFC 的理解"></a>BFC 的理解</h3><p>block format context: 块级格式上下文</p>
<h3 id="实现两栏布局（左侧固定和右侧自适应）-5-种"><a href="#实现两栏布局（左侧固定和右侧自适应）-5-种" class="headerlink" title="实现两栏布局（左侧固定和右侧自适应） 5 种"></a>实现两栏布局（左侧固定和右侧自适应） 5 种</h3><h3 id="实现圣杯布局和双飞翼布局（三分栏）"><a href="#实现圣杯布局和双飞翼布局（三分栏）" class="headerlink" title="实现圣杯布局和双飞翼布局（三分栏）"></a>实现圣杯布局和双飞翼布局（三分栏）</h3><h3 id="水平垂直居中的实现"><a href="#水平垂直居中的实现" class="headerlink" title="水平垂直居中的实现"></a>水平垂直居中的实现</h3><h3 id="flex：1-的含义"><a href="#flex：1-的含义" class="headerlink" title="flex：1 的含义"></a>flex：1 的含义</h3><p>flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。<br>flex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。<br>flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 .</p>
<h3 id="line-height-如何继承"><a href="#line-height-如何继承" class="headerlink" title="line-height 如何继承"></a>line-height 如何继承</h3><h2 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h2><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>值类型的变量直接存储数据（<strong>栈</strong>上），而引用类型的变量持有的是数据的引用（地址），数据存储在数据<strong>堆</strong>中。</p>
<p>引用类型：当<strong>声明</strong>一个类时，只在<strong>栈</strong>中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 <strong>new</strong> 创建一个类的实例时，分配<strong>堆</strong>上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</p>
<h3 id="typeof-能判断哪些类型"><a href="#typeof-能判断哪些类型" class="headerlink" title="typeof 能判断哪些类型"></a>typeof 能判断哪些类型</h3><p>所有类型：undefined null(特殊引用类型，指向空地址) string number boolean symbol function(特殊引用类型)</p>
<ol>
<li>识别所有值类型</li>
<li>识别函数 返回 ‘function’</li>
<li>判断是否是引用类型</li>
</ol>
<p>注意： typeof null | [1,2]  =&gt; “object”</p>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h3><p>== 只要求值相等即可 即经过类型转换为同一类型后值相等即可<br>=== 不仅值相等 类型也要相同</p>
<p>使用过程中，除了 == null 之外，其他一律用 ===<br>if(obj.a == null) 等价于 if(obj.a === null || obj.a === undefined)</p>
<p>truly变量： !!a === true的变量<br>falsely变量  !!a === false的变量 ( 0 NaN “” null undefined false )</p>
<p>逻辑判断：<br>10 &amp;&amp; 0 前面是truly值，&amp;&amp;直接返回后面的值<br>“” || ‘abc’ 前面是falsely值， ||直接返回后面的值</p>
<h3 id="为啥-0-1-0-2-！-0-3"><a href="#为啥-0-1-0-2-！-0-3" class="headerlink" title="为啥 0.1+0.2 ！== 0.3"></a>为啥 0.1+0.2 ！== 0.3</h3><p>是由于浮点数运算的精度问题（精度是有限的）导致等式左右的结果不严格相等<br>浮点数转成二进制是无限循环的，所以计算机中只能存储一个近似值</p>
<p>正确的比较方法 是使用js提供的最小精度值 Number.EPSILON<br><code>Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON</code></p>
<h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><p>原型：<br>每个class都有显式原型prototype<br>每个class实例化后的对象都有隐式原型__proto__<br>实例的隐式原型指向对应class的显式原型<br>class类具有定义的属性和方法，也有显式原型prototype。而将这个class类实例化后就有了隐式原型__proto__，即shilihua.proto === Student.proptotype</p>
<p>原型链：<br>首先，每个对象在初始化的时候都会被添加上__proto__属性，指向该对象的原型对象，同时在js中万物皆对象，所以该对象的原型对象也有__proto__属性指向它的原型对象，这样一直指下去就会形成一个原型形成的链，简称原型链。</p>
<h3 id="如何判断一个变量是不是数组"><a href="#如何判断一个变量是不是数组" class="headerlink" title="如何判断一个变量是不是数组"></a>如何判断一个变量是不是数组</h3><p>param instanceof Array (return true/false)</p>
<p>xialuo instanceof Student  (true)</p>
<h3 id="class的原型本质，怎么理解"><a href="#class的原型本质，怎么理解" class="headerlink" title="class的原型本质，怎么理解"></a>class的原型本质，怎么理解</h3><p>TODO:原型和原型链的图示</p>
<p>class可以理解为一个模板，本质就是一个函数，通过constructor构造方法来构造一些属性和方法，然后通过new关键字来实例化这个类<br>继承： 子类在自身的constructor方法中用super关键字调用父类的constuctor方法</p>
<h3 id="js的几种继承方式"><a href="#js的几种继承方式" class="headerlink" title="js的几种继承方式"></a>js的几种继承方式</h3><p>TODO:</p>
<ul>
<li>原型继承：</li>
</ul>
<p>优点：通过原型继承多个引用类型的属性和方法</p>
<p>缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。</p>
<ul>
<li>盗用构造函数</li>
</ul>
<p>优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染</p>
<p>缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）</p>
<ul>
<li>组合继承</li>
</ul>
<p>优点： 集合了原型继承和盗用构造函数继承的优点</p>
<p>缺点：存在效率问题，Super始终会被调用两次</p>
<ul>
<li>原型式继承</li>
</ul>
<p>优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性</p>
<p>缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染</p>
<ul>
<li>寄生式继承</li>
</ul>
<p>优点：根据一个对象克隆创建另一个对象，并增强对象</p>
<p>缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍</p>
<ul>
<li>寄生式组合继承</li>
</ul>
<p>优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>作用域（scope） ：当前的<strong>执行上下文</strong>，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。作用域最大的用处就是<strong>隔离变量</strong>，不同作用域下的同名变量不会有冲突。</p>
<ul>
<li>全局作用域 （最外层定义的变量和函数，未定义并直接赋值的变量-变量提升，window对象的属性）</li>
<li>函数作用域 （函数内部定义的变量）</li>
<li>块级作用域 （let const声明的变量）</li>
</ul>
<p>作用域链</p>
<ul>
<li>自由变量 当前作用域中没有定义的变量，称为自由变量。</li>
<li>作用域链  访问变量时，自己的作用域中没有，一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃，这种一层一层的关系，就是作用域链</li>
<li>作用域与执行上下文的区别<ul>
<li>解释阶段（作用域规则确定）</li>
<li>执行阶段（执行上下文）</li>
</ul>
</li>
</ul>
<p>执行上下文在运行时确定（this的指向问题），随时可能改变，作用域（变量的值）在定义时就确定，并且不会改变。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol>
<li><p>有权访问其他函数作用域中变量得函数</p>
</li>
<li><p>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 = 函数 + 函数能够访问的自由变量</p>
</li>
</ol>
<p>所有（闭包）自由变量的查找 是在函数定义的地方，向上级作用域查找 不是在执行的地方</p>
<h4 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h4><p>在一个函数内部创建另一个函数</p>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><p>可以阻止变量被回收 </p>
<h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><p>比普通函数更加占用内存，可能造成内存泄漏，不会被垃圾回收机制回收</p>
<h4 id="闭包的实际应用场景"><a href="#闭包的实际应用场景" class="headerlink" title="闭包的实际应用场景"></a>闭包的实际应用场景</h4><p>循环绑定监听事件,给标签循环添加监听事件<br>解决方式：1. 立即执行函数 2. es6声明 let const等（如下）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a,i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里面的i都是10</span><br>&#125;<br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>  <span class="hljs-comment">// 这里都是块级作用域</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>任务：找到<strong>哪些被分配的内存确实已经不再需要了</strong></p>
<ol>
<li><p>引用计数垃圾收集<br>理解为 对象有没有其他对象引用它，如果没有就标记为<strong>零引用</strong>，对象将被垃圾回收机制回收<br>限制：循环引用的风险</p>
</li>
<li><p>标记-清除算法<br>理解为 对象是否可以获得 假定设置一个root对象，垃圾回收器会定期从根开始找所有从它开始引用的对象，如果从全局对象无法获取的对象则会被垃圾回收器回收<br>限制: 那些无法从根对象查询到的对象都将被清除（一般没问题）</p>
</li>
</ol>
<h3 id="this-的用法及含义"><a href="#this-的用法及含义" class="headerlink" title="this 的用法及含义"></a>this 的用法及含义</h3><p><strong>this取什么值是在函数被执行的时候确定的，不是在定义的时候</strong></p>
<p>this的指向问题</p>
<ol>
<li>作为普通函数 window</li>
<li>使用call bind apply （call可直接换this指向 bind是有返回值 返回值再调用）</li>
<li>作为对象方法被调用 指代的就是这个对象本身</li>
<li>在class方法中调用 当前实例本身 setTimeout注意</li>
<li>箭头函数  <code>()=&gt;&#123;this&#125;</code> 和上级作用域的值一致</li>
</ol>
<h3 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h3><ol>
<li>cookie<ol>
<li>特点<ol>
<li>本身用于浏览器和server通讯</li>
<li>可用<code>document.cookie = &#39;xxx&#39;</code>来修改</li>
</ol>
</li>
<li>缺点<ol>
<li>存储大小限制为4KB</li>
<li>http请求需要发送到服务端，增加请求数量</li>
<li>只能用document.cookie修改</li>
</ol>
</li>
</ol>
</li>
<li>localStorage 和 sessionStorage<ol>
<li>特点<ol>
<li>最大可存储 5MB</li>
<li>api 简单易用，setItem getItem</li>
<li>不会跟随 http 请求发送给服务端</li>
</ol>
</li>
<li>区别<ol>
<li>localStorage 会永久存储，除非手动删除</li>
<li>sessionStorage 数据只存在当前会话，浏览器关闭则清空</li>
<li>一般用 localStorage 较多</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="http-缓存（强制缓存-协商缓存）"><a href="#http-缓存（强制缓存-协商缓存）" class="headerlink" title="http 缓存（强制缓存 | 协商缓存）"></a>http 缓存（强制缓存 | 协商缓存）</h3><h4 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h4><p>网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p>
<h4 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h4><p>http 缓存机制主要在http相应头中设定，响应头中相关字段为 Expires,Cache-Control,Last-Modified,If-Modified-Since,Etag 等</p>
<ol>
<li>Expires</li>
<li>Cache-Control<ol>
<li>max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒</li>
<li>s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；</li>
<li>public：指示响应可被任何缓存区缓存；</li>
<li>private：只能针对个人用户，而不能被代理服务器缓存；</li>
<li>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</li>
<li>no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</li>
</ol>
</li>
</ol>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>过程：</p>
<ol>
<li>初次请求，服务器返回资源和cache-control</li>
<li>再次请求，本地缓存直接返回资源</li>
</ol>
<p>cache-control</p>
<h4 id="协商缓存（对比缓存）"><a href="#协商缓存（对比缓存）" class="headerlink" title="协商缓存（对比缓存）"></a>协商缓存（对比缓存）</h4><ul>
<li>服务端缓存策略。</li>
<li>服务端判断客户端资源，是否和服务端资源一样。</li>
<li>一致则返回 304，否则返回 200 和最新的资源。<br>过程：</li>
</ul>
<ol>
<li>初次请求，服务器端返回资源和资源标识</li>
<li>再次请求时带着资源标识，服务器端返回304，或返回资源（200）和新的资源标识</li>
</ol>
<p>资源标识：保存在Response Headers中</p>
<ol>
<li>Last-Modified： 资源的最后修改时间</li>
<li>Etag： 资源的唯一标识</li>
</ol>
<h5 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified  If-Modified-Since"></a>Last-modified  If-Modified-Since</h5><p>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p>
<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag  If-None-Match"></a>Etag  If-None-Match</h5><p>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，通过 <strong>If-None-match</strong>（就是Etag的值） 传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Etag的优先级比last-modified高</p>
<p>last-modified的不足：</p>
<ol>
<li>只能精确到秒级，如果一个文件一秒内多次修改，不能准确标注文件的修改时间</li>
<li>如果一个文件定期生成且内容没有变化，last-modified也会改变，导致无法使用缓存</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果，而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，<strong>不会影响阻塞</strong>后面的代码执行</p>
<ol>
<li>最开始实现异步都是采用<strong>回调函数</strong>实现的，但是有个缺点：回调地狱</li>
<li>为了解决回调地狱的问题，ES6提出了Promise的方式 （Generator配合yield方式）</li>
<li>ES7又提出新的异步解决方案 async/await async是Generator函数的语法糖，优点是使异步逻辑的代码跟同步一样容易理解</li>
</ol>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>TODO:实现一遍Promise A+规范</p>
<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>异步任务不进入主线程，而是进入<strong>任务队列</strong>，当主线程中的任务执行完毕，就从任务队列中取出任务放进主线程中来进行执行。由于主线程不断重复的获得任务、执行任务、再获取再执行，所以这种机制被叫做事件循环。</p>
<ol>
<li>event loop过程1<ol>
<li>同步代码，一行一行放在call Stack（执行栈）执行</li>
<li>遇到异步，会先记录下并交给其他线程处理，等待时机（定时，网络请求）</li>
<li>时机到了，就会移动到callback queue</li>
</ol>
</li>
<li>event loop过程2<ol>
<li>如果call stack为空（同步代码执行完），event loop开始工作</li>
<li>轮训查找callback queue，如果有则移动到call stack<ol>
<li>优先检查微任务队列是否有任务，没有的话再去宏任务队列检查</li>
</ol>
</li>
<li>然后继续轮训查找</li>
</ol>
</li>
</ol>
<p>另一种说法：</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ol>
<p>总结：</p>
<ol>
<li>tasks 按序执行，浏览器会在 tasks 之间执行渲染。</li>
<li>microtasks 按序执行，在下面情况时执行：<ol>
<li>在每个回调之后，只要没有其它代码正在运行。</li>
<li>在每个 task 的末尾</li>
</ol>
</li>
</ol>
<h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><p>异步任务队列不只一个，根据任务种类分为微任务队列(micro task/ Task)和宏任务队列(macro task/Jobs)</p>
<p>宏任务 -（当前微任务） - 渲染 - 宏任务 。。。</p>
<p><strong>微任务比宏任务执行时间要早</strong></p>
<p>常见宏任务：</p>
<ol>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate(Node)</li>
<li>点击事件或键盘事件 i/o事件</li>
<li>Ajax</li>
<li>script整体代码段</li>
<li>promise里面的代码</li>
</ol>
<p>常见微任务</p>
<ol>
<li><strong>promise.then</strong>,<strong>await</strong>（与then类似）,promise.catch</li>
<li>object.observe</li>
<li>new MutationObserver(浏览器环境)</li>
<li>process.nextTick(node)</li>
</ol>
<p>注意：async函数在await之前的代码都是<strong>同步</strong>执行的，可以理解为await之前的代码属于new Promise传入的代码，<strong>await之后的代码都是在Promise.then中的回调</strong></p>
<h3 id="柯里化-1"><a href="#柯里化-1" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化就是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a+ b + c<br>&#125;<br><span class="hljs-comment">// 柯里化之后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> a + b + c<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 调用时</span><br>sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h4 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h4><p>我们处理函数时，希望函数功能尽可能单一</p>
<h4 id="自动柯里化"><a href="#自动柯里化" class="headerlink" title="自动柯里化"></a>自动柯里化</h4><p>(个人感觉不重要，理解什么是柯里化即可)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCurried</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args1.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-literal">null</span>, ...args1)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">null</span>, [...args1, ...args2])<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b + c + d + e<br>&#125;<br><span class="hljs-keyword">let</span> resFunc = myCurried(sum)<br><span class="hljs-built_in">console</span>.log(resFunc(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">23</span>))<br><span class="hljs-comment">//解析:</span><br><span class="hljs-comment">//1、这里的fn.length获取的是函数传入参数的长度</span><br><span class="hljs-comment">//2、这里使用递归的思想</span><br></code></pre></td></tr></table></figure>

<h3 id="箭头函数的优缺点"><a href="#箭头函数的优缺点" class="headerlink" title="箭头函数的优缺点"></a>箭头函数的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>简写了函数</li>
<li><strong>改变this的指向为当前外部对象</strong></li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>没有arguments参数</li>
<li>无法通过apply bind call来改变this的指向</li>
</ol>
<h4 id="不能用于哪些场景"><a href="#不能用于哪些场景" class="headerlink" title="不能用于哪些场景"></a>不能用于哪些场景</h4><ol>
<li>不能用于对象方法</li>
<li>不能用于对象原型</li>
<li>不能用于构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-attr">getA</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log( obj.getA() ) <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="前端性能优化的措施"><a href="#前端性能优化的措施" class="headerlink" title="前端性能优化的措施"></a>前端性能优化的措施</h3><p><a target="_blank" rel="noopener" href="http://www.pczh.cn/news/22013.html">参考</a></p>
<h4 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h4><ol>
<li>减少请求数量<ol>
<li><strong>图片处理</strong><ol>
<li>雪碧图</li>
<li>Base64</li>
<li>使用字体图标</li>
</ol>
</li>
<li>减少重定向</li>
<li><strong>使用缓存</strong></li>
<li><strong>不使用CSS @import</strong></li>
<li>避免使用空的src和href</li>
</ol>
</li>
<li>减小资源大小<ol>
<li><strong>压缩 html css js 和图片均可压缩</strong></li>
<li><strong>使用webp格式的图片</strong></li>
<li><strong>开启gzip</strong>（www服务器中安装的功能，用来压缩网页内容后传输到来访的电脑浏览器中）</li>
</ol>
</li>
<li>优化网络连接<ol>
<li><strong>使用CDN</strong></li>
<li>使用DNS预解析 （DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度） <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx&quot;&gt;</code></li>
</ol>
</li>
<li>优化资源加载<ol>
<li><strong>资源加载位置</strong><ol>
<li>css放在head中，先外链，再本页</li>
<li>js放在body底部，先外链，再本页</li>
<li>处理页面及页面布局的js’文件放在head中，如flexible.js</li>
<li>body中尽量不写style和script标签</li>
</ol>
</li>
<li><strong>资源加载时机</strong><ol>
<li>异步script标签<ol>
<li>defer html解析完立即执行</li>
<li>async 加载完成后立即执行</li>
</ol>
</li>
<li>模块按需加载</li>
<li>使用资源预加载preload和资源预读取prefetch</li>
<li>资源懒加载和资源预加载</li>
</ol>
</li>
</ol>
</li>
<li>减少重绘回流<ol>
<li>避免使用层级较深的选择器</li>
<li>避免使用CSS表达式，计算频率太高</li>
<li><strong>元素适当的定义高度或设置最小高度，以免动态载入内容时出现页面元素晃动</strong></li>
<li><strong>给图片设置尺寸，不然从0到有会位移，产生回流</strong></li>
<li><strong>能用css实现就不要用js实现</strong></li>
<li>对需要多次重绘的元素独立为render layer渲染层，设置absolute</li>
</ol>
</li>
<li>DOM优化<ol>
<li>缓存DOM <code>const div = document.getElementById(&#39;div&#39;)</code></li>
<li>减少DOM深度</li>
<li><strong>批量操作DOM</strong> 比如先拼接完字符串再更新DOM</li>
<li><strong>事件代理</strong></li>
<li><strong>防抖和节流</strong></li>
</ol>
</li>
<li>构建优化<ol>
<li>打包公共代码 使用CommonsChunkPlugin插件 参考</li>
<li><strong>动态导入和按需加载</strong></li>
<li><strong>剔除无用代码</strong> tree shaking 主要插件 uglifyjs purifyCSS</li>
<li>长缓存优化（忽略）</li>
</ol>
</li>
</ol>
<h2 id="vue-相关"><a href="#vue-相关" class="headerlink" title="vue 相关"></a>vue 相关</h2><h3 id="vue-的优势"><a href="#vue-的优势" class="headerlink" title="vue 的优势"></a>vue 的优势</h3><h3 id="mvvm-和-mvc-区别"><a href="#mvvm-和-mvc-区别" class="headerlink" title="mvvm 和 mvc 区别"></a>mvvm 和 mvc 区别</h3><h3 id="vue-双向绑定的原理"><a href="#vue-双向绑定的原理" class="headerlink" title="vue 双向绑定的原理"></a>vue 双向绑定的原理</h3><h3 id="vue2-和-vue3-双向绑定原理的区别-：proxy"><a href="#vue2-和-vue3-双向绑定原理的区别-：proxy" class="headerlink" title="vue2 和 vue3 双向绑定原理的区别 ：proxy"></a>vue2 和 vue3 双向绑定原理的区别 ：proxy</h3><h3 id="data-为啥是函数"><a href="#data-为啥是函数" class="headerlink" title="data 为啥是函数"></a>data 为啥是函数</h3><h3 id="data-computed-watch-的依赖关系"><a href="#data-computed-watch-的依赖关系" class="headerlink" title="data computed watch 的依赖关系"></a>data computed watch 的依赖关系</h3><h3 id="为啥-v-for-和-v-if-不建议一起用"><a href="#为啥-v-for-和-v-if-不建议一起用" class="headerlink" title="为啥 v-for 和 v-if 不建议一起用"></a>为啥 v-for 和 v-if 不建议一起用</h3><h3 id="插槽（匿名，具名，作用域）及用法"><a href="#插槽（匿名，具名，作用域）及用法" class="headerlink" title="插槽（匿名，具名，作用域）及用法"></a>插槽（匿名，具名，作用域）及用法</h3><h3 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h3><h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><h3 id="封装的-vue-组件"><a href="#封装的-vue-组件" class="headerlink" title="封装的 vue 组件"></a>封装的 vue 组件</h3><h3 id="vue-的-template-是怎么编译的"><a href="#vue-的-template-是怎么编译的" class="headerlink" title="vue 的 template 是怎么编译的"></a>vue 的 template 是怎么编译的</h3><h3 id="vue-的两种路由模式-hash-和-history"><a href="#vue-的两种路由模式-hash-和-history" class="headerlink" title="vue 的两种路由模式 hash 和 history"></a>vue 的两种路由模式 hash 和 history</h3><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h3><h3 id="动态路由怎么获取传递的动态参数"><a href="#动态路由怎么获取传递的动态参数" class="headerlink" title="动态路由怎么获取传递的动态参数"></a>动态路由怎么获取传递的动态参数</h3><h3 id="vue-router-的钩子函数"><a href="#vue-router-的钩子函数" class="headerlink" title="vue-router 的钩子函数"></a>vue-router 的钩子函数</h3><h3 id="路由传值的方式"><a href="#路由传值的方式" class="headerlink" title="路由传值的方式"></a>路由传值的方式</h3><h3 id="vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决"><a href="#vue-中-data-数组的方法哪些不可以触发视图更新？不行的话怎么解决" class="headerlink" title="vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决"></a>vue 中 data 数组的方法哪些不可以触发视图更新？不行的话怎么解决</h3><h3 id="vue-首屏加载优化方案"><a href="#vue-首屏加载优化方案" class="headerlink" title="vue 首屏加载优化方案"></a>vue 首屏加载优化方案</h3><h3 id="vue-的-nextTick"><a href="#vue-的-nextTick" class="headerlink" title="vue 的 nextTick"></a>vue 的 nextTick</h3><h3 id="mixin-的用法"><a href="#mixin-的用法" class="headerlink" title="mixin 的用法"></a>mixin 的用法</h3><h3 id="虚拟-dom-的理解及其优点"><a href="#虚拟-dom-的理解及其优点" class="headerlink" title="虚拟 dom 的理解及其优点"></a>虚拟 dom 的理解及其优点</h3><h3 id="vue-底层是怎么实现对数组的监听的"><a href="#vue-底层是怎么实现对数组的监听的" class="headerlink" title="vue 底层是怎么实现对数组的监听的"></a>vue 底层是怎么实现对数组的监听的</h3><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="http执行机制"><a href="#http执行机制" class="headerlink" title="http执行机制"></a>http执行机制</h3><h3 id="从-url-被输入到请求返回发生了什么"><a href="#从-url-被输入到请求返回发生了什么" class="headerlink" title="从 url 被输入到请求返回发生了什么"></a>从 url 被输入到请求返回发生了什么</h3><ol>
<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。<ol>
<li>强缓存</li>
<li>协商缓存</li>
</ol>
</li>
<li>DNS 域名解析</li>
<li>TCP 连接<blockquote>
<p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</p>
</blockquote>
</li>
<li>HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器渲染页面（important）<ol>
<li>先将HTML加载到浏览器的内部。</li>
<li>从上往下开始解析HTML。</li>
<li>当解析到引入的外部CSS文件时，另一个线程开始加载CSS文件，HTML继续解析。</li>
<li>浏览器解析DOM文档时，会将DOM文档解析成一棵树结构–DOM Tree，用来更清晰的显示出标签之间的层级关系。</li>
<li>HTML解析完毕之后，等待CSS解析。</li>
<li>CSS文件会被解析成CSS规则树(CSSOM Tree)，解析完毕之后会将每个节点的样式附加到DOM Tree形成布局树，最后再化为Render Tree （渲染树）</li>
<li>在渲染树(Reader Tree)上运行布局(Layout) 以计算每个节点的几何体，然后将每个节点绘制 到屏幕上</li>
</ol>
</li>
<li>断开 TCP 连接</li>
</ol>
<h3 id="前端缓存的几种缓存方式"><a href="#前端缓存的几种缓存方式" class="headerlink" title="前端缓存的几种缓存方式"></a>前端缓存的几种缓存方式</h3><h2 id="webpack-相关"><a href="#webpack-相关" class="headerlink" title="webpack 相关"></a>webpack 相关</h2><h2 id="typescript-和-vue3-相关"><a href="#typescript-和-vue3-相关" class="headerlink" title="typescript 和 vue3 相关"></a>typescript 和 vue3 相关</h2><h2 id="uniapp-相关"><a href="#uniapp-相关" class="headerlink" title="uniapp 相关"></a>uniapp 相关</h2><h2 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="遇到最困难的问题是啥-怎么解决"><a href="#遇到最困难的问题是啥-怎么解决" class="headerlink" title="遇到最困难的问题是啥 怎么解决"></a>遇到最困难的问题是啥 怎么解决</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7031322059414175774">参考 1</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7061588533214969892">参考 2</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/14/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/">
                        <span class="hidden-mobile">后台管理系统登录功能的实现</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"SENRU08HPXafOGhG2XAwDq4Q-gzGzoHsz","appKey":"SmBXysKuOGYdFfLXpPenWmvh","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/ZhangKai66" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
